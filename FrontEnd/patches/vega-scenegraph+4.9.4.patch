diff --git a/node_modules/vega-scenegraph/build/vega-scenegraph-schema.json b/node_modules/vega-scenegraph/build/vega-scenegraph-schema.json
deleted file mode 100644
index 28486b4..0000000
--- a/node_modules/vega-scenegraph/build/vega-scenegraph-schema.json
+++ /dev/null
@@ -1,2150 +0,0 @@
-{
-  "$schema": "http://json-schema.org/draft-07/schema#",
-  "title": "Vega scenegraph",
-  "description": "Vega scenegraph model.",
-  "oneOf": [
-    {
-      "$ref": "#/definitions/mark"
-    }
-  ],
-  "definitions": {
-    "mark": {
-      "oneOf": [
-        {
-          "$ref": "#/definitions/mark-group"
-        },
-        {
-          "$ref": "#/definitions/mark-arc"
-        },
-        {
-          "$ref": "#/definitions/mark-area"
-        },
-        {
-          "$ref": "#/definitions/mark-image"
-        },
-        {
-          "$ref": "#/definitions/mark-line"
-        },
-        {
-          "$ref": "#/definitions/mark-path"
-        },
-        {
-          "$ref": "#/definitions/mark-rect"
-        },
-        {
-          "$ref": "#/definitions/mark-rule"
-        },
-        {
-          "$ref": "#/definitions/mark-symbol"
-        },
-        {
-          "$ref": "#/definitions/mark-text"
-        },
-        {
-          "$ref": "#/definitions/mark-trail"
-        }
-      ]
-    },
-    "path": {
-      "type": "string",
-      "pattern": "^[ \t\r\f]*([Mm][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*[ \t\r\f]*(([Zz]|[LlTt][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*|[HhVv][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*|[Cc][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?){2}(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?){2})*|[QqSs][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*|[Aa][ \t\r\f]*[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)?[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)?[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*)(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??([Zz]|[LlTt][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*|[HhVv][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*|[Cc][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?){2}(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?){2})*|[QqSs][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*|[Aa][ \t\r\f]*[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)?[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)?[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*))*)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[Mm][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*[ \t\r\f]*(([Zz]|[LlTt][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*|[HhVv][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*|[Cc][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?){2}(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?){2})*|[QqSs][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*|[Aa][ \t\r\f]*[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)?[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)?[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*)(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??([Zz]|[LlTt][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*|[HhVv][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*|[Cc][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?){2}(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?){2})*|[QqSs][ \t\r\f]*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*|[Aa][ \t\r\f]*[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)?[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?(([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)?[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[01]([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?([ \t\r\f]+,?[ \t\r\f]*|,[ \t\r\f]*)??[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)*))*)?)*)?[ \t\r\f]*$"
-    },
-    "paint": {
-      "oneOf": [
-        {
-          "$ref": "#/definitions/color"
-        },
-        {
-          "$ref": "#/definitions/linearGradient"
-        },
-        {
-          "$ref": "#/definitions/radialGradient"
-        }
-      ]
-    },
-    "color": {
-      "oneOf": [
-        {
-          "type": "string",
-          "pattern": "^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$"
-        },
-        {
-          "type": "string",
-          "pattern": "^rgb\\([ \t\f]*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(,[ \t\f]*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){2}[ \t\f]*\\)$"
-        },
-        {
-          "type": "string",
-          "pattern": "^rgb\\([ \t\f]*([0-9]|[1-9][0-9]|100)%(,[ \t\f]*([0-9]|[1-9][0-9]|100)%){2}[ \t\f]*\\)$"
-        },
-        {
-          "type": "string",
-          "pattern": "^hsl\\([ \t\f]*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9]|360)(,[ \t\f]*([0-9]|[1-9][0-9]|100)%){2}[ \t\f]*\\)$"
-        },
-        {
-          "type": "string",
-          "pattern": "^([Aa][Ll][Ii][Cc][Ee][Bb][Ll][Uu][Ee]|[Aa][Nn][Tt][Ii][Qq][Uu][Ee][Ww][Hh][Ii][Tt][Ee]|[Aa][Qq][Uu][Aa]|[Aa][Qq][Uu][Aa][Mm][Aa][Rr][Ii][Nn][Ee]|[Aa][Zz][Uu][Rr][Ee]|[Bb][Ee][Ii][Gg][Ee]|[Bb][Ii][Ss][Qq][Uu][Ee]|[Bb][Ll][Aa][Cc][Kk]|[Bb][Ll][Aa][Nn][Cc][Hh][Ee][Dd][Aa][Ll][Mm][Oo][Nn][Dd]|[Bb][Ll][Uu][Ee]|[Bb][Ll][Uu][Ee][Vv][Ii][Oo][Ll][Ee][Tt]|[Bb][Rr][Oo][Ww][Nn]|[Bb][Uu][Rr][Ll][Yy][Ww][Oo][Oo][Dd]|[Cc][Aa][Dd][Ee][Tt][Bb][Ll][Uu][Ee]|[Cc][Hh][Aa][Rr][Tt][Rr][Ee][Uu][Ss][Ee]|[Cc][Hh][Oo][Cc][Oo][Ll][Aa][Tt][Ee]|[Cc][Oo][Rr][Aa][Ll]|[Cc][Oo][Rr][Nn][Ff][Ll][Oo][Ww][Ee][Rr][Bb][Ll][Uu][Ee]|[Cc][Oo][Rr][Nn][Ss][Ii][Ll][Kk]|[Cc][Rr][Ii][Mm][Ss][Oo][Nn]|[Cc][Yy][Aa][Nn]|[Dd][Aa][Rr][Kk][Bb][Ll][Uu][Ee]|[Dd][Aa][Rr][Kk][Cc][Yy][Aa][Nn]|[Dd][Aa][Rr][Kk][Gg][Oo][Ll][Dd][Ee][Nn][Rr][Oo][Dd]|[Dd][Aa][Rr][Kk][Gg][Rr][Aa][Yy]|[Dd][Aa][Rr][Kk][Gg][Rr][Ee][Ee][Nn]|[Dd][Aa][Rr][Kk][Kk][Hh][Aa][Kk][Ii]|[Dd][Aa][Rr][Kk][Mm][Aa][Gg][Ee][Nn][Tt][Aa]|[Dd][Aa][Rr][Kk][Oo][Ll][Ii][Vv][Ee][Gg][Rr][Ee][Ee][Nn]|[Dd][Aa][Rr][Kk][Oo][Rr][Aa][Nn][Gg][Ee]|[Dd][Aa][Rr][Kk][Oo][Rr][Cc][Hh][Ii][Dd]|[Dd][Aa][Rr][Kk][Rr][Ee][Dd]|[Dd][Aa][Rr][Kk][Ss][Aa][Ll][Mm][Oo][Nn]|[Dd][Aa][Rr][Kk][Ss][Ee][Aa][Gg][Rr][Ee][Ee][Nn]|[Dd][Aa][Rr][Kk][Ss][Ll][Aa][Tt][Ee][Bb][Ll][Uu][Ee]|[Dd][Aa][Rr][Kk][Ss][Ll][Aa][Tt][Ee][Gg][Rr][Aa][Yy]|[Dd][Aa][Rr][Kk][Tt][Uu][Rr][Qq][Uu][Oo][Ii][Ss][Ee]|[Dd][Aa][Rr][Kk][Vv][Ii][Oo][Ll][Ee][Tt]|[Dd][Ee][Ee][Pp][Pp][Ii][Nn][Kk]|[Dd][Ee][Ee][Pp][Ss][Kk][Yy][Bb][Ll][Uu][Ee]|[Dd][Ii][Mm][Gg][Rr][Aa][Yy]|[Dd][Oo][Dd][Gg][Ee][Rr][Bb][Ll][Uu][Ee]|[Ff][Ii][Rr][Ee][Bb][Rr][Ii][Cc][Kk]|[Ff][Ll][Oo][Rr][Aa][Ll][Ww][Hh][Ii][Tt][Ee]|[Ff][Oo][Rr][Ee][Ss][Tt][Gg][Rr][Ee][Ee][Nn]|[Ff][Uu][Cc][Hh][Ss][Ii][Aa]|[Gg][Aa][Ii][Nn][Ss][Bb][Oo][Rr][Oo]|[Gg][Hh][Oo][Ss][Tt][Ww][Hh][Ii][Tt][Ee]|[Gg][Oo][Ll][Dd]|[Gg][Oo][Ll][Dd][Ee][Nn][Rr][Oo][Dd]|[Gg][Rr][Aa][Yy]|[Gg][Rr][Ee][Ee][Nn]|[Gg][Rr][Ee][Ee][Nn][Yy][Ee][Ll][Ll][Oo][Ww]|[Hh][Oo][Nn][Ee][Yy][Dd][Ee][Ww]|[Hh][Oo][Tt][Pp][Ii][Nn][Kk]|[Ii][Nn][Dd][Ii][Aa][Nn][Rr][Ee][Dd]|[Ii][Nn][Dd][Ii][Gg][Oo]|[Ii][Vv][Oo][Rr][Yy]|[Kk][Hh][Aa][Kk][Ii]|[Ll][Aa][Vv][Ee][Nn][Dd][Ee][Rr]|[Ll][Aa][Vv][Ee][Nn][Dd][Ee][Rr][Bb][Ll][Uu][Ss][Hh]|[Ll][Aa][Ww][Nn][Gg][Rr][Ee][Ee][Nn]|[Ll][Ee][Mm][Oo][Nn][Cc][Hh][Ii][Ff][Ff][Oo][Nn]|[Ll][Ii][Gg][Hh][Tt][Bb][Ll][Uu][Ee]|[Ll][Ii][Gg][Hh][Tt][Cc][Oo][Rr][Aa][Ll]|[Ll][Ii][Gg][Hh][Tt][Cc][Yy][Aa][Nn]|[Ll][Ii][Gg][Hh][Tt][Gg][Oo][Ll][Dd][Ee][Nn][Rr][Oo][Dd][Yy][Ee][Ll][Ll][Oo][Ww]|[Ll][Ii][Gg][Hh][Tt][Gg][Rr][Aa][Yy]|[Ll][Ii][Gg][Hh][Tt][Gg][Rr][Ee][Ee][Nn]|[Ll][Ii][Gg][Hh][Tt][Pp][Ii][Nn][Kk]|[Ll][Ii][Gg][Hh][Tt][Ss][Aa][Ll][Mm][Oo][Nn]|[Ll][Ii][Gg][Hh][Tt][Ss][Ee][Aa][Gg][Rr][Ee][Ee][Nn]|[Ll][Ii][Gg][Hh][Tt][Ss][Kk][Yy][Bb][Ll][Uu][Ee]|[Ll][Ii][Gg][Hh][Tt][Ss][Ll][Aa][Tt][Ee][Gg][Rr][Aa][Yy]|[Ll][Ii][Gg][Hh][Tt][Ss][Tt][Ee][Ee][Ll][Bb][Ll][Uu][Ee]|[Ll][Ii][Gg][Hh][Tt][Yy][Ee][Ll][Ll][Oo][Ww]|[Ll][Ii][Mm][Ee]|[Ll][Ii][Mm][Ee][Gg][Rr][Ee][Ee][Nn]|[Ll][Ii][Nn][Ee][Nn]|[Mm][Aa][Gg][Ee][Nn][Tt][Aa]|[Mm][Aa][Rr][Oo][Oo][Nn]|[Mm][Ee][Dd][Ii][Uu][Mm][Aa][Qq][Uu][Aa][Mm][Aa][Rr][Ii][Nn][Ee]|[Mm][Ee][Dd][Ii][Uu][Mm][Bb][Ll][Uu][Ee]|[Mm][Ee][Dd][Ii][Uu][Mm][Oo][Rr][Cc][Hh][Ii][Dd]|[Mm][Ee][Dd][Ii][Uu][Mm][Pp][Uu][Rr][Pp][Ll][Ee]|[Mm][Ee][Dd][Ii][Uu][Mm][Ss][Ee][Aa][Gg][Rr][Ee][Ee][Nn]|[Mm][Ee][Dd][Ii][Uu][Mm][Ss][Ll][Aa][Tt][Ee][Bb][Ll][Uu][Ee]|[Mm][Ee][Dd][Ii][Uu][Mm][Ss][Pp][Rr][Ii][Nn][Gg][Gg][Rr][Ee][Ee][Nn]|[Mm][Ee][Dd][Ii][Uu][Mm][Tt][Uu][Rr][Qq][Uu][Oo][Ii][Ss][Ee]|[Mm][Ee][Dd][Ii][Uu][Mm][Vv][Ii][Oo][Ll][Ee][Tt][Rr][Ee][Dd]|[Mm][Ii][Dd][Nn][Ii][Gg][Hh][Tt][Bb][Ll][Uu][Ee]|[Mm][Ii][Nn][Tt][Cc][Rr][Ee][Aa][Mm]|[Mm][Ii][Ss][Tt][Yy][Rr][Oo][Ss][Ee]|[Mm][Oo][Cc][Cc][Aa][Ss][Ii][Nn]|[Nn][Aa][Vv][Aa][Jj][Oo][Ww][Hh][Ii][Tt][Ee]|[Nn][Aa][Vv][Yy]|[Oo][Ll][Dd][Ll][Aa][Cc][Ee]|[Oo][Ll][Ii][Vv][Ee]|[Oo][Ll][Ii][Vv][Ee][Dd][Rr][Aa][Bb]|[Oo][Rr][Aa][Nn][Gg][Ee]|[Oo][Rr][Aa][Nn][Gg][Ee][Rr][Ee][Dd]|[Oo][Rr][Cc][Hh][Ii][Dd]|[Pp][Aa][Ll][Ee][Gg][Oo][Ll][Dd][Ee][Nn][Rr][Oo][Dd]|[Pp][Aa][Ll][Ee][Gg][Rr][Ee][Ee][Nn]|[Pp][Aa][Ll][Ee][Tt][Uu][Rr][Qq][Uu][Oo][Ii][Ss][Ee]|[Pp][Aa][Ll][Ee][Vv][Ii][Oo][Ll][Ee][Tt][Rr][Ee][Dd]|[Pp][Aa][Pp][Aa][Yy][Aa][Ww][Hh][Ii][Pp]|[Pp][Ee][Aa][Cc][Hh][Pp][Uu][Ff][Ff]|[Pp][Ee][Rr][Uu]|[Pp][Ii][Nn][Kk]|[Pp][Ll][Uu][Mm]|[Pp][Oo][Ww][Dd][Ee][Rr][Bb][Ll][Uu][Ee]|[Pp][Uu][Rr][Pp][Ll][Ee]|[Rr][Ee][Bb][Ee][Cc][Cc][Aa][Pp][Uu][Rr][Pp][Ll][Ee]|[Rr][Ee][Dd]|[Rr][Oo][Ss][Yy][Bb][Rr][Oo][Ww][Nn]|[Rr][Oo][Yy][Aa][Ll][Bb][Ll][Uu][Ee]|[Ss][Aa][Dd][Dd][Ll][Ee][Bb][Rr][Oo][Ww][Nn]|[Ss][Aa][Ll][Mm][Oo][Nn]|[Ss][Aa][Nn][Dd][Yy][Bb][Rr][Oo][Ww][Nn]|[Ss][Ee][Aa][Gg][Rr][Ee][Ee][Nn]|[Ss][Ee][Aa][Ss][Hh][Ee][Ll][Ll]|[Ss][Ii][Ee][Nn][Nn][Aa]|[Ss][Ii][Ll][Vv][Ee][Rr]|[Ss][Kk][Yy][Bb][Ll][Uu][Ee]|[Ss][Ll][Aa][Tt][Ee][Bb][Ll][Uu][Ee]|[Ss][Ll][Aa][Tt][Ee][Gg][Rr][Aa][Yy]|[Ss][Nn][Oo][Ww]|[Ss][Pp][Rr][Ii][Nn][Gg][Gg][Rr][Ee][Ee][Nn]|[Ss][Tt][Ee][Ee][Ll][Bb][Ll][Uu][Ee]|[Tt][Aa][Nn]|[Tt][Ee][Aa][Ll]|[Tt][Hh][Ii][Ss][Tt][Ll][Ee]|[Tt][Oo][Mm][Aa][Tt][Oo]|[Tt][Uu][Rr][Qq][Uu][Oo][Ii][Ss][Ee]|[Vv][Ii][Oo][Ll][Ee][Tt]|[Ww][Hh][Ee][Aa][Tt]|[Ww][Hh][Ii][Tt][Ee]|[Ww][Hh][Ii][Tt][Ee][Ss][Mm][Oo][Kk][Ee]|[Yy][Ee][Ll][Ll][Oo][Ww]|[Yy][Ee][Ll][Ll][Oo][Ww][Gg][Rr][Ee][Ee][Nn])$"
-        }
-      ]
-    },
-    "gradientStop": {
-      "type": "object",
-      "properties": {
-        "offset": {
-          "type": "number"
-        },
-        "color": {
-          "$ref": "#/definitions/color"
-        }
-      },
-      "required": [
-        "offset",
-        "color"
-      ]
-    },
-    "linearGradient": {
-      "type": "object",
-      "properties": {
-        "gradient": {
-          "enum": [
-            "linear"
-          ]
-        },
-        "id": {
-          "type": "string"
-        },
-        "x1": {
-          "type": "number"
-        },
-        "y1": {
-          "type": "number"
-        },
-        "x2": {
-          "type": "number"
-        },
-        "y2": {
-          "type": "number"
-        },
-        "stops": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/gradientStop"
-          }
-        }
-      },
-      "required": [
-        "gradient",
-        "stops"
-      ],
-      "additionalProperties": false
-    },
-    "radialGradient": {
-      "type": "object",
-      "properties": {
-        "gradient": {
-          "enum": [
-            "radial"
-          ]
-        },
-        "id": {
-          "type": "string"
-        },
-        "x1": {
-          "type": "number"
-        },
-        "y1": {
-          "type": "number"
-        },
-        "r1": {
-          "type": "number"
-        },
-        "x2": {
-          "type": "number"
-        },
-        "y2": {
-          "type": "number"
-        },
-        "r2": {
-          "type": "number"
-        },
-        "stops": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/gradientStop"
-          }
-        }
-      },
-      "required": [
-        "gradient",
-        "stops"
-      ],
-      "additionalProperties": false
-    },
-    "mark-group": {
-      "type": "object",
-      "properties": {
-        "marktype": {
-          "enum": [
-            "group"
-          ]
-        },
-        "name": {
-          "type": "string"
-        },
-        "role": {
-          "type": "string"
-        },
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "interactive": {
-          "type": "boolean",
-          "default": true
-        },
-        "items": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/item-group"
-          }
-        },
-        "zindex": {
-          "type": "number"
-        }
-      },
-      "required": [
-        "marktype"
-      ],
-      "additionalProperties": false
-    },
-    "item-group": {
-      "type": "object",
-      "properties": {
-        "x": {
-          "type": "number"
-        },
-        "y": {
-          "type": "number"
-        },
-        "width": {
-          "type": "number"
-        },
-        "height": {
-          "type": "number"
-        },
-        "blend": {
-          "enum": [
-            null,
-            "multiply",
-            "screen",
-            "overlay",
-            "darken",
-            "lighten",
-            "color-dodge",
-            "color-burn",
-            "hard-light",
-            "soft-light",
-            "difference",
-            "exclusion",
-            "hue",
-            "saturation",
-            "color",
-            "luminosity"
-          ],
-          "default": null
-        },
-        "opacity": {
-          "type": "number",
-          "default": 1
-        },
-        "fill": {
-          "$ref": "#/definitions/paint"
-        },
-        "fillOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "stroke": {
-          "$ref": "#/definitions/paint"
-        },
-        "strokeOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeWidth": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeCap": {
-          "enum": [
-            "butt",
-            "cap",
-            "round"
-          ],
-          "default": "butt"
-        },
-        "strokeJoin": {
-          "enum": [
-            "miter",
-            "round",
-            "bevel"
-          ],
-          "default": "miter"
-        },
-        "strokeMiterLimit": {
-          "type": "number"
-        },
-        "strokeDash": {
-          "type": "array",
-          "items": {
-            "type": "number"
-          }
-        },
-        "strokeDashOffset": {
-          "type": "number",
-          "default": 0
-        },
-        "zindex": {
-          "type": "number"
-        },
-        "cursor": {
-          "type": "string"
-        },
-        "href": {
-          "type": "string",
-          "format": "uri-reference"
-        },
-        "tooltip": {},
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "ariaRole": {
-          "type": "string"
-        },
-        "ariaRoleDescription": {
-          "type": "string"
-        },
-        "clip": {
-          "type": "boolean"
-        },
-        "cornerRadius": {
-          "type": "number"
-        },
-        "cornerRadiusTopLeft": {
-          "type": "number"
-        },
-        "cornerRadiusTopRight": {
-          "type": "number"
-        },
-        "cornerRadiusBottomRight": {
-          "type": "number"
-        },
-        "cornerRadiusBottomLeft": {
-          "type": "number"
-        },
-        "items": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/mark"
-          }
-        },
-        "strokeForeground": {
-          "type": "boolean"
-        },
-        "strokeOffset": {
-          "type": "number"
-        }
-      },
-      "additionalProperties": false
-    },
-    "mark-arc": {
-      "type": "object",
-      "properties": {
-        "marktype": {
-          "enum": [
-            "arc"
-          ]
-        },
-        "name": {
-          "type": "string"
-        },
-        "role": {
-          "type": "string"
-        },
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "interactive": {
-          "type": "boolean",
-          "default": true
-        },
-        "items": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/item-arc"
-          }
-        },
-        "zindex": {
-          "type": "number"
-        }
-      },
-      "required": [
-        "marktype"
-      ],
-      "additionalProperties": false
-    },
-    "item-arc": {
-      "type": "object",
-      "properties": {
-        "x": {
-          "type": "number"
-        },
-        "y": {
-          "type": "number"
-        },
-        "width": {
-          "type": "number"
-        },
-        "height": {
-          "type": "number"
-        },
-        "blend": {
-          "enum": [
-            null,
-            "multiply",
-            "screen",
-            "overlay",
-            "darken",
-            "lighten",
-            "color-dodge",
-            "color-burn",
-            "hard-light",
-            "soft-light",
-            "difference",
-            "exclusion",
-            "hue",
-            "saturation",
-            "color",
-            "luminosity"
-          ],
-          "default": null
-        },
-        "opacity": {
-          "type": "number",
-          "default": 1
-        },
-        "fill": {
-          "$ref": "#/definitions/paint"
-        },
-        "fillOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "stroke": {
-          "$ref": "#/definitions/paint"
-        },
-        "strokeOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeWidth": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeCap": {
-          "enum": [
-            "butt",
-            "cap",
-            "round"
-          ],
-          "default": "butt"
-        },
-        "strokeJoin": {
-          "enum": [
-            "miter",
-            "round",
-            "bevel"
-          ],
-          "default": "miter"
-        },
-        "strokeMiterLimit": {
-          "type": "number"
-        },
-        "strokeDash": {
-          "type": "array",
-          "items": {
-            "type": "number"
-          }
-        },
-        "strokeDashOffset": {
-          "type": "number",
-          "default": 0
-        },
-        "zindex": {
-          "type": "number"
-        },
-        "cursor": {
-          "type": "string"
-        },
-        "href": {
-          "type": "string",
-          "format": "uri-reference"
-        },
-        "tooltip": {},
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "ariaRole": {
-          "type": "string"
-        },
-        "ariaRoleDescription": {
-          "type": "string"
-        },
-        "startAngle": {
-          "type": "number"
-        },
-        "endAngle": {
-          "type": "number"
-        },
-        "padAngle": {
-          "type": "number"
-        },
-        "innerRadius": {
-          "type": "number"
-        },
-        "outerRadius": {
-          "type": "number"
-        },
-        "cornerRadius": {
-          "type": "number"
-        }
-      },
-      "additionalProperties": false
-    },
-    "mark-area": {
-      "type": "object",
-      "properties": {
-        "marktype": {
-          "enum": [
-            "area"
-          ]
-        },
-        "name": {
-          "type": "string"
-        },
-        "role": {
-          "type": "string"
-        },
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "interactive": {
-          "type": "boolean",
-          "default": true
-        },
-        "items": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/item-area"
-          }
-        },
-        "zindex": {
-          "type": "number"
-        }
-      },
-      "required": [
-        "marktype"
-      ],
-      "additionalProperties": false
-    },
-    "item-area": {
-      "type": "object",
-      "properties": {
-        "x": {
-          "type": "number"
-        },
-        "y": {
-          "type": "number"
-        },
-        "width": {
-          "type": "number"
-        },
-        "height": {
-          "type": "number"
-        },
-        "blend": {
-          "enum": [
-            null,
-            "multiply",
-            "screen",
-            "overlay",
-            "darken",
-            "lighten",
-            "color-dodge",
-            "color-burn",
-            "hard-light",
-            "soft-light",
-            "difference",
-            "exclusion",
-            "hue",
-            "saturation",
-            "color",
-            "luminosity"
-          ],
-          "default": null
-        },
-        "opacity": {
-          "type": "number",
-          "default": 1
-        },
-        "fill": {
-          "$ref": "#/definitions/paint"
-        },
-        "fillOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "stroke": {
-          "$ref": "#/definitions/paint"
-        },
-        "strokeOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeWidth": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeCap": {
-          "enum": [
-            "butt",
-            "cap",
-            "round"
-          ],
-          "default": "butt"
-        },
-        "strokeJoin": {
-          "enum": [
-            "miter",
-            "round",
-            "bevel"
-          ],
-          "default": "miter"
-        },
-        "strokeMiterLimit": {
-          "type": "number"
-        },
-        "strokeDash": {
-          "type": "array",
-          "items": {
-            "type": "number"
-          }
-        },
-        "strokeDashOffset": {
-          "type": "number",
-          "default": 0
-        },
-        "zindex": {
-          "type": "number"
-        },
-        "cursor": {
-          "type": "string"
-        },
-        "href": {
-          "type": "string",
-          "format": "uri-reference"
-        },
-        "tooltip": {},
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "ariaRole": {
-          "type": "string"
-        },
-        "ariaRoleDescription": {
-          "type": "string"
-        },
-        "defined": {
-          "type": "boolean"
-        },
-        "interpolate": {
-          "enum": [
-            "basis",
-            "cardinal",
-            "catmull-rom",
-            "linear",
-            "monotone",
-            "natural",
-            "step",
-            "step-after",
-            "step-before"
-          ]
-        },
-        "tension": {
-          "type": "number"
-        },
-        "orient": {
-          "enum": [
-            "horizontal",
-            "vertical"
-          ]
-        }
-      },
-      "additionalProperties": false
-    },
-    "mark-image": {
-      "type": "object",
-      "properties": {
-        "marktype": {
-          "enum": [
-            "image"
-          ]
-        },
-        "name": {
-          "type": "string"
-        },
-        "role": {
-          "type": "string"
-        },
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "interactive": {
-          "type": "boolean",
-          "default": true
-        },
-        "items": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/item-image"
-          }
-        },
-        "zindex": {
-          "type": "number"
-        }
-      },
-      "required": [
-        "marktype"
-      ],
-      "additionalProperties": false
-    },
-    "item-image": {
-      "type": "object",
-      "properties": {
-        "x": {
-          "type": "number"
-        },
-        "y": {
-          "type": "number"
-        },
-        "width": {
-          "type": "number"
-        },
-        "height": {
-          "type": "number"
-        },
-        "blend": {
-          "enum": [
-            null,
-            "multiply",
-            "screen",
-            "overlay",
-            "darken",
-            "lighten",
-            "color-dodge",
-            "color-burn",
-            "hard-light",
-            "soft-light",
-            "difference",
-            "exclusion",
-            "hue",
-            "saturation",
-            "color",
-            "luminosity"
-          ],
-          "default": null
-        },
-        "opacity": {
-          "type": "number",
-          "default": 1
-        },
-        "fill": {
-          "$ref": "#/definitions/paint"
-        },
-        "fillOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "stroke": {
-          "$ref": "#/definitions/paint"
-        },
-        "strokeOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeWidth": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeCap": {
-          "enum": [
-            "butt",
-            "cap",
-            "round"
-          ],
-          "default": "butt"
-        },
-        "strokeJoin": {
-          "enum": [
-            "miter",
-            "round",
-            "bevel"
-          ],
-          "default": "miter"
-        },
-        "strokeMiterLimit": {
-          "type": "number"
-        },
-        "strokeDash": {
-          "type": "array",
-          "items": {
-            "type": "number"
-          }
-        },
-        "strokeDashOffset": {
-          "type": "number",
-          "default": 0
-        },
-        "zindex": {
-          "type": "number"
-        },
-        "cursor": {
-          "type": "string"
-        },
-        "href": {
-          "type": "string",
-          "format": "uri-reference"
-        },
-        "tooltip": {},
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "ariaRole": {
-          "type": "string"
-        },
-        "ariaRoleDescription": {
-          "type": "string"
-        },
-        "url": {
-          "type": "string",
-          "format": "uri-reference"
-        },
-        "aspect": {
-          "type": "boolean",
-          "default": true
-        },
-        "smooth": {
-          "type": "boolean",
-          "default": true
-        },
-        "align": {
-          "enum": [
-            "left",
-            "center",
-            "right"
-          ],
-          "default": "left"
-        },
-        "baseline": {
-          "enum": [
-            "top",
-            "middle",
-            "bottom"
-          ],
-          "default": "top"
-        }
-      },
-      "additionalProperties": false
-    },
-    "mark-line": {
-      "type": "object",
-      "properties": {
-        "marktype": {
-          "enum": [
-            "line"
-          ]
-        },
-        "name": {
-          "type": "string"
-        },
-        "role": {
-          "type": "string"
-        },
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "interactive": {
-          "type": "boolean",
-          "default": true
-        },
-        "items": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/item-line"
-          }
-        },
-        "zindex": {
-          "type": "number"
-        }
-      },
-      "required": [
-        "marktype"
-      ],
-      "additionalProperties": false
-    },
-    "item-line": {
-      "type": "object",
-      "properties": {
-        "x": {
-          "type": "number"
-        },
-        "y": {
-          "type": "number"
-        },
-        "width": {
-          "type": "number"
-        },
-        "height": {
-          "type": "number"
-        },
-        "blend": {
-          "enum": [
-            null,
-            "multiply",
-            "screen",
-            "overlay",
-            "darken",
-            "lighten",
-            "color-dodge",
-            "color-burn",
-            "hard-light",
-            "soft-light",
-            "difference",
-            "exclusion",
-            "hue",
-            "saturation",
-            "color",
-            "luminosity"
-          ],
-          "default": null
-        },
-        "opacity": {
-          "type": "number",
-          "default": 1
-        },
-        "fill": {
-          "$ref": "#/definitions/paint"
-        },
-        "fillOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "stroke": {
-          "$ref": "#/definitions/paint"
-        },
-        "strokeOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeWidth": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeCap": {
-          "enum": [
-            "butt",
-            "cap",
-            "round"
-          ],
-          "default": "butt"
-        },
-        "strokeJoin": {
-          "enum": [
-            "miter",
-            "round",
-            "bevel"
-          ],
-          "default": "miter"
-        },
-        "strokeMiterLimit": {
-          "type": "number"
-        },
-        "strokeDash": {
-          "type": "array",
-          "items": {
-            "type": "number"
-          }
-        },
-        "strokeDashOffset": {
-          "type": "number",
-          "default": 0
-        },
-        "zindex": {
-          "type": "number"
-        },
-        "cursor": {
-          "type": "string"
-        },
-        "href": {
-          "type": "string",
-          "format": "uri-reference"
-        },
-        "tooltip": {},
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "ariaRole": {
-          "type": "string"
-        },
-        "ariaRoleDescription": {
-          "type": "string"
-        },
-        "defined": {
-          "type": "boolean"
-        },
-        "interpolate": {
-          "enum": [
-            "basis",
-            "basis-closed",
-            "basis-open",
-            "bundle",
-            "cardinal",
-            "cardinal-closed",
-            "cardinal-open",
-            "catmull-rom",
-            "catmull-rom-closed",
-            "catmull-rom-open",
-            "linear",
-            "linear-closed",
-            "monotone",
-            "natural",
-            "step",
-            "step-after",
-            "step-before"
-          ]
-        },
-        "tension": {
-          "type": "number"
-        },
-        "orient": {
-          "enum": [
-            "horizontal",
-            "vertical"
-          ]
-        },
-        "size": {
-          "type": "number"
-        }
-      },
-      "additionalProperties": false
-    },
-    "mark-path": {
-      "type": "object",
-      "properties": {
-        "marktype": {
-          "enum": [
-            "path"
-          ]
-        },
-        "name": {
-          "type": "string"
-        },
-        "role": {
-          "type": "string"
-        },
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "interactive": {
-          "type": "boolean",
-          "default": true
-        },
-        "items": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/item-path"
-          }
-        },
-        "zindex": {
-          "type": "number"
-        }
-      },
-      "required": [
-        "marktype"
-      ],
-      "additionalProperties": false
-    },
-    "item-path": {
-      "type": "object",
-      "properties": {
-        "x": {
-          "type": "number"
-        },
-        "y": {
-          "type": "number"
-        },
-        "width": {
-          "type": "number"
-        },
-        "height": {
-          "type": "number"
-        },
-        "blend": {
-          "enum": [
-            null,
-            "multiply",
-            "screen",
-            "overlay",
-            "darken",
-            "lighten",
-            "color-dodge",
-            "color-burn",
-            "hard-light",
-            "soft-light",
-            "difference",
-            "exclusion",
-            "hue",
-            "saturation",
-            "color",
-            "luminosity"
-          ],
-          "default": null
-        },
-        "opacity": {
-          "type": "number",
-          "default": 1
-        },
-        "fill": {
-          "$ref": "#/definitions/paint"
-        },
-        "fillOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "stroke": {
-          "$ref": "#/definitions/paint"
-        },
-        "strokeOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeWidth": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeCap": {
-          "enum": [
-            "butt",
-            "cap",
-            "round"
-          ],
-          "default": "butt"
-        },
-        "strokeJoin": {
-          "enum": [
-            "miter",
-            "round",
-            "bevel"
-          ],
-          "default": "miter"
-        },
-        "strokeMiterLimit": {
-          "type": "number"
-        },
-        "strokeDash": {
-          "type": "array",
-          "items": {
-            "type": "number"
-          }
-        },
-        "strokeDashOffset": {
-          "type": "number",
-          "default": 0
-        },
-        "zindex": {
-          "type": "number"
-        },
-        "cursor": {
-          "type": "string"
-        },
-        "href": {
-          "type": "string",
-          "format": "uri-reference"
-        },
-        "tooltip": {},
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "ariaRole": {
-          "type": "string"
-        },
-        "ariaRoleDescription": {
-          "type": "string"
-        },
-        "angle": {
-          "type": "number"
-        },
-        "path": {
-          "$ref": "#/definitions/path"
-        },
-        "scaleX": {
-          "type": "number"
-        },
-        "scaleY": {
-          "type": "number"
-        }
-      },
-      "additionalProperties": false
-    },
-    "mark-rect": {
-      "type": "object",
-      "properties": {
-        "marktype": {
-          "enum": [
-            "rect"
-          ]
-        },
-        "name": {
-          "type": "string"
-        },
-        "role": {
-          "type": "string"
-        },
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "interactive": {
-          "type": "boolean",
-          "default": true
-        },
-        "items": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/item-rect"
-          }
-        },
-        "zindex": {
-          "type": "number"
-        }
-      },
-      "required": [
-        "marktype"
-      ],
-      "additionalProperties": false
-    },
-    "item-rect": {
-      "type": "object",
-      "properties": {
-        "x": {
-          "type": "number"
-        },
-        "y": {
-          "type": "number"
-        },
-        "width": {
-          "type": "number"
-        },
-        "height": {
-          "type": "number"
-        },
-        "blend": {
-          "enum": [
-            null,
-            "multiply",
-            "screen",
-            "overlay",
-            "darken",
-            "lighten",
-            "color-dodge",
-            "color-burn",
-            "hard-light",
-            "soft-light",
-            "difference",
-            "exclusion",
-            "hue",
-            "saturation",
-            "color",
-            "luminosity"
-          ],
-          "default": null
-        },
-        "opacity": {
-          "type": "number",
-          "default": 1
-        },
-        "fill": {
-          "$ref": "#/definitions/paint"
-        },
-        "fillOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "stroke": {
-          "$ref": "#/definitions/paint"
-        },
-        "strokeOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeWidth": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeCap": {
-          "enum": [
-            "butt",
-            "cap",
-            "round"
-          ],
-          "default": "butt"
-        },
-        "strokeJoin": {
-          "enum": [
-            "miter",
-            "round",
-            "bevel"
-          ],
-          "default": "miter"
-        },
-        "strokeMiterLimit": {
-          "type": "number"
-        },
-        "strokeDash": {
-          "type": "array",
-          "items": {
-            "type": "number"
-          }
-        },
-        "strokeDashOffset": {
-          "type": "number",
-          "default": 0
-        },
-        "zindex": {
-          "type": "number"
-        },
-        "cursor": {
-          "type": "string"
-        },
-        "href": {
-          "type": "string",
-          "format": "uri-reference"
-        },
-        "tooltip": {},
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "ariaRole": {
-          "type": "string"
-        },
-        "ariaRoleDescription": {
-          "type": "string"
-        },
-        "cornerRadius": {
-          "type": "number"
-        },
-        "cornerRadiusTopLeft": {
-          "type": "number"
-        },
-        "cornerRadiusTopRight": {
-          "type": "number"
-        },
-        "cornerRadiusBottomRight": {
-          "type": "number"
-        },
-        "cornerRadiusBottomLeft": {
-          "type": "number"
-        }
-      },
-      "additionalProperties": false
-    },
-    "mark-rule": {
-      "type": "object",
-      "properties": {
-        "marktype": {
-          "enum": [
-            "rule"
-          ]
-        },
-        "name": {
-          "type": "string"
-        },
-        "role": {
-          "type": "string"
-        },
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "interactive": {
-          "type": "boolean",
-          "default": true
-        },
-        "items": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/item-rule"
-          }
-        },
-        "zindex": {
-          "type": "number"
-        }
-      },
-      "required": [
-        "marktype"
-      ],
-      "additionalProperties": false
-    },
-    "item-rule": {
-      "type": "object",
-      "properties": {
-        "x": {
-          "type": "number"
-        },
-        "y": {
-          "type": "number"
-        },
-        "width": {
-          "type": "number"
-        },
-        "height": {
-          "type": "number"
-        },
-        "blend": {
-          "enum": [
-            null,
-            "multiply",
-            "screen",
-            "overlay",
-            "darken",
-            "lighten",
-            "color-dodge",
-            "color-burn",
-            "hard-light",
-            "soft-light",
-            "difference",
-            "exclusion",
-            "hue",
-            "saturation",
-            "color",
-            "luminosity"
-          ],
-          "default": null
-        },
-        "opacity": {
-          "type": "number",
-          "default": 1
-        },
-        "fill": {
-          "$ref": "#/definitions/paint"
-        },
-        "fillOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "stroke": {
-          "$ref": "#/definitions/paint"
-        },
-        "strokeOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeWidth": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeCap": {
-          "enum": [
-            "butt",
-            "cap",
-            "round"
-          ],
-          "default": "butt"
-        },
-        "strokeJoin": {
-          "enum": [
-            "miter",
-            "round",
-            "bevel"
-          ],
-          "default": "miter"
-        },
-        "strokeMiterLimit": {
-          "type": "number"
-        },
-        "strokeDash": {
-          "type": "array",
-          "items": {
-            "type": "number"
-          }
-        },
-        "strokeDashOffset": {
-          "type": "number",
-          "default": 0
-        },
-        "zindex": {
-          "type": "number"
-        },
-        "cursor": {
-          "type": "string"
-        },
-        "href": {
-          "type": "string",
-          "format": "uri-reference"
-        },
-        "tooltip": {},
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "ariaRole": {
-          "type": "string"
-        },
-        "ariaRoleDescription": {
-          "type": "string"
-        },
-        "x2": {
-          "type": "number"
-        },
-        "y2": {
-          "type": "number"
-        }
-      },
-      "additionalProperties": false
-    },
-    "mark-symbol": {
-      "type": "object",
-      "properties": {
-        "marktype": {
-          "enum": [
-            "symbol"
-          ]
-        },
-        "name": {
-          "type": "string"
-        },
-        "role": {
-          "type": "string"
-        },
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "interactive": {
-          "type": "boolean",
-          "default": true
-        },
-        "items": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/item-symbol"
-          }
-        },
-        "zindex": {
-          "type": "number"
-        }
-      },
-      "required": [
-        "marktype"
-      ],
-      "additionalProperties": false
-    },
-    "item-symbol": {
-      "type": "object",
-      "properties": {
-        "x": {
-          "type": "number"
-        },
-        "y": {
-          "type": "number"
-        },
-        "width": {
-          "type": "number"
-        },
-        "height": {
-          "type": "number"
-        },
-        "blend": {
-          "enum": [
-            null,
-            "multiply",
-            "screen",
-            "overlay",
-            "darken",
-            "lighten",
-            "color-dodge",
-            "color-burn",
-            "hard-light",
-            "soft-light",
-            "difference",
-            "exclusion",
-            "hue",
-            "saturation",
-            "color",
-            "luminosity"
-          ],
-          "default": null
-        },
-        "opacity": {
-          "type": "number",
-          "default": 1
-        },
-        "fill": {
-          "$ref": "#/definitions/paint"
-        },
-        "fillOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "stroke": {
-          "$ref": "#/definitions/paint"
-        },
-        "strokeOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeWidth": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeCap": {
-          "enum": [
-            "butt",
-            "cap",
-            "round"
-          ],
-          "default": "butt"
-        },
-        "strokeJoin": {
-          "enum": [
-            "miter",
-            "round",
-            "bevel"
-          ],
-          "default": "miter"
-        },
-        "strokeMiterLimit": {
-          "type": "number"
-        },
-        "strokeDash": {
-          "type": "array",
-          "items": {
-            "type": "number"
-          }
-        },
-        "strokeDashOffset": {
-          "type": "number",
-          "default": 0
-        },
-        "zindex": {
-          "type": "number"
-        },
-        "cursor": {
-          "type": "string"
-        },
-        "href": {
-          "type": "string",
-          "format": "uri-reference"
-        },
-        "tooltip": {},
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "ariaRole": {
-          "type": "string"
-        },
-        "ariaRoleDescription": {
-          "type": "string"
-        },
-        "angle": {
-          "type": "number",
-          "default": 0
-        },
-        "size": {
-          "type": "number",
-          "default": 100
-        },
-        "shape": {
-          "type": "string"
-        }
-      },
-      "additionalProperties": false
-    },
-    "mark-text": {
-      "type": "object",
-      "properties": {
-        "marktype": {
-          "enum": [
-            "text"
-          ]
-        },
-        "name": {
-          "type": "string"
-        },
-        "role": {
-          "type": "string"
-        },
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "interactive": {
-          "type": "boolean",
-          "default": true
-        },
-        "items": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/item-text"
-          }
-        },
-        "zindex": {
-          "type": "number"
-        }
-      },
-      "required": [
-        "marktype"
-      ],
-      "additionalProperties": false
-    },
-    "item-text": {
-      "type": "object",
-      "properties": {
-        "x": {
-          "type": "number"
-        },
-        "y": {
-          "type": "number"
-        },
-        "width": {
-          "type": "number"
-        },
-        "height": {
-          "type": "number"
-        },
-        "blend": {
-          "enum": [
-            null,
-            "multiply",
-            "screen",
-            "overlay",
-            "darken",
-            "lighten",
-            "color-dodge",
-            "color-burn",
-            "hard-light",
-            "soft-light",
-            "difference",
-            "exclusion",
-            "hue",
-            "saturation",
-            "color",
-            "luminosity"
-          ],
-          "default": null
-        },
-        "opacity": {
-          "type": "number",
-          "default": 1
-        },
-        "fill": {
-          "$ref": "#/definitions/paint"
-        },
-        "fillOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "stroke": {
-          "$ref": "#/definitions/paint"
-        },
-        "strokeOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeWidth": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeCap": {
-          "enum": [
-            "butt",
-            "cap",
-            "round"
-          ],
-          "default": "butt"
-        },
-        "strokeJoin": {
-          "enum": [
-            "miter",
-            "round",
-            "bevel"
-          ],
-          "default": "miter"
-        },
-        "strokeMiterLimit": {
-          "type": "number"
-        },
-        "strokeDash": {
-          "type": "array",
-          "items": {
-            "type": "number"
-          }
-        },
-        "strokeDashOffset": {
-          "type": "number",
-          "default": 0
-        },
-        "zindex": {
-          "type": "number"
-        },
-        "cursor": {
-          "type": "string"
-        },
-        "href": {
-          "type": "string",
-          "format": "uri-reference"
-        },
-        "tooltip": {},
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "ariaRole": {
-          "type": "string"
-        },
-        "ariaRoleDescription": {
-          "type": "string"
-        },
-        "text": {
-          "oneOf": [
-            {
-              "type": "string"
-            },
-            {
-              "type": "array",
-              "items": {
-                "type": "string"
-              }
-            }
-          ]
-        },
-        "limit": {
-          "type": "number",
-          "default": 0
-        },
-        "lineHeight": {
-          "type": "number"
-        },
-        "dir": {
-          "type": "string",
-          "default": "ltr"
-        },
-        "ellipsis": {
-          "type": "string",
-          "default": "…"
-        },
-        "align": {
-          "enum": [
-            "left",
-            "center",
-            "right"
-          ],
-          "default": "left"
-        },
-        "baseline": {
-          "enum": [
-            "alphabetic",
-            "top",
-            "middle",
-            "bottom",
-            "line-top",
-            "line-bottom"
-          ],
-          "default": "alphabetic"
-        },
-        "angle": {
-          "type": "number",
-          "default": 0
-        },
-        "theta": {
-          "type": "number",
-          "default": 0
-        },
-        "radius": {
-          "type": "number",
-          "default": 0
-        },
-        "dx": {
-          "type": "number",
-          "default": 0
-        },
-        "dy": {
-          "type": "number",
-          "default": 0
-        },
-        "font": {
-          "type": "string",
-          "default": "sans-serif"
-        },
-        "fontSize": {
-          "type": "number"
-        },
-        "fontStyle": {
-          "enum": [
-            "normal",
-            "italic",
-            "oblique"
-          ],
-          "default": "normal"
-        },
-        "fontWeight": {
-          "enum": [
-            "normal",
-            "bold",
-            "bolder",
-            "lighter",
-            100,
-            200,
-            300,
-            400,
-            500,
-            600,
-            700,
-            800,
-            900
-          ],
-          "default": "normal"
-        },
-        "fontVariant": {
-          "enum": [
-            "normal",
-            "small-caps"
-          ],
-          "default": "normal"
-        }
-      },
-      "additionalProperties": false
-    },
-    "mark-trail": {
-      "type": "object",
-      "properties": {
-        "marktype": {
-          "enum": [
-            "trail"
-          ]
-        },
-        "name": {
-          "type": "string"
-        },
-        "role": {
-          "type": "string"
-        },
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "interactive": {
-          "type": "boolean",
-          "default": true
-        },
-        "items": {
-          "type": "array",
-          "items": {
-            "$ref": "#/definitions/item-trail"
-          }
-        },
-        "zindex": {
-          "type": "number"
-        }
-      },
-      "required": [
-        "marktype"
-      ],
-      "additionalProperties": false
-    },
-    "item-trail": {
-      "type": "object",
-      "properties": {
-        "x": {
-          "type": "number"
-        },
-        "y": {
-          "type": "number"
-        },
-        "width": {
-          "type": "number"
-        },
-        "height": {
-          "type": "number"
-        },
-        "blend": {
-          "enum": [
-            null,
-            "multiply",
-            "screen",
-            "overlay",
-            "darken",
-            "lighten",
-            "color-dodge",
-            "color-burn",
-            "hard-light",
-            "soft-light",
-            "difference",
-            "exclusion",
-            "hue",
-            "saturation",
-            "color",
-            "luminosity"
-          ],
-          "default": null
-        },
-        "opacity": {
-          "type": "number",
-          "default": 1
-        },
-        "fill": {
-          "$ref": "#/definitions/paint"
-        },
-        "fillOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "stroke": {
-          "$ref": "#/definitions/paint"
-        },
-        "strokeOpacity": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeWidth": {
-          "type": "number",
-          "default": 1
-        },
-        "strokeCap": {
-          "enum": [
-            "butt",
-            "cap",
-            "round"
-          ],
-          "default": "butt"
-        },
-        "strokeJoin": {
-          "enum": [
-            "miter",
-            "round",
-            "bevel"
-          ],
-          "default": "miter"
-        },
-        "strokeMiterLimit": {
-          "type": "number"
-        },
-        "strokeDash": {
-          "type": "array",
-          "items": {
-            "type": "number"
-          }
-        },
-        "strokeDashOffset": {
-          "type": "number",
-          "default": 0
-        },
-        "zindex": {
-          "type": "number"
-        },
-        "cursor": {
-          "type": "string"
-        },
-        "href": {
-          "type": "string",
-          "format": "uri-reference"
-        },
-        "tooltip": {},
-        "description": {
-          "type": "string"
-        },
-        "aria": {
-          "type": "boolean"
-        },
-        "ariaRole": {
-          "type": "string"
-        },
-        "ariaRoleDescription": {
-          "type": "string"
-        },
-        "defined": {
-          "type": "boolean"
-        },
-        "size": {
-          "type": "number",
-          "default": 1
-        }
-      },
-      "additionalProperties": false
-    }
-  }
-}
\ No newline at end of file
diff --git a/node_modules/vega-scenegraph/build/vega-scenegraph.js b/node_modules/vega-scenegraph/build/vega-scenegraph.js
deleted file mode 100644
index 4603cfd..0000000
--- a/node_modules/vega-scenegraph/build/vega-scenegraph.js
+++ /dev/null
@@ -1,5232 +0,0 @@
-(function (global, factory) {
-  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('d3-shape'), require('d3-path'), require('vega-canvas'), require('vega-loader'), require('vega-scale')) :
-  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'd3-shape', 'd3-path', 'vega-canvas', 'vega-loader', 'vega-scale'], factory) :
-  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.d3, global.d3, global.vega, global.vega, global.vega));
-}(this, (function (exports, vegaUtil, d3Shape, d3Path, vegaCanvas, vegaLoader, vegaScale) { 'use strict';
-
-  let gradient_id = 0;
-  function resetSVGGradientId() {
-    gradient_id = 0;
-  }
-  const patternPrefix = 'p_';
-  function isGradient(value) {
-    return value && value.gradient;
-  }
-  function gradientRef(g, defs, base) {
-    const type = g.gradient;
-    let id = g.id,
-        prefix = type === 'radial' ? patternPrefix : ''; // check id, assign default values as needed
-
-    if (!id) {
-      id = g.id = 'gradient_' + gradient_id++;
-
-      if (type === 'radial') {
-        g.x1 = get(g.x1, 0.5);
-        g.y1 = get(g.y1, 0.5);
-        g.r1 = get(g.r1, 0);
-        g.x2 = get(g.x2, 0.5);
-        g.y2 = get(g.y2, 0.5);
-        g.r2 = get(g.r2, 0.5);
-        prefix = patternPrefix;
-      } else {
-        g.x1 = get(g.x1, 0);
-        g.y1 = get(g.y1, 0);
-        g.x2 = get(g.x2, 1);
-        g.y2 = get(g.y2, 0);
-      }
-    } // register definition
-
-
-    defs[id] = g; // return url reference
-
-    return 'url(' + (base || '') + '#' + prefix + id + ')';
-  }
-
-  function get(val, def) {
-    return val != null ? val : def;
-  }
-
-  function Gradient (p0, p1) {
-    var stops = [],
-        gradient;
-    return gradient = {
-      gradient: 'linear',
-      x1: p0 ? p0[0] : 0,
-      y1: p0 ? p0[1] : 0,
-      x2: p1 ? p1[0] : 1,
-      y2: p1 ? p1[1] : 0,
-      stops: stops,
-      stop: function (offset, color) {
-        stops.push({
-          offset: offset,
-          color: color
-        });
-        return gradient;
-      }
-    };
-  }
-
-  const lookup = {
-    'basis': {
-      curve: d3Shape.curveBasis
-    },
-    'basis-closed': {
-      curve: d3Shape.curveBasisClosed
-    },
-    'basis-open': {
-      curve: d3Shape.curveBasisOpen
-    },
-    'bundle': {
-      curve: d3Shape.curveBundle,
-      tension: 'beta',
-      value: 0.85
-    },
-    'cardinal': {
-      curve: d3Shape.curveCardinal,
-      tension: 'tension',
-      value: 0
-    },
-    'cardinal-open': {
-      curve: d3Shape.curveCardinalOpen,
-      tension: 'tension',
-      value: 0
-    },
-    'cardinal-closed': {
-      curve: d3Shape.curveCardinalClosed,
-      tension: 'tension',
-      value: 0
-    },
-    'catmull-rom': {
-      curve: d3Shape.curveCatmullRom,
-      tension: 'alpha',
-      value: 0.5
-    },
-    'catmull-rom-closed': {
-      curve: d3Shape.curveCatmullRomClosed,
-      tension: 'alpha',
-      value: 0.5
-    },
-    'catmull-rom-open': {
-      curve: d3Shape.curveCatmullRomOpen,
-      tension: 'alpha',
-      value: 0.5
-    },
-    'linear': {
-      curve: d3Shape.curveLinear
-    },
-    'linear-closed': {
-      curve: d3Shape.curveLinearClosed
-    },
-    'monotone': {
-      horizontal: d3Shape.curveMonotoneY,
-      vertical: d3Shape.curveMonotoneX
-    },
-    'natural': {
-      curve: d3Shape.curveNatural
-    },
-    'step': {
-      curve: d3Shape.curveStep
-    },
-    'step-after': {
-      curve: d3Shape.curveStepAfter
-    },
-    'step-before': {
-      curve: d3Shape.curveStepBefore
-    }
-  };
-  function curves(type, orientation, tension) {
-    var entry = vegaUtil.hasOwnProperty(lookup, type) && lookup[type],
-        curve = null;
-
-    if (entry) {
-      curve = entry.curve || entry[orientation || 'vertical'];
-
-      if (entry.tension && tension != null) {
-        curve = curve[entry.tension](tension);
-      }
-    }
-
-    return curve;
-  }
-
-  // Path parsing and rendering code adapted from fabric.js -- Thanks!
-  const cmdlen = {
-    m: 2,
-    l: 2,
-    h: 1,
-    v: 1,
-    c: 6,
-    s: 4,
-    q: 4,
-    t: 2,
-    a: 7
-  },
-        regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\.\d+)(\.\d)/g, /(\d)([-+])/g, /\s|,|###/];
-  function pathParse (pathstr) {
-    const result = [];
-    let curr, chunks, parsed, param, cmd, len, i, j, n, m; // First, break path into command sequence
-
-    const path = pathstr.slice().replace(regexp[0], '###$1').split(regexp[1]).slice(1); // Next, parse each command in turn
-
-    for (i = 0, n = path.length; i < n; ++i) {
-      curr = path[i];
-      chunks = curr.slice(1).trim().replace(regexp[2], '$1###$2').replace(regexp[3], '$1###$2').split(regexp[4]);
-      cmd = curr.charAt(0);
-      parsed = [cmd];
-
-      for (j = 0, m = chunks.length; j < m; ++j) {
-        if ((param = +chunks[j]) === param) {
-          // not NaN
-          parsed.push(param);
-        }
-      }
-
-      len = cmdlen[cmd.toLowerCase()];
-
-      if (parsed.length - 1 > len) {
-        const m = parsed.length;
-        j = 1;
-        result.push([cmd].concat(parsed.slice(j, j += len))); // handle implicit lineTo (#2803)
-
-        cmd = cmd === 'M' ? 'L' : cmd === 'm' ? 'l' : cmd;
-
-        for (; j < m; j += len) {
-          result.push([cmd].concat(parsed.slice(j, j + len)));
-        }
-      } else {
-        result.push(parsed);
-      }
-    }
-
-    return result;
-  }
-
-  const DegToRad = Math.PI / 180;
-  const Epsilon = 1e-14;
-  const HalfPi = Math.PI / 2;
-  const Tau = Math.PI * 2;
-  const HalfSqrt3 = Math.sqrt(3) / 2;
-
-  var segmentCache = {};
-  var bezierCache = {};
-  var join = [].join; // Copied from Inkscape svgtopdf, thanks!
-
-  function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
-    const key = join.call(arguments);
-
-    if (segmentCache[key]) {
-      return segmentCache[key];
-    }
-
-    const th = rotateX * DegToRad;
-    const sin_th = Math.sin(th);
-    const cos_th = Math.cos(th);
-    rx = Math.abs(rx);
-    ry = Math.abs(ry);
-    const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
-    const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
-    let pl = px * px / (rx * rx) + py * py / (ry * ry);
-
-    if (pl > 1) {
-      pl = Math.sqrt(pl);
-      rx *= pl;
-      ry *= pl;
-    }
-
-    const a00 = cos_th / rx;
-    const a01 = sin_th / rx;
-    const a10 = -sin_th / ry;
-    const a11 = cos_th / ry;
-    const x0 = a00 * ox + a01 * oy;
-    const y0 = a10 * ox + a11 * oy;
-    const x1 = a00 * x + a01 * y;
-    const y1 = a10 * x + a11 * y;
-    const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
-    let sfactor_sq = 1 / d - 0.25;
-    if (sfactor_sq < 0) sfactor_sq = 0;
-    let sfactor = Math.sqrt(sfactor_sq);
-    if (sweep == large) sfactor = -sfactor;
-    const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
-    const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
-    const th0 = Math.atan2(y0 - yc, x0 - xc);
-    const th1 = Math.atan2(y1 - yc, x1 - xc);
-    let th_arc = th1 - th0;
-
-    if (th_arc < 0 && sweep === 1) {
-      th_arc += Tau;
-    } else if (th_arc > 0 && sweep === 0) {
-      th_arc -= Tau;
-    }
-
-    const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));
-    const result = [];
-
-    for (let i = 0; i < segs; ++i) {
-      const th2 = th0 + i * th_arc / segs;
-      const th3 = th0 + (i + 1) * th_arc / segs;
-      result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
-    }
-
-    return segmentCache[key] = result;
-  }
-  function bezier(params) {
-    const key = join.call(params);
-
-    if (bezierCache[key]) {
-      return bezierCache[key];
-    }
-
-    var cx = params[0],
-        cy = params[1],
-        th0 = params[2],
-        th1 = params[3],
-        rx = params[4],
-        ry = params[5],
-        sin_th = params[6],
-        cos_th = params[7];
-    const a00 = cos_th * rx;
-    const a01 = -sin_th * ry;
-    const a10 = sin_th * rx;
-    const a11 = cos_th * ry;
-    const cos_th0 = Math.cos(th0);
-    const sin_th0 = Math.sin(th0);
-    const cos_th1 = Math.cos(th1);
-    const sin_th1 = Math.sin(th1);
-    const th_half = 0.5 * (th1 - th0);
-    const sin_th_h2 = Math.sin(th_half * 0.5);
-    const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
-    const x1 = cx + cos_th0 - t * sin_th0;
-    const y1 = cy + sin_th0 + t * cos_th0;
-    const x3 = cx + cos_th1;
-    const y3 = cy + sin_th1;
-    const x2 = x3 + t * sin_th1;
-    const y2 = y3 - t * cos_th1;
-    return bezierCache[key] = [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
-  }
-
-  const temp = ['l', 0, 0, 0, 0, 0, 0, 0];
-
-  function scale$1(current, sX, sY) {
-    const c = temp[0] = current[0];
-
-    if (c === 'a' || c === 'A') {
-      temp[1] = sX * current[1];
-      temp[2] = sY * current[2];
-      temp[3] = current[3];
-      temp[4] = current[4];
-      temp[5] = current[5];
-      temp[6] = sX * current[6];
-      temp[7] = sY * current[7];
-    } else if (c === 'h' || c === 'H') {
-      temp[1] = sX * current[1];
-    } else if (c === 'v' || c === 'V') {
-      temp[1] = sY * current[1];
-    } else {
-      for (var i = 1, n = current.length; i < n; ++i) {
-        temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
-      }
-    }
-
-    return temp;
-  }
-
-  function pathRender (context, path, l, t, sX, sY) {
-    var current,
-        // current instruction
-    previous = null,
-        x = 0,
-        // current x
-    y = 0,
-        // current y
-    controlX = 0,
-        // current control point x
-    controlY = 0,
-        // current control point y
-    tempX,
-        tempY,
-        tempControlX,
-        tempControlY;
-    if (l == null) l = 0;
-    if (t == null) t = 0;
-    if (sX == null) sX = 1;
-    if (sY == null) sY = sX;
-    if (context.beginPath) context.beginPath();
-
-    for (var i = 0, len = path.length; i < len; ++i) {
-      current = path[i];
-
-      if (sX !== 1 || sY !== 1) {
-        current = scale$1(current, sX, sY);
-      }
-
-      switch (current[0]) {
-        // first letter
-        case 'l':
-          // lineto, relative
-          x += current[1];
-          y += current[2];
-          context.lineTo(x + l, y + t);
-          break;
-
-        case 'L':
-          // lineto, absolute
-          x = current[1];
-          y = current[2];
-          context.lineTo(x + l, y + t);
-          break;
-
-        case 'h':
-          // horizontal lineto, relative
-          x += current[1];
-          context.lineTo(x + l, y + t);
-          break;
-
-        case 'H':
-          // horizontal lineto, absolute
-          x = current[1];
-          context.lineTo(x + l, y + t);
-          break;
-
-        case 'v':
-          // vertical lineto, relative
-          y += current[1];
-          context.lineTo(x + l, y + t);
-          break;
-
-        case 'V':
-          // verical lineto, absolute
-          y = current[1];
-          context.lineTo(x + l, y + t);
-          break;
-
-        case 'm':
-          // moveTo, relative
-          x += current[1];
-          y += current[2];
-          context.moveTo(x + l, y + t);
-          break;
-
-        case 'M':
-          // moveTo, absolute
-          x = current[1];
-          y = current[2];
-          context.moveTo(x + l, y + t);
-          break;
-
-        case 'c':
-          // bezierCurveTo, relative
-          tempX = x + current[5];
-          tempY = y + current[6];
-          controlX = x + current[3];
-          controlY = y + current[4];
-          context.bezierCurveTo(x + current[1] + l, // x1
-          y + current[2] + t, // y1
-          controlX + l, // x2
-          controlY + t, // y2
-          tempX + l, tempY + t);
-          x = tempX;
-          y = tempY;
-          break;
-
-        case 'C':
-          // bezierCurveTo, absolute
-          x = current[5];
-          y = current[6];
-          controlX = current[3];
-          controlY = current[4];
-          context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
-          break;
-
-        case 's':
-          // shorthand cubic bezierCurveTo, relative
-          // transform to absolute x,y
-          tempX = x + current[3];
-          tempY = y + current[4]; // calculate reflection of previous control points
-
-          controlX = 2 * x - controlX;
-          controlY = 2 * y - controlY;
-          context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t); // set control point to 2nd one of this command
-          // the first control point is assumed to be the reflection of
-          // the second control point on the previous command relative
-          // to the current point.
-
-          controlX = x + current[1];
-          controlY = y + current[2];
-          x = tempX;
-          y = tempY;
-          break;
-
-        case 'S':
-          // shorthand cubic bezierCurveTo, absolute
-          tempX = current[3];
-          tempY = current[4]; // calculate reflection of previous control points
-
-          controlX = 2 * x - controlX;
-          controlY = 2 * y - controlY;
-          context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);
-          x = tempX;
-          y = tempY; // set control point to 2nd one of this command
-          // the first control point is assumed to be the reflection of
-          // the second control point on the previous command relative
-          // to the current point.
-
-          controlX = current[1];
-          controlY = current[2];
-          break;
-
-        case 'q':
-          // quadraticCurveTo, relative
-          // transform to absolute x,y
-          tempX = x + current[3];
-          tempY = y + current[4];
-          controlX = x + current[1];
-          controlY = y + current[2];
-          context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
-          x = tempX;
-          y = tempY;
-          break;
-
-        case 'Q':
-          // quadraticCurveTo, absolute
-          tempX = current[3];
-          tempY = current[4];
-          context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);
-          x = tempX;
-          y = tempY;
-          controlX = current[1];
-          controlY = current[2];
-          break;
-
-        case 't':
-          // shorthand quadraticCurveTo, relative
-          // transform to absolute x,y
-          tempX = x + current[1];
-          tempY = y + current[2];
-
-          if (previous[0].match(/[QqTt]/) === null) {
-            // If there is no previous command or if the previous command was not a Q, q, T or t,
-            // assume the control point is coincident with the current point
-            controlX = x;
-            controlY = y;
-          } else if (previous[0] === 't') {
-            // calculate reflection of previous control points for t
-            controlX = 2 * x - tempControlX;
-            controlY = 2 * y - tempControlY;
-          } else if (previous[0] === 'q') {
-            // calculate reflection of previous control points for q
-            controlX = 2 * x - controlX;
-            controlY = 2 * y - controlY;
-          }
-
-          tempControlX = controlX;
-          tempControlY = controlY;
-          context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
-          x = tempX;
-          y = tempY;
-          controlX = x + current[1];
-          controlY = y + current[2];
-          break;
-
-        case 'T':
-          tempX = current[1];
-          tempY = current[2]; // calculate reflection of previous control points
-
-          controlX = 2 * x - controlX;
-          controlY = 2 * y - controlY;
-          context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
-          x = tempX;
-          y = tempY;
-          break;
-
-        case 'a':
-          drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);
-          x += current[6];
-          y += current[7];
-          break;
-
-        case 'A':
-          drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);
-          x = current[6];
-          y = current[7];
-          break;
-
-        case 'z':
-        case 'Z':
-          context.closePath();
-          break;
-      }
-
-      previous = current;
-    }
-  }
-
-  function drawArc(context, x, y, coords) {
-    const seg = segments(coords[5], // end x
-    coords[6], // end y
-    coords[0], // radius x
-    coords[1], // radius y
-    coords[3], // large flag
-    coords[4], // sweep flag
-    coords[2], // rotation
-    x, y);
-
-    for (let i = 0; i < seg.length; ++i) {
-      const bez = bezier(seg[i]);
-      context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
-    }
-  }
-
-  const Tan30 = 0.5773502691896257;
-  const builtins = {
-    'circle': {
-      draw: function (context, size) {
-        const r = Math.sqrt(size) / 2;
-        context.moveTo(r, 0);
-        context.arc(0, 0, r, 0, Tau);
-      }
-    },
-    'cross': {
-      draw: function (context, size) {
-        var r = Math.sqrt(size) / 2,
-            s = r / 2.5;
-        context.moveTo(-r, -s);
-        context.lineTo(-r, s);
-        context.lineTo(-s, s);
-        context.lineTo(-s, r);
-        context.lineTo(s, r);
-        context.lineTo(s, s);
-        context.lineTo(r, s);
-        context.lineTo(r, -s);
-        context.lineTo(s, -s);
-        context.lineTo(s, -r);
-        context.lineTo(-s, -r);
-        context.lineTo(-s, -s);
-        context.closePath();
-      }
-    },
-    'diamond': {
-      draw: function (context, size) {
-        const r = Math.sqrt(size) / 2;
-        context.moveTo(-r, 0);
-        context.lineTo(0, -r);
-        context.lineTo(r, 0);
-        context.lineTo(0, r);
-        context.closePath();
-      }
-    },
-    'square': {
-      draw: function (context, size) {
-        var w = Math.sqrt(size),
-            x = -w / 2;
-        context.rect(x, x, w, w);
-      }
-    },
-    'arrow': {
-      draw: function (context, size) {
-        var r = Math.sqrt(size) / 2,
-            s = r / 7,
-            t = r / 2.5,
-            v = r / 8;
-        context.moveTo(-s, r);
-        context.lineTo(s, r);
-        context.lineTo(s, -v);
-        context.lineTo(t, -v);
-        context.lineTo(0, -r);
-        context.lineTo(-t, -v);
-        context.lineTo(-s, -v);
-        context.closePath();
-      }
-    },
-    'wedge': {
-      draw: function (context, size) {
-        var r = Math.sqrt(size) / 2,
-            h = HalfSqrt3 * r,
-            o = h - r * Tan30,
-            b = r / 4;
-        context.moveTo(0, -h - o);
-        context.lineTo(-b, h - o);
-        context.lineTo(b, h - o);
-        context.closePath();
-      }
-    },
-    'triangle': {
-      draw: function (context, size) {
-        var r = Math.sqrt(size) / 2,
-            h = HalfSqrt3 * r,
-            o = h - r * Tan30;
-        context.moveTo(0, -h - o);
-        context.lineTo(-r, h - o);
-        context.lineTo(r, h - o);
-        context.closePath();
-      }
-    },
-    'triangle-up': {
-      draw: function (context, size) {
-        var r = Math.sqrt(size) / 2,
-            h = HalfSqrt3 * r;
-        context.moveTo(0, -h);
-        context.lineTo(-r, h);
-        context.lineTo(r, h);
-        context.closePath();
-      }
-    },
-    'triangle-down': {
-      draw: function (context, size) {
-        var r = Math.sqrt(size) / 2,
-            h = HalfSqrt3 * r;
-        context.moveTo(0, h);
-        context.lineTo(-r, -h);
-        context.lineTo(r, -h);
-        context.closePath();
-      }
-    },
-    'triangle-right': {
-      draw: function (context, size) {
-        var r = Math.sqrt(size) / 2,
-            h = HalfSqrt3 * r;
-        context.moveTo(h, 0);
-        context.lineTo(-h, -r);
-        context.lineTo(-h, r);
-        context.closePath();
-      }
-    },
-    'triangle-left': {
-      draw: function (context, size) {
-        var r = Math.sqrt(size) / 2,
-            h = HalfSqrt3 * r;
-        context.moveTo(-h, 0);
-        context.lineTo(h, -r);
-        context.lineTo(h, r);
-        context.closePath();
-      }
-    },
-    'stroke': {
-      draw: function (context, size) {
-        const r = Math.sqrt(size) / 2;
-        context.moveTo(-r, 0);
-        context.lineTo(r, 0);
-      }
-    }
-  };
-  function symbols(_) {
-    return vegaUtil.hasOwnProperty(builtins, _) ? builtins[_] : customSymbol(_);
-  }
-  var custom = {};
-
-  function customSymbol(path) {
-    if (!vegaUtil.hasOwnProperty(custom, path)) {
-      const parsed = pathParse(path);
-      custom[path] = {
-        draw: function (context, size) {
-          pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);
-        }
-      };
-    }
-
-    return custom[path];
-  }
-
-  const C = 0.448084975506; // C = 1 - c
-
-  function rectangleX(d) {
-    return d.x;
-  }
-
-  function rectangleY(d) {
-    return d.y;
-  }
-
-  function rectangleWidth(d) {
-    return d.width;
-  }
-
-  function rectangleHeight(d) {
-    return d.height;
-  }
-
-  function number(_) {
-    return typeof _ === 'function' ? _ : () => +_;
-  }
-
-  function clamp(value, min, max) {
-    return Math.max(min, Math.min(value, max));
-  }
-
-  function vg_rect () {
-    var x = rectangleX,
-        y = rectangleY,
-        width = rectangleWidth,
-        height = rectangleHeight,
-        crTL = number(0),
-        crTR = crTL,
-        crBL = crTL,
-        crBR = crTL,
-        context = null;
-
-    function rectangle(_, x0, y0) {
-      var buffer,
-          x1 = x0 != null ? x0 : +x.call(this, _),
-          y1 = y0 != null ? y0 : +y.call(this, _),
-          w = +width.call(this, _),
-          h = +height.call(this, _),
-          s = Math.min(w, h) / 2,
-          tl = clamp(+crTL.call(this, _), 0, s),
-          tr = clamp(+crTR.call(this, _), 0, s),
-          bl = clamp(+crBL.call(this, _), 0, s),
-          br = clamp(+crBR.call(this, _), 0, s);
-      if (!context) context = buffer = d3Path.path();
-
-      if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {
-        context.rect(x1, y1, w, h);
-      } else {
-        var x2 = x1 + w,
-            y2 = y1 + h;
-        context.moveTo(x1 + tl, y1);
-        context.lineTo(x2 - tr, y1);
-        context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);
-        context.lineTo(x2, y2 - br);
-        context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);
-        context.lineTo(x1 + bl, y2);
-        context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);
-        context.lineTo(x1, y1 + tl);
-        context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);
-        context.closePath();
-      }
-
-      if (buffer) {
-        context = null;
-        return buffer + '' || null;
-      }
-    }
-
-    rectangle.x = function (_) {
-      if (arguments.length) {
-        x = number(_);
-        return rectangle;
-      } else {
-        return x;
-      }
-    };
-
-    rectangle.y = function (_) {
-      if (arguments.length) {
-        y = number(_);
-        return rectangle;
-      } else {
-        return y;
-      }
-    };
-
-    rectangle.width = function (_) {
-      if (arguments.length) {
-        width = number(_);
-        return rectangle;
-      } else {
-        return width;
-      }
-    };
-
-    rectangle.height = function (_) {
-      if (arguments.length) {
-        height = number(_);
-        return rectangle;
-      } else {
-        return height;
-      }
-    };
-
-    rectangle.cornerRadius = function (tl, tr, br, bl) {
-      if (arguments.length) {
-        crTL = number(tl);
-        crTR = tr != null ? number(tr) : crTL;
-        crBR = br != null ? number(br) : crTL;
-        crBL = bl != null ? number(bl) : crTR;
-        return rectangle;
-      } else {
-        return crTL;
-      }
-    };
-
-    rectangle.context = function (_) {
-      if (arguments.length) {
-        context = _ == null ? null : _;
-        return rectangle;
-      } else {
-        return context;
-      }
-    };
-
-    return rectangle;
-  }
-
-  function vg_trail () {
-    var x,
-        y,
-        size,
-        defined,
-        context = null,
-        ready,
-        x1,
-        y1,
-        r1;
-
-    function point(x2, y2, w2) {
-      const r2 = w2 / 2;
-
-      if (ready) {
-        var ux = y1 - y2,
-            uy = x2 - x1;
-
-        if (ux || uy) {
-          // get normal vector
-          var ud = Math.sqrt(ux * ux + uy * uy),
-              rx = (ux /= ud) * r1,
-              ry = (uy /= ud) * r1,
-              t = Math.atan2(uy, ux); // draw segment
-
-          context.moveTo(x1 - rx, y1 - ry);
-          context.lineTo(x2 - ux * r2, y2 - uy * r2);
-          context.arc(x2, y2, r2, t - Math.PI, t);
-          context.lineTo(x1 + rx, y1 + ry);
-          context.arc(x1, y1, r1, t, t + Math.PI);
-        } else {
-          context.arc(x2, y2, r2, 0, Tau);
-        }
-
-        context.closePath();
-      } else {
-        ready = 1;
-      }
-
-      x1 = x2;
-      y1 = y2;
-      r1 = r2;
-    }
-
-    function trail(data) {
-      var i,
-          n = data.length,
-          d,
-          defined0 = false,
-          buffer;
-      if (context == null) context = buffer = d3Path.path();
-
-      for (i = 0; i <= n; ++i) {
-        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
-          if (defined0 = !defined0) ready = 0;
-        }
-
-        if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));
-      }
-
-      if (buffer) {
-        context = null;
-        return buffer + '' || null;
-      }
-    }
-
-    trail.x = function (_) {
-      if (arguments.length) {
-        x = _;
-        return trail;
-      } else {
-        return x;
-      }
-    };
-
-    trail.y = function (_) {
-      if (arguments.length) {
-        y = _;
-        return trail;
-      } else {
-        return y;
-      }
-    };
-
-    trail.size = function (_) {
-      if (arguments.length) {
-        size = _;
-        return trail;
-      } else {
-        return size;
-      }
-    };
-
-    trail.defined = function (_) {
-      if (arguments.length) {
-        defined = _;
-        return trail;
-      } else {
-        return defined;
-      }
-    };
-
-    trail.context = function (_) {
-      if (arguments.length) {
-        if (_ == null) {
-          context = null;
-        } else {
-          context = _;
-        }
-
-        return trail;
-      } else {
-        return context;
-      }
-    };
-
-    return trail;
-  }
-
-  function value$1(a, b) {
-    return a != null ? a : b;
-  }
-
-  const x = item => item.x || 0,
-        y = item => item.y || 0,
-        w = item => item.width || 0,
-        h = item => item.height || 0,
-        xw = item => (item.x || 0) + (item.width || 0),
-        yh = item => (item.y || 0) + (item.height || 0),
-        sa = item => item.startAngle || 0,
-        ea = item => item.endAngle || 0,
-        pa = item => item.padAngle || 0,
-        ir = item => item.innerRadius || 0,
-        or = item => item.outerRadius || 0,
-        cr = item => item.cornerRadius || 0,
-        tl = item => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0,
-        tr = item => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0,
-        br = item => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0,
-        bl = item => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,
-        sz = item => value$1(item.size, 64),
-        ts = item => item.size || 1,
-        def = item => !(item.defined === false),
-        type = item => symbols(item.shape || 'circle');
-
-  const arcShape = d3Shape.arc().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),
-        areavShape = d3Shape.area().x(x).y1(y).y0(yh).defined(def),
-        areahShape = d3Shape.area().y(y).x1(x).x0(xw).defined(def),
-        lineShape = d3Shape.line().x(x).y(y).defined(def),
-        rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl),
-        symbolShape = d3Shape.symbol().type(type).size(sz),
-        trailShape = vg_trail().x(x).y(y).defined(def).size(ts);
-  function hasCornerRadius(item) {
-    return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
-  }
-  function arc$1(context, item) {
-    return arcShape.context(context)(item);
-  }
-  function area$1(context, items) {
-    const item = items[0],
-          interp = item.interpolate || 'linear';
-    return (item.orient === 'horizontal' ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context)(items);
-  }
-  function line$1(context, items) {
-    const item = items[0],
-          interp = item.interpolate || 'linear';
-    return lineShape.curve(curves(interp, item.orient, item.tension)).context(context)(items);
-  }
-  function rectangle(context, item, x, y) {
-    return rectShape.context(context)(item, x, y);
-  }
-  function shape$1(context, item) {
-    return (item.mark.shape || item.shape).context(context)(item);
-  }
-  function symbol$1(context, item) {
-    return symbolShape.context(context)(item);
-  }
-  function trail$1(context, items) {
-    return trailShape.context(context)(items);
-  }
-
-  var clip_id = 1;
-  function resetSVGClipId() {
-    clip_id = 1;
-  }
-  function clip$1 (renderer, item, size) {
-    var clip = item.clip,
-        defs = renderer._defs,
-        id = item.clip_id || (item.clip_id = 'clip' + clip_id++),
-        c = defs.clipping[id] || (defs.clipping[id] = {
-      id: id
-    });
-
-    if (vegaUtil.isFunction(clip)) {
-      c.path = clip(null);
-    } else if (hasCornerRadius(size)) {
-      c.path = rectangle(null, size, 0, 0);
-    } else {
-      c.width = size.width || 0;
-      c.height = size.height || 0;
-    }
-
-    return 'url(#' + id + ')';
-  }
-
-  function Bounds(b) {
-    this.clear();
-    if (b) this.union(b);
-  }
-  Bounds.prototype = {
-    clone() {
-      return new Bounds(this);
-    },
-
-    clear() {
-      this.x1 = +Number.MAX_VALUE;
-      this.y1 = +Number.MAX_VALUE;
-      this.x2 = -Number.MAX_VALUE;
-      this.y2 = -Number.MAX_VALUE;
-      return this;
-    },
-
-    empty() {
-      return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
-    },
-
-    equals(b) {
-      return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
-    },
-
-    set(x1, y1, x2, y2) {
-      if (x2 < x1) {
-        this.x2 = x1;
-        this.x1 = x2;
-      } else {
-        this.x1 = x1;
-        this.x2 = x2;
-      }
-
-      if (y2 < y1) {
-        this.y2 = y1;
-        this.y1 = y2;
-      } else {
-        this.y1 = y1;
-        this.y2 = y2;
-      }
-
-      return this;
-    },
-
-    add(x, y) {
-      if (x < this.x1) this.x1 = x;
-      if (y < this.y1) this.y1 = y;
-      if (x > this.x2) this.x2 = x;
-      if (y > this.y2) this.y2 = y;
-      return this;
-    },
-
-    expand(d) {
-      this.x1 -= d;
-      this.y1 -= d;
-      this.x2 += d;
-      this.y2 += d;
-      return this;
-    },
-
-    round() {
-      this.x1 = Math.floor(this.x1);
-      this.y1 = Math.floor(this.y1);
-      this.x2 = Math.ceil(this.x2);
-      this.y2 = Math.ceil(this.y2);
-      return this;
-    },
-
-    scale(s) {
-      this.x1 *= s;
-      this.y1 *= s;
-      this.x2 *= s;
-      this.y2 *= s;
-      return this;
-    },
-
-    translate(dx, dy) {
-      this.x1 += dx;
-      this.x2 += dx;
-      this.y1 += dy;
-      this.y2 += dy;
-      return this;
-    },
-
-    rotate(angle, x, y) {
-      const p = this.rotatedPoints(angle, x, y);
-      return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
-    },
-
-    rotatedPoints(angle, x, y) {
-      var {
-        x1,
-        y1,
-        x2,
-        y2
-      } = this,
-          cos = Math.cos(angle),
-          sin = Math.sin(angle),
-          cx = x - x * cos + y * sin,
-          cy = y - x * sin - y * cos;
-      return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];
-    },
-
-    union(b) {
-      if (b.x1 < this.x1) this.x1 = b.x1;
-      if (b.y1 < this.y1) this.y1 = b.y1;
-      if (b.x2 > this.x2) this.x2 = b.x2;
-      if (b.y2 > this.y2) this.y2 = b.y2;
-      return this;
-    },
-
-    intersect(b) {
-      if (b.x1 > this.x1) this.x1 = b.x1;
-      if (b.y1 > this.y1) this.y1 = b.y1;
-      if (b.x2 < this.x2) this.x2 = b.x2;
-      if (b.y2 < this.y2) this.y2 = b.y2;
-      return this;
-    },
-
-    encloses(b) {
-      return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
-    },
-
-    alignsWith(b) {
-      return b && (this.x1 == b.x1 || this.x2 == b.x2 || this.y1 == b.y1 || this.y2 == b.y2);
-    },
-
-    intersects(b) {
-      return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
-    },
-
-    contains(x, y) {
-      return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
-    },
-
-    width() {
-      return this.x2 - this.x1;
-    },
-
-    height() {
-      return this.y2 - this.y1;
-    }
-
-  };
-
-  function Item(mark) {
-    this.mark = mark;
-    this.bounds = this.bounds || new Bounds();
-  }
-
-  function GroupItem(mark) {
-    Item.call(this, mark);
-    this.items = this.items || [];
-  }
-  vegaUtil.inherits(GroupItem, Item);
-
-  function ResourceLoader(customLoader) {
-    this._pending = 0;
-    this._loader = customLoader || vegaLoader.loader();
-  }
-
-  function increment(loader) {
-    loader._pending += 1;
-  }
-
-  function decrement(loader) {
-    loader._pending -= 1;
-  }
-
-  ResourceLoader.prototype = {
-    pending() {
-      return this._pending;
-    },
-
-    sanitizeURL(uri) {
-      const loader = this;
-      increment(loader);
-      return loader._loader.sanitize(uri, {
-        context: 'href'
-      }).then(opt => {
-        decrement(loader);
-        return opt;
-      }).catch(() => {
-        decrement(loader);
-        return null;
-      });
-    },
-
-    loadImage(uri) {
-      const loader = this,
-            Image = vegaCanvas.image();
-      increment(loader);
-      return loader._loader.sanitize(uri, {
-        context: 'image'
-      }).then(opt => {
-        const url = opt.href;
-        if (!url || !Image) throw {
-          url: url
-        };
-        const img = new Image(); // set crossOrigin only if cors is defined; empty string sets anonymous mode
-        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin
-
-        const cors = vegaUtil.hasOwnProperty(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';
-        if (cors != null) img.crossOrigin = cors; // attempt to load image resource
-
-        img.onload = () => decrement(loader);
-
-        img.onerror = () => decrement(loader);
-
-        img.src = url;
-        return img;
-      }).catch(e => {
-        decrement(loader);
-        return {
-          complete: false,
-          width: 0,
-          height: 0,
-          src: e && e.url || ''
-        };
-      });
-    },
-
-    ready() {
-      const loader = this;
-      return new Promise(accept => {
-        function poll(value) {
-          if (!loader.pending()) accept(value);else setTimeout(() => {
-            poll(true);
-          }, 10);
-        }
-
-        poll(false);
-      });
-    }
-
-  };
-
-  function boundStroke (bounds, item, miter) {
-    if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
-      const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
-      bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
-    }
-
-    return bounds;
-  }
-
-  function miterAdjustment(item, strokeWidth) {
-    // TODO: more sophisticated adjustment? Or miter support in boundContext?
-    return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;
-  }
-
-  const circleThreshold = Tau - 1e-8;
-  let bounds, lx, ly, rot, ma, mb, mc, md;
-
-  const add = (x, y) => bounds.add(x, y);
-
-  const addL = (x, y) => add(lx = x, ly = y);
-
-  const addX = x => add(x, bounds.y1);
-
-  const addY = y => add(bounds.x1, y);
-
-  const px = (x, y) => ma * x + mc * y;
-
-  const py = (x, y) => mb * x + md * y;
-
-  const addp = (x, y) => add(px(x, y), py(x, y));
-
-  const addpL = (x, y) => addL(px(x, y), py(x, y));
-
-  function boundContext (_, deg) {
-    bounds = _;
-
-    if (deg) {
-      rot = deg * DegToRad;
-      ma = md = Math.cos(rot);
-      mb = Math.sin(rot);
-      mc = -mb;
-    } else {
-      ma = md = 1;
-      rot = mb = mc = 0;
-    }
-
-    return context$1;
-  }
-  const context$1 = {
-    beginPath() {},
-
-    closePath() {},
-
-    moveTo: addpL,
-    lineTo: addpL,
-
-    rect(x, y, w, h) {
-      if (rot) {
-        addp(x + w, y);
-        addp(x + w, y + h);
-        addp(x, y + h);
-        addpL(x, y);
-      } else {
-        add(x + w, y + h);
-        addL(x, y);
-      }
-    },
-
-    quadraticCurveTo(x1, y1, x2, y2) {
-      const px1 = px(x1, y1),
-            py1 = py(x1, y1),
-            px2 = px(x2, y2),
-            py2 = py(x2, y2);
-      quadExtrema(lx, px1, px2, addX);
-      quadExtrema(ly, py1, py2, addY);
-      addL(px2, py2);
-    },
-
-    bezierCurveTo(x1, y1, x2, y2, x3, y3) {
-      const px1 = px(x1, y1),
-            py1 = py(x1, y1),
-            px2 = px(x2, y2),
-            py2 = py(x2, y2),
-            px3 = px(x3, y3),
-            py3 = py(x3, y3);
-      cubicExtrema(lx, px1, px2, px3, addX);
-      cubicExtrema(ly, py1, py2, py3, addY);
-      addL(px3, py3);
-    },
-
-    arc(cx, cy, r, sa, ea, ccw) {
-      sa += rot;
-      ea += rot; // store last point on path
-
-      lx = r * Math.cos(ea) + cx;
-      ly = r * Math.sin(ea) + cy;
-
-      if (Math.abs(ea - sa) > circleThreshold) {
-        // treat as full circle
-        add(cx - r, cy - r);
-        add(cx + r, cy + r);
-      } else {
-        const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);
-
-        let s, i; // sample end points
-
-        update(sa);
-        update(ea); // sample interior points aligned with 90 degrees
-
-        if (ea !== sa) {
-          sa = sa % Tau;
-          if (sa < 0) sa += Tau;
-          ea = ea % Tau;
-          if (ea < 0) ea += Tau;
-
-          if (ea < sa) {
-            ccw = !ccw; // flip direction
-
-            s = sa;
-            sa = ea;
-            ea = s; // swap end-points
-          }
-
-          if (ccw) {
-            ea -= Tau;
-            s = sa - sa % HalfPi;
-
-            for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) update(s);
-          } else {
-            s = sa - sa % HalfPi + HalfPi;
-
-            for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) update(s);
-          }
-        }
-      }
-    }
-
-  };
-
-  function quadExtrema(x0, x1, x2, cb) {
-    const t = (x0 - x1) / (x0 + x2 - 2 * x1);
-    if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);
-  }
-
-  function cubicExtrema(x0, x1, x2, x3, cb) {
-    const a = x3 - x0 + 3 * x1 - 3 * x2,
-          b = x0 + x2 - 2 * x1,
-          c = x0 - x1;
-    let t0 = 0,
-        t1 = 0,
-        r; // solve for parameter t
-
-    if (Math.abs(a) > Epsilon) {
-      // quadratic equation
-      r = b * b + c * a;
-
-      if (r >= 0) {
-        r = Math.sqrt(r);
-        t0 = (-b + r) / a;
-        t1 = (-b - r) / a;
-      }
-    } else {
-      // linear equation
-      t0 = 0.5 * c / b;
-    } // calculate position
-
-
-    if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));
-    if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));
-  }
-
-  function cubic(t, x0, x1, x2, x3) {
-    const s = 1 - t,
-          s2 = s * s,
-          t2 = t * t;
-    return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;
-  }
-
-  var context = (context = vegaCanvas.canvas(1, 1)) ? context.getContext('2d') : null;
-
-  const b = new Bounds();
-  function intersectPath(draw) {
-    return function (item, brush) {
-      // rely on (inaccurate) bounds intersection if no context
-      if (!context) return true; // add path to offscreen graphics context
-
-      draw(context, item); // get bounds intersection region
-
-      b.clear().union(item.bounds).intersect(brush).round();
-      const {
-        x1,
-        y1,
-        x2,
-        y2
-      } = b; // iterate over intersection region
-      // perform fine grained inclusion test
-
-      for (let y = y1; y <= y2; ++y) {
-        for (let x = x1; x <= x2; ++x) {
-          if (context.isPointInPath(x, y)) {
-            return true;
-          }
-        }
-      } // false if no hits in intersection region
-
-
-      return false;
-    };
-  }
-  function intersectPoint(item, box) {
-    return box.contains(item.x || 0, item.y || 0);
-  }
-  function intersectRect(item, box) {
-    const x = item.x || 0,
-          y = item.y || 0,
-          w = item.width || 0,
-          h = item.height || 0;
-    return box.intersects(b.set(x, y, x + w, y + h));
-  }
-  function intersectRule(item, box) {
-    const x = item.x || 0,
-          y = item.y || 0,
-          x2 = item.x2 != null ? item.x2 : x,
-          y2 = item.y2 != null ? item.y2 : y;
-    return intersectBoxLine(box, x, y, x2, y2);
-  }
-  function intersectBoxLine(box, x, y, u, v) {
-    const {
-      x1,
-      y1,
-      x2,
-      y2
-    } = box,
-          dx = u - x,
-          dy = v - y;
-    let t0 = 0,
-        t1 = 1,
-        p,
-        q,
-        r,
-        e;
-
-    for (e = 0; e < 4; ++e) {
-      if (e === 0) {
-        p = -dx;
-        q = -(x1 - x);
-      }
-
-      if (e === 1) {
-        p = dx;
-        q = x2 - x;
-      }
-
-      if (e === 2) {
-        p = -dy;
-        q = -(y1 - y);
-      }
-
-      if (e === 3) {
-        p = dy;
-        q = y2 - y;
-      }
-
-      if (Math.abs(p) < 1e-10 && q < 0) return false;
-      r = q / p;
-
-      if (p < 0) {
-        if (r > t1) return false;else if (r > t0) t0 = r;
-      } else if (p > 0) {
-        if (r < t0) return false;else if (r < t1) t1 = r;
-      }
-    }
-
-    return true;
-  }
-
-  function blend (context, item) {
-    context.globalCompositeOperation = item.blend || 'source-over';
-  }
-
-  function value (value, dflt) {
-    return value == null ? dflt : value;
-  }
-
-  function addStops(gradient, stops) {
-    const n = stops.length;
-
-    for (let i = 0; i < n; ++i) {
-      gradient.addColorStop(stops[i].offset, stops[i].color);
-    }
-
-    return gradient;
-  }
-
-  function gradient (context, spec, bounds) {
-    const w = bounds.width(),
-          h = bounds.height();
-    let gradient;
-
-    if (spec.gradient === 'radial') {
-      gradient = context.createRadialGradient(bounds.x1 + value(spec.x1, 0.5) * w, bounds.y1 + value(spec.y1, 0.5) * h, Math.max(w, h) * value(spec.r1, 0), bounds.x1 + value(spec.x2, 0.5) * w, bounds.y1 + value(spec.y2, 0.5) * h, Math.max(w, h) * value(spec.r2, 0.5));
-    } else {
-      // linear gradient
-      const x1 = value(spec.x1, 0),
-            y1 = value(spec.y1, 0),
-            x2 = value(spec.x2, 1),
-            y2 = value(spec.y2, 0);
-
-      if (x1 === x2 || y1 === y2 || w === h) {
-        // axis aligned: use normal gradient
-        gradient = context.createLinearGradient(bounds.x1 + x1 * w, bounds.y1 + y1 * h, bounds.x1 + x2 * w, bounds.y1 + y2 * h);
-      } else {
-        // not axis aligned: render gradient into a pattern (#2365)
-        // this allows us to use normalized bounding box coordinates
-        const image = vegaCanvas.canvas(Math.ceil(w), Math.ceil(h)),
-              ictx = image.getContext('2d');
-        ictx.scale(w, h);
-        ictx.fillStyle = addStops(ictx.createLinearGradient(x1, y1, x2, y2), spec.stops);
-        ictx.fillRect(0, 0, w, h);
-        return context.createPattern(image, 'no-repeat');
-      }
-    }
-
-    return addStops(gradient, spec.stops);
-  }
-
-  function color (context, item, value) {
-    return isGradient(value) ? gradient(context, value, item.bounds) : value;
-  }
-
-  function fill (context, item, opacity) {
-    opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;
-
-    if (opacity > 0) {
-      context.globalAlpha = opacity;
-      context.fillStyle = color(context, item, item.fill);
-      return true;
-    } else {
-      return false;
-    }
-  }
-
-  var Empty = [];
-  function stroke (context, item, opacity) {
-    var lw = (lw = item.strokeWidth) != null ? lw : 1;
-    if (lw <= 0) return false;
-    opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
-
-    if (opacity > 0) {
-      context.globalAlpha = opacity;
-      context.strokeStyle = color(context, item, item.stroke);
-      context.lineWidth = lw;
-      context.lineCap = item.strokeCap || 'butt';
-      context.lineJoin = item.strokeJoin || 'miter';
-      context.miterLimit = item.strokeMiterLimit || 10;
-
-      if (context.setLineDash) {
-        context.setLineDash(item.strokeDash || Empty);
-        context.lineDashOffset = item.strokeDashOffset || 0;
-      }
-
-      return true;
-    } else {
-      return false;
-    }
-  }
-
-  function compare(a, b) {
-    return a.zindex - b.zindex || a.index - b.index;
-  }
-
-  function zorder(scene) {
-    if (!scene.zdirty) return scene.zitems;
-    var items = scene.items,
-        output = [],
-        item,
-        i,
-        n;
-
-    for (i = 0, n = items.length; i < n; ++i) {
-      item = items[i];
-      item.index = i;
-      if (item.zindex) output.push(item);
-    }
-
-    scene.zdirty = false;
-    return scene.zitems = output.sort(compare);
-  }
-  function visit(scene, visitor) {
-    var items = scene.items,
-        i,
-        n;
-    if (!items || !items.length) return;
-    const zitems = zorder(scene);
-
-    if (zitems && zitems.length) {
-      for (i = 0, n = items.length; i < n; ++i) {
-        if (!items[i].zindex) visitor(items[i]);
-      }
-
-      items = zitems;
-    }
-
-    for (i = 0, n = items.length; i < n; ++i) {
-      visitor(items[i]);
-    }
-  }
-  function pickVisit(scene, visitor) {
-    var items = scene.items,
-        hit,
-        i;
-    if (!items || !items.length) return null;
-    const zitems = zorder(scene);
-    if (zitems && zitems.length) items = zitems;
-
-    for (i = items.length; --i >= 0;) {
-      if (hit = visitor(items[i])) return hit;
-    }
-
-    if (items === zitems) {
-      for (items = scene.items, i = items.length; --i >= 0;) {
-        if (!items[i].zindex) {
-          if (hit = visitor(items[i])) return hit;
-        }
-      }
-    }
-
-    return null;
-  }
-
-  function drawAll(path) {
-    return function (context, scene, bounds) {
-      visit(scene, item => {
-        if (!bounds || bounds.intersects(item.bounds)) {
-          drawPath(path, context, item, item);
-        }
-      });
-    };
-  }
-  function drawOne(path) {
-    return function (context, scene, bounds) {
-      if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {
-        drawPath(path, context, scene.items[0], scene.items);
-      }
-    };
-  }
-
-  function drawPath(path, context, item, items) {
-    var opacity = item.opacity == null ? 1 : item.opacity;
-    if (opacity === 0) return;
-    if (path(context, items)) return;
-    blend(context, item);
-
-    if (item.fill && fill(context, item, opacity)) {
-      context.fill();
-    }
-
-    if (item.stroke && stroke(context, item, opacity)) {
-      context.stroke();
-    }
-  }
-
-  function pick$1(test) {
-    test = test || vegaUtil.truthy;
-    return function (context, scene, x, y, gx, gy) {
-      x *= context.pixelRatio;
-      y *= context.pixelRatio;
-      return pickVisit(scene, item => {
-        const b = item.bounds; // first hit test against bounding box
-
-        if (b && !b.contains(gx, gy) || !b) return; // if in bounding box, perform more careful test
-
-        if (test(context, item, x, y, gx, gy)) return item;
-      });
-    };
-  }
-  function hitPath(path, filled) {
-    return function (context, o, x, y) {
-      var item = Array.isArray(o) ? o[0] : o,
-          fill = filled == null ? item.fill : filled,
-          stroke = item.stroke && context.isPointInStroke,
-          lw,
-          lc;
-
-      if (stroke) {
-        lw = item.strokeWidth;
-        lc = item.strokeCap;
-        context.lineWidth = lw != null ? lw : 1;
-        context.lineCap = lc != null ? lc : 'butt';
-      }
-
-      return path(context, o) ? false : fill && context.isPointInPath(x, y) || stroke && context.isPointInStroke(x, y);
-    };
-  }
-  function pickPath(path) {
-    return pick$1(hitPath(path));
-  }
-
-  function translate(x, y) {
-    return 'translate(' + x + ',' + y + ')';
-  }
-  function rotate(a) {
-    return 'rotate(' + a + ')';
-  }
-  function scale(scaleX, scaleY) {
-    return 'scale(' + scaleX + ',' + scaleY + ')';
-  }
-  function translateItem(item) {
-    return translate(item.x || 0, item.y || 0);
-  }
-  function rotateItem(item) {
-    return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '');
-  }
-  function transformItem(item) {
-    return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '') + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');
-  }
-
-  function markItemPath (type, shape, isect) {
-    function attr(emit, item) {
-      emit('transform', rotateItem(item));
-      emit('d', shape(null, item));
-    }
-
-    function bound(bounds, item) {
-      shape(boundContext(bounds, item.angle), item);
-      return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);
-    }
-
-    function draw(context, item) {
-      var x = item.x || 0,
-          y = item.y || 0,
-          a = item.angle || 0;
-      context.translate(x, y);
-      if (a) context.rotate(a *= DegToRad);
-      context.beginPath();
-      shape(context, item);
-      if (a) context.rotate(-a);
-      context.translate(-x, -y);
-    }
-
-    return {
-      type: type,
-      tag: 'path',
-      nested: false,
-      attr: attr,
-      bound: bound,
-      draw: drawAll(draw),
-      pick: pickPath(draw),
-      isect: isect || intersectPath(draw)
-    };
-  }
-
-  var arc = markItemPath('arc', arc$1);
-
-  function pickArea(a, p) {
-    var v = a[0].orient === 'horizontal' ? p[1] : p[0],
-        z = a[0].orient === 'horizontal' ? 'y' : 'x',
-        i = a.length,
-        min = +Infinity,
-        hit,
-        d;
-
-    while (--i >= 0) {
-      if (a[i].defined === false) continue;
-      d = Math.abs(a[i][z] - v);
-
-      if (d < min) {
-        min = d;
-        hit = a[i];
-      }
-    }
-
-    return hit;
-  }
-  function pickLine(a, p) {
-    var t = Math.pow(a[0].strokeWidth || 1, 2),
-        i = a.length,
-        dx,
-        dy,
-        dd;
-
-    while (--i >= 0) {
-      if (a[i].defined === false) continue;
-      dx = a[i].x - p[0];
-      dy = a[i].y - p[1];
-      dd = dx * dx + dy * dy;
-      if (dd < t) return a[i];
-    }
-
-    return null;
-  }
-  function pickTrail(a, p) {
-    var i = a.length,
-        dx,
-        dy,
-        dd;
-
-    while (--i >= 0) {
-      if (a[i].defined === false) continue;
-      dx = a[i].x - p[0];
-      dy = a[i].y - p[1];
-      dd = dx * dx + dy * dy;
-      dx = a[i].size || 1;
-      if (dd < dx * dx) return a[i];
-    }
-
-    return null;
-  }
-
-  function markMultiItemPath (type, shape, tip) {
-    function attr(emit, item) {
-      var items = item.mark.items;
-      if (items.length) emit('d', shape(null, items));
-    }
-
-    function bound(bounds, mark) {
-      var items = mark.items;
-
-      if (items.length === 0) {
-        return bounds;
-      } else {
-        shape(boundContext(bounds), items);
-        return boundStroke(bounds, items[0]);
-      }
-    }
-
-    function draw(context, items) {
-      context.beginPath();
-      shape(context, items);
-    }
-
-    const hit = hitPath(draw);
-
-    function pick(context, scene, x, y, gx, gy) {
-      var items = scene.items,
-          b = scene.bounds;
-
-      if (!items || !items.length || b && !b.contains(gx, gy)) {
-        return null;
-      }
-
-      x *= context.pixelRatio;
-      y *= context.pixelRatio;
-      return hit(context, items, x, y) ? items[0] : null;
-    }
-
-    return {
-      type: type,
-      tag: 'path',
-      nested: true,
-      attr: attr,
-      bound: bound,
-      draw: drawOne(draw),
-      pick: pick,
-      isect: intersectPoint,
-      tip: tip
-    };
-  }
-
-  var area = markMultiItemPath('area', area$1, pickArea);
-
-  function clip (context, scene) {
-    var clip = scene.clip;
-    context.save();
-
-    if (vegaUtil.isFunction(clip)) {
-      context.beginPath();
-      clip(context);
-      context.clip();
-    } else {
-      clipGroup(context, scene.group);
-    }
-  }
-  function clipGroup(context, group) {
-    context.beginPath();
-    hasCornerRadius(group) ? rectangle(context, group, 0, 0) : context.rect(0, 0, group.width || 0, group.height || 0);
-    context.clip();
-  }
-
-  function offset$1(item) {
-    const sw = value(item.strokeWidth, 1);
-    return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
-  }
-
-  function attr$5(emit, item) {
-    emit('transform', translateItem(item));
-  }
-
-  function emitRectangle(emit, item) {
-    const off = offset$1(item);
-    emit('d', rectangle(null, item, off, off));
-  }
-
-  function background(emit, item) {
-    emit('class', 'background');
-    emit('aria-hidden', true);
-    emitRectangle(emit, item);
-  }
-
-  function foreground(emit, item) {
-    emit('class', 'foreground');
-    emit('aria-hidden', true);
-
-    if (item.strokeForeground) {
-      emitRectangle(emit, item);
-    } else {
-      emit('d', '');
-    }
-  }
-
-  function content(emit, item, renderer) {
-    const url = item.clip ? clip$1(renderer, item, item) : null;
-    emit('clip-path', url);
-  }
-
-  function bound$5(bounds, group) {
-    if (!group.clip && group.items) {
-      const items = group.items,
-            m = items.length;
-
-      for (let j = 0; j < m; ++j) {
-        bounds.union(items[j].bounds);
-      }
-    }
-
-    if ((group.clip || group.width || group.height) && !group.noBound) {
-      bounds.add(0, 0).add(group.width || 0, group.height || 0);
-    }
-
-    boundStroke(bounds, group);
-    return bounds.translate(group.x || 0, group.y || 0);
-  }
-
-  function rectanglePath(context, group, x, y) {
-    const off = offset$1(group);
-    context.beginPath();
-    rectangle(context, group, (x || 0) + off, (y || 0) + off);
-  }
-
-  const hitBackground = hitPath(rectanglePath);
-  const hitForeground = hitPath(rectanglePath, false);
-  const hitCorner = hitPath(rectanglePath, true);
-
-  function draw$4(context, scene, bounds) {
-    visit(scene, group => {
-      const gx = group.x || 0,
-            gy = group.y || 0,
-            fore = group.strokeForeground,
-            opacity = group.opacity == null ? 1 : group.opacity; // draw group background
-
-      if ((group.stroke || group.fill) && opacity) {
-        rectanglePath(context, group, gx, gy);
-        blend(context, group);
-
-        if (group.fill && fill(context, group, opacity)) {
-          context.fill();
-        }
-
-        if (group.stroke && !fore && stroke(context, group, opacity)) {
-          context.stroke();
-        }
-      } // setup graphics context, set clip and bounds
-
-
-      context.save();
-      context.translate(gx, gy);
-      if (group.clip) clipGroup(context, group);
-      if (bounds) bounds.translate(-gx, -gy); // draw group contents
-
-      visit(group, item => {
-        this.draw(context, item, bounds);
-      }); // restore graphics context
-
-      if (bounds) bounds.translate(gx, gy);
-      context.restore(); // draw group foreground
-
-      if (fore && group.stroke && opacity) {
-        rectanglePath(context, group, gx, gy);
-        blend(context, group);
-
-        if (stroke(context, group, opacity)) {
-          context.stroke();
-        }
-      }
-    });
-  }
-
-  function pick(context, scene, x, y, gx, gy) {
-    if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
-      return null;
-    }
-
-    const cx = x * context.pixelRatio,
-          cy = y * context.pixelRatio;
-    return pickVisit(scene, group => {
-      let hit, dx, dy; // first hit test bounding box
-
-      const b = group.bounds;
-      if (b && !b.contains(gx, gy)) return; // passed bounds check, test rectangular clip
-
-      dx = group.x || 0;
-      dy = group.y || 0;
-      const dw = dx + (group.width || 0),
-            dh = dy + (group.height || 0),
-            c = group.clip;
-      if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return; // adjust coordinate system
-
-      context.save();
-      context.translate(dx, dy);
-      dx = gx - dx;
-      dy = gy - dy; // test background for rounded corner clip
-
-      if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {
-        context.restore();
-        return null;
-      }
-
-      const fore = group.strokeForeground,
-            ix = scene.interactive !== false; // hit test against group foreground
-
-      if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {
-        context.restore();
-        return group;
-      } // hit test against contained marks
-
-
-      hit = pickVisit(group, mark => pickMark(mark, dx, dy) ? this.pick(mark, x, y, dx, dy) : null); // hit test against group background
-
-      if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {
-        hit = group;
-      } // restore state and return
-
-
-      context.restore();
-      return hit || null;
-    });
-  }
-
-  function pickMark(mark, x, y) {
-    return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);
-  }
-
-  var group = {
-    type: 'group',
-    tag: 'g',
-    nested: false,
-    attr: attr$5,
-    bound: bound$5,
-    draw: draw$4,
-    pick: pick,
-    isect: intersectRect,
-    content: content,
-    background: background,
-    foreground: foreground
-  };
-
-  var metadata = {
-    'xmlns': 'http://www.w3.org/2000/svg',
-    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
-    'version': '1.1'
-  };
-
-  function getImage(item, renderer) {
-    var image = item.image;
-
-    if (!image || item.url && item.url !== image.url) {
-      image = {
-        complete: false,
-        width: 0,
-        height: 0
-      };
-      renderer.loadImage(item.url).then(image => {
-        item.image = image;
-        item.image.url = item.url;
-      });
-    }
-
-    return image;
-  }
-
-  function imageWidth(item, image) {
-    return item.width != null ? item.width : !image || !image.width ? 0 : item.aspect !== false && item.height ? item.height * image.width / image.height : image.width;
-  }
-
-  function imageHeight(item, image) {
-    return item.height != null ? item.height : !image || !image.height ? 0 : item.aspect !== false && item.width ? item.width * image.height / image.width : image.height;
-  }
-
-  function imageXOffset(align, w) {
-    return align === 'center' ? w / 2 : align === 'right' ? w : 0;
-  }
-
-  function imageYOffset(baseline, h) {
-    return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;
-  }
-
-  function attr$4(emit, item, renderer) {
-    const img = getImage(item, renderer),
-          w = imageWidth(item, img),
-          h = imageHeight(item, img),
-          x = (item.x || 0) - imageXOffset(item.align, w),
-          y = (item.y || 0) - imageYOffset(item.baseline, h),
-          i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';
-    emit('href', i, metadata['xmlns:xlink'], 'xlink:href');
-    emit('transform', translate(x, y));
-    emit('width', w);
-    emit('height', h);
-    emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');
-  }
-
-  function bound$4(bounds, item) {
-    const img = item.image,
-          w = imageWidth(item, img),
-          h = imageHeight(item, img),
-          x = (item.x || 0) - imageXOffset(item.align, w),
-          y = (item.y || 0) - imageYOffset(item.baseline, h);
-    return bounds.set(x, y, x + w, y + h);
-  }
-
-  function draw$3(context, scene, bounds) {
-    visit(scene, item => {
-      if (bounds && !bounds.intersects(item.bounds)) return; // bounds check
-
-      const img = getImage(item, this);
-      let w = imageWidth(item, img);
-      let h = imageHeight(item, img);
-      if (w === 0 || h === 0) return; // early exit
-
-      let x = (item.x || 0) - imageXOffset(item.align, w),
-          y = (item.y || 0) - imageYOffset(item.baseline, h),
-          opacity,
-          ar0,
-          ar1,
-          t;
-
-      if (item.aspect !== false) {
-        ar0 = img.width / img.height;
-        ar1 = item.width / item.height;
-
-        if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
-          if (ar1 < ar0) {
-            t = w / ar0;
-            y += (h - t) / 2;
-            h = t;
-          } else {
-            t = h * ar0;
-            x += (w - t) / 2;
-            w = t;
-          }
-        }
-      }
-
-      if (img.complete || img.toDataURL) {
-        blend(context, item);
-        context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;
-        context.imageSmoothingEnabled = item.smooth !== false;
-        context.drawImage(img, x, y, w, h);
-      }
-    });
-  }
-
-  var image = {
-    type: 'image',
-    tag: 'image',
-    nested: false,
-    attr: attr$4,
-    bound: bound$4,
-    draw: draw$3,
-    pick: pick$1(),
-    isect: vegaUtil.truthy,
-    // bounds check is sufficient
-    get: getImage,
-    xOffset: imageXOffset,
-    yOffset: imageYOffset
-  };
-
-  var line = markMultiItemPath('line', line$1, pickLine);
-
-  function attr$3(emit, item) {
-    var sx = item.scaleX || 1,
-        sy = item.scaleY || 1;
-
-    if (sx !== 1 || sy !== 1) {
-      emit('vector-effect', 'non-scaling-stroke');
-    }
-
-    emit('transform', transformItem(item));
-    emit('d', item.path);
-  }
-
-  function path$1(context, item) {
-    var path = item.path;
-    if (path == null) return true;
-    var x = item.x || 0,
-        y = item.y || 0,
-        sx = item.scaleX || 1,
-        sy = item.scaleY || 1,
-        a = (item.angle || 0) * DegToRad,
-        cache = item.pathCache;
-
-    if (!cache || cache.path !== path) {
-      (item.pathCache = cache = pathParse(path)).path = path;
-    }
-
-    if (a && context.rotate && context.translate) {
-      context.translate(x, y);
-      context.rotate(a);
-      pathRender(context, cache, 0, 0, sx, sy);
-      context.rotate(-a);
-      context.translate(-x, -y);
-    } else {
-      pathRender(context, cache, x, y, sx, sy);
-    }
-  }
-
-  function bound$3(bounds, item) {
-    return path$1(boundContext(bounds, item.angle), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);
-  }
-
-  var path$2 = {
-    type: 'path',
-    tag: 'path',
-    nested: false,
-    attr: attr$3,
-    bound: bound$3,
-    draw: drawAll(path$1),
-    pick: pickPath(path$1),
-    isect: intersectPath(path$1)
-  };
-
-  function attr$2(emit, item) {
-    emit('d', rectangle(null, item));
-  }
-
-  function bound$2(bounds, item) {
-    var x, y;
-    return boundStroke(bounds.set(x = item.x || 0, y = item.y || 0, x + item.width || 0, y + item.height || 0), item);
-  }
-
-  function draw$2(context, item) {
-    context.beginPath();
-    rectangle(context, item);
-  }
-
-  var rect = {
-    type: 'rect',
-    tag: 'path',
-    nested: false,
-    attr: attr$2,
-    bound: bound$2,
-    draw: drawAll(draw$2),
-    pick: pickPath(draw$2),
-    isect: intersectRect
-  };
-
-  function attr$1(emit, item) {
-    emit('transform', translateItem(item));
-    emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);
-    emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);
-  }
-
-  function bound$1(bounds, item) {
-    var x1, y1;
-    return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);
-  }
-
-  function path(context, item, opacity) {
-    var x1, y1, x2, y2;
-
-    if (item.stroke && stroke(context, item, opacity)) {
-      x1 = item.x || 0;
-      y1 = item.y || 0;
-      x2 = item.x2 != null ? item.x2 : x1;
-      y2 = item.y2 != null ? item.y2 : y1;
-      context.beginPath();
-      context.moveTo(x1, y1);
-      context.lineTo(x2, y2);
-      return true;
-    }
-
-    return false;
-  }
-
-  function draw$1(context, scene, bounds) {
-    visit(scene, item => {
-      if (bounds && !bounds.intersects(item.bounds)) return; // bounds check
-
-      var opacity = item.opacity == null ? 1 : item.opacity;
-
-      if (opacity && path(context, item, opacity)) {
-        blend(context, item);
-        context.stroke();
-      }
-    });
-  }
-
-  function hit$1(context, item, x, y) {
-    if (!context.isPointInStroke) return false;
-    return path(context, item, 1) && context.isPointInStroke(x, y);
-  }
-
-  var rule = {
-    type: 'rule',
-    tag: 'line',
-    nested: false,
-    attr: attr$1,
-    bound: bound$1,
-    draw: draw$1,
-    pick: pick$1(hit$1),
-    isect: intersectRule
-  };
-
-  var shape = markItemPath('shape', shape$1);
-
-  var symbol = markItemPath('symbol', symbol$1, intersectPoint);
-
-  const widthCache = vegaUtil.lruCache();
-  var textMetrics = {
-    height: fontSize,
-    measureWidth: measureWidth,
-    estimateWidth: estimateWidth,
-    width: estimateWidth,
-    canvas: useCanvas
-  };
-  useCanvas(true);
-
-  function useCanvas(use) {
-    textMetrics.width = use && context ? measureWidth : estimateWidth;
-  } // make simple estimate if no canvas is available
-
-
-  function estimateWidth(item, text) {
-    return _estimateWidth(textValue(item, text), fontSize(item));
-  }
-
-  function _estimateWidth(text, currentFontHeight) {
-    return ~~(0.8 * text.length * currentFontHeight);
-  } // measure text width if canvas is available
-
-
-  function measureWidth(item, text) {
-    return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0 : _measureWidth(text, font(item));
-  }
-
-  function _measureWidth(text, currentFont) {
-    const key = `(${currentFont}) ${text}`;
-    let width = widthCache.get(key);
-
-    if (width === undefined) {
-      context.font = currentFont;
-      width = context.measureText(text).width;
-      widthCache.set(key, width);
-    }
-
-    return width;
-  }
-
-  function fontSize(item) {
-    return item.fontSize != null ? +item.fontSize || 0 : 11;
-  }
-  function lineHeight(item) {
-    return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
-  }
-
-  function lineArray(_) {
-    return vegaUtil.isArray(_) ? _.length > 1 ? _ : _[0] : _;
-  }
-
-  function textLines(item) {
-    return lineArray(item.lineBreak && item.text && !vegaUtil.isArray(item.text) ? item.text.split(item.lineBreak) : item.text);
-  }
-  function multiLineOffset(item) {
-    const tl = textLines(item);
-    return (vegaUtil.isArray(tl) ? tl.length - 1 : 0) * lineHeight(item);
-  }
-  function textValue(item, line) {
-    const text = line == null ? '' : (line + '').trim();
-    return item.limit > 0 && text.length ? truncate(item, text) : text;
-  }
-
-  function widthGetter(item) {
-    if (textMetrics.width === measureWidth) {
-      // we are using canvas
-      const currentFont = font(item);
-      return text => _measureWidth(text, currentFont);
-    } else {
-      // we are relying on estimates
-      const currentFontHeight = fontSize(item);
-      return text => _estimateWidth(text, currentFontHeight);
-    }
-  }
-
-  function truncate(item, text) {
-    var limit = +item.limit,
-        width = widthGetter(item);
-    if (width(text) < limit) return text;
-    var ellipsis = item.ellipsis || '\u2026',
-        rtl = item.dir === 'rtl',
-        lo = 0,
-        hi = text.length,
-        mid;
-    limit -= width(ellipsis);
-
-    if (rtl) {
-      while (lo < hi) {
-        mid = lo + hi >>> 1;
-        if (width(text.slice(mid)) > limit) lo = mid + 1;else hi = mid;
-      }
-
-      return ellipsis + text.slice(lo);
-    } else {
-      while (lo < hi) {
-        mid = 1 + (lo + hi >>> 1);
-        if (width(text.slice(0, mid)) < limit) lo = mid;else hi = mid - 1;
-      }
-
-      return text.slice(0, lo) + ellipsis;
-    }
-  }
-
-  function fontFamily(item, quote) {
-    var font = item.font;
-    return (quote && font ? String(font).replace(/"/g, '\'') : font) || 'sans-serif';
-  }
-  function font(item, quote) {
-    return '' + (item.fontStyle ? item.fontStyle + ' ' : '') + (item.fontVariant ? item.fontVariant + ' ' : '') + (item.fontWeight ? item.fontWeight + ' ' : '') + fontSize(item) + 'px ' + fontFamily(item, quote);
-  }
-  function offset(item) {
-    // perform our own font baseline calculation
-    // why? not all browsers support SVG 1.1 'alignment-baseline' :(
-    // this also ensures consistent layout across renderers
-    var baseline = item.baseline,
-        h = fontSize(item);
-    return Math.round(baseline === 'top' ? 0.79 * h : baseline === 'middle' ? 0.30 * h : baseline === 'bottom' ? -0.21 * h : baseline === 'line-top' ? 0.29 * h + 0.5 * lineHeight(item) : baseline === 'line-bottom' ? 0.29 * h - 0.5 * lineHeight(item) : 0);
-  }
-
-  const textAlign = {
-    'left': 'start',
-    'center': 'middle',
-    'right': 'end'
-  };
-  const tempBounds = new Bounds();
-
-  function anchorPoint(item) {
-    var x = item.x || 0,
-        y = item.y || 0,
-        r = item.radius || 0,
-        t;
-
-    if (r) {
-      t = (item.theta || 0) - HalfPi;
-      x += r * Math.cos(t);
-      y += r * Math.sin(t);
-    }
-
-    tempBounds.x1 = x;
-    tempBounds.y1 = y;
-    return tempBounds;
-  }
-
-  function attr(emit, item) {
-    var dx = item.dx || 0,
-        dy = (item.dy || 0) + offset(item),
-        p = anchorPoint(item),
-        x = p.x1,
-        y = p.y1,
-        a = item.angle || 0,
-        t;
-    emit('text-anchor', textAlign[item.align] || 'start');
-
-    if (a) {
-      t = translate(x, y) + ' ' + rotate(a);
-      if (dx || dy) t += ' ' + translate(dx, dy);
-    } else {
-      t = translate(x + dx, y + dy);
-    }
-
-    emit('transform', t);
-  }
-
-  function bound(bounds, item, mode) {
-    var h = textMetrics.height(item),
-        a = item.align,
-        p = anchorPoint(item),
-        x = p.x1,
-        y = p.y1,
-        dx = item.dx || 0,
-        dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h),
-        // use 4/5 offset
-    tl = textLines(item),
-        w; // get dimensions
-
-    if (vegaUtil.isArray(tl)) {
-      // multi-line text
-      h += lineHeight(item) * (tl.length - 1);
-      w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);
-    } else {
-      // single-line text
-      w = textMetrics.width(item, tl);
-    } // horizontal alignment
-
-
-    if (a === 'center') {
-      dx -= w / 2;
-    } else if (a === 'right') {
-      dx -= w;
-    } else ;
-
-    bounds.set(dx += x, dy += y, dx + w, dy + h);
-
-    if (item.angle && !mode) {
-      bounds.rotate(item.angle * DegToRad, x, y);
-    } else if (mode === 2) {
-      return bounds.rotatedPoints(item.angle * DegToRad, x, y);
-    }
-
-    return bounds;
-  }
-
-  function draw(context, scene, bounds) {
-    visit(scene, item => {
-      var opacity = item.opacity == null ? 1 : item.opacity,
-          p,
-          x,
-          y,
-          i,
-          lh,
-          tl,
-          str;
-      if (bounds && !bounds.intersects(item.bounds) || // bounds check
-      opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;
-      context.font = font(item);
-      context.textAlign = item.align || 'left';
-      p = anchorPoint(item);
-      x = p.x1, y = p.y1;
-
-      if (item.angle) {
-        context.save();
-        context.translate(x, y);
-        context.rotate(item.angle * DegToRad);
-        x = y = 0; // reset x, y
-      }
-
-      x += item.dx || 0;
-      y += (item.dy || 0) + offset(item);
-      tl = textLines(item);
-      blend(context, item);
-
-      if (vegaUtil.isArray(tl)) {
-        lh = lineHeight(item);
-
-        for (i = 0; i < tl.length; ++i) {
-          str = textValue(item, tl[i]);
-
-          if (item.fill && fill(context, item, opacity)) {
-            context.fillText(str, x, y);
-          }
-
-          if (item.stroke && stroke(context, item, opacity)) {
-            context.strokeText(str, x, y);
-          }
-
-          y += lh;
-        }
-      } else {
-        str = textValue(item, tl);
-
-        if (item.fill && fill(context, item, opacity)) {
-          context.fillText(str, x, y);
-        }
-
-        if (item.stroke && stroke(context, item, opacity)) {
-          context.strokeText(str, x, y);
-        }
-      }
-
-      if (item.angle) context.restore();
-    });
-  }
-
-  function hit(context, item, x, y, gx, gy) {
-    if (item.fontSize <= 0) return false;
-    if (!item.angle) return true; // bounds sufficient if no rotation
-    // project point into space of unrotated bounds
-
-    var p = anchorPoint(item),
-        ax = p.x1,
-        ay = p.y1,
-        b = bound(tempBounds, item, 1),
-        a = -item.angle * DegToRad,
-        cos = Math.cos(a),
-        sin = Math.sin(a),
-        px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),
-        py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);
-    return b.contains(px, py);
-  }
-
-  function intersectText(item, box) {
-    const p = bound(tempBounds, item, 2);
-    return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
-  }
-
-  var text = {
-    type: 'text',
-    tag: 'text',
-    nested: false,
-    attr: attr,
-    bound: bound,
-    draw: draw,
-    pick: pick$1(hit),
-    isect: intersectText
-  };
-
-  var trail = markMultiItemPath('trail', trail$1, pickTrail);
-
-  var Marks = {
-    arc: arc,
-    area: area,
-    group: group,
-    image: image,
-    line: line,
-    path: path$2,
-    rect: rect,
-    rule: rule,
-    shape: shape,
-    symbol: symbol,
-    text: text,
-    trail: trail
-  };
-
-  function boundItem (item, func, opt) {
-    var type = Marks[item.mark.marktype],
-        bound = func || type.bound;
-    if (type.nested) item = item.mark;
-    return bound(item.bounds || (item.bounds = new Bounds()), item, opt);
-  }
-
-  var DUMMY = {
-    mark: null
-  };
-  function boundMark (mark, bounds, opt) {
-    var type = Marks[mark.marktype],
-        bound = type.bound,
-        items = mark.items,
-        hasItems = items && items.length,
-        i,
-        n,
-        item,
-        b;
-
-    if (type.nested) {
-      if (hasItems) {
-        item = items[0];
-      } else {
-        // no items, fake it
-        DUMMY.mark = mark;
-        item = DUMMY;
-      }
-
-      b = boundItem(item, bound, opt);
-      bounds = bounds && bounds.union(b) || b;
-      return bounds;
-    }
-
-    bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();
-
-    if (hasItems) {
-      for (i = 0, n = items.length; i < n; ++i) {
-        bounds.union(boundItem(items[i], bound, opt));
-      }
-    }
-
-    return mark.bounds = bounds;
-  }
-
-  const keys = ['marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex', 'x', 'y', 'width', 'height', 'align', 'baseline', // layout
-  'fill', 'fillOpacity', 'opacity', 'blend', // fill
-  'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap', // stroke
-  'strokeDash', 'strokeDashOffset', // stroke dash
-  'strokeForeground', 'strokeOffset', // group
-  'startAngle', 'endAngle', 'innerRadius', 'outerRadius', // arc
-  'cornerRadius', 'padAngle', // arc, rect
-  'cornerRadiusTopLeft', 'cornerRadiusTopRight', // rect, group
-  'cornerRadiusBottomLeft', 'cornerRadiusBottomRight', 'interpolate', 'tension', 'orient', 'defined', // area, line
-  'url', 'aspect', 'smooth', // image
-  'path', 'scaleX', 'scaleY', // path
-  'x2', 'y2', // rule
-  'size', 'shape', // symbol
-  'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy', // text
-  'ellipsis', 'limit', 'lineBreak', 'lineHeight', 'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant', // font
-  'description', 'aria', 'ariaRole', 'ariaRoleDescription' // aria
-  ];
-  function sceneToJSON(scene, indent) {
-    return JSON.stringify(scene, keys, indent);
-  }
-  function sceneFromJSON(json) {
-    const scene = typeof json === 'string' ? JSON.parse(json) : json;
-    return initialize(scene);
-  }
-
-  function initialize(scene) {
-    var type = scene.marktype,
-        items = scene.items,
-        parent,
-        i,
-        n;
-
-    if (items) {
-      for (i = 0, n = items.length; i < n; ++i) {
-        parent = type ? 'mark' : 'group';
-        items[i][parent] = scene;
-        if (items[i].zindex) items[i][parent].zdirty = true;
-        if ('group' === (type || parent)) initialize(items[i]);
-      }
-    }
-
-    if (type) boundMark(scene);
-    return scene;
-  }
-
-  function Scenegraph(scene) {
-    if (arguments.length) {
-      this.root = sceneFromJSON(scene);
-    } else {
-      this.root = createMark({
-        marktype: 'group',
-        name: 'root',
-        role: 'frame'
-      });
-      this.root.items = [new GroupItem(this.root)];
-    }
-  }
-  Scenegraph.prototype = {
-    toJSON(indent) {
-      return sceneToJSON(this.root, indent || 0);
-    },
-
-    mark(markdef, group, index) {
-      group = group || this.root.items[0];
-      const mark = createMark(markdef, group);
-      group.items[index] = mark;
-      if (mark.zindex) mark.group.zdirty = true;
-      return mark;
-    }
-
-  };
-
-  function createMark(def, group) {
-    const mark = {
-      bounds: new Bounds(),
-      clip: !!def.clip,
-      group: group,
-      interactive: def.interactive === false ? false : true,
-      items: [],
-      marktype: def.marktype,
-      name: def.name || undefined,
-      role: def.role || undefined,
-      zindex: def.zindex || 0
-    }; // add accessibility properties if defined
-
-    if (def.aria != null) {
-      mark.aria = def.aria;
-    }
-
-    if (def.description) {
-      mark.description = def.description;
-    }
-
-    return mark;
-  }
-
-  // create a new DOM element
-  function domCreate(doc, tag, ns) {
-    if (!doc && typeof document !== 'undefined' && document.createElement) {
-      doc = document;
-    }
-
-    return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
-  } // find first child element with matching tag
-
-  function domFind(el, tag) {
-    tag = tag.toLowerCase();
-    var nodes = el.childNodes,
-        i = 0,
-        n = nodes.length;
-
-    for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {
-      return nodes[i];
-    }
-  } // retrieve child element at given index
-  // create & insert if doesn't exist or if tags do not match
-
-  function domChild(el, index, tag, ns) {
-    var a = el.childNodes[index],
-        b;
-
-    if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {
-      b = a || null;
-      a = domCreate(el.ownerDocument, tag, ns);
-      el.insertBefore(a, b);
-    }
-
-    return a;
-  } // remove all child elements at or above the given index
-
-  function domClear(el, index) {
-    var nodes = el.childNodes,
-        curr = nodes.length;
-
-    while (curr > index) el.removeChild(nodes[--curr]);
-
-    return el;
-  } // generate css class name for mark
-
-  function cssClass(mark) {
-    return 'mark-' + mark.marktype + (mark.role ? ' role-' + mark.role : '') + (mark.name ? ' ' + mark.name : '');
-  }
-
-  function point (event, el) {
-    const rect = el.getBoundingClientRect();
-    return [event.clientX - rect.left - (el.clientLeft || 0), event.clientY - rect.top - (el.clientTop || 0)];
-  }
-
-  function resolveItem (item, event, el, origin) {
-    var mark = item && item.mark,
-        mdef,
-        p;
-
-    if (mark && (mdef = Marks[mark.marktype]).tip) {
-      p = point(event, el);
-      p[0] -= origin[0];
-      p[1] -= origin[1];
-
-      while (item = item.mark.group) {
-        p[0] -= item.x || 0;
-        p[1] -= item.y || 0;
-      }
-
-      item = mdef.tip(mark.items, p);
-    }
-
-    return item;
-  }
-
-  /**
-   * Create a new Handler instance.
-   * @param {object} [customLoader] - Optional loader instance for
-   *   href URL sanitization. If not specified, a standard loader
-   *   instance will be generated.
-   * @param {function} [customTooltip] - Optional tooltip handler
-   *   function for custom tooltip display.
-   * @constructor
-   */
-
-  function Handler(customLoader, customTooltip) {
-    this._active = null;
-    this._handlers = {};
-    this._loader = customLoader || vegaLoader.loader();
-    this._tooltip = customTooltip || defaultTooltip;
-  } // The default tooltip display handler.
-  // Sets the HTML title attribute on the visualization container.
-
-  function defaultTooltip(handler, event, item, value) {
-    handler.element().setAttribute('title', value || '');
-  }
-
-  Handler.prototype = {
-    /**
-     * Initialize a new Handler instance.
-     * @param {DOMElement} el - The containing DOM element for the display.
-     * @param {Array<number>} origin - The origin of the display, in pixels.
-     *   The coordinate system will be translated to this point.
-     * @param {object} [obj] - Optional context object that should serve as
-     *   the "this" context for event callbacks.
-     * @return {Handler} - This handler instance.
-     */
-    initialize(el, origin, obj) {
-      this._el = el;
-      this._obj = obj || null;
-      return this.origin(origin);
-    },
-
-    /**
-     * Returns the parent container element for a visualization.
-     * @return {DOMElement} - The containing DOM element.
-     */
-    element() {
-      return this._el;
-    },
-
-    /**
-     * Returns the scene element (e.g., canvas or SVG) of the visualization
-     * Subclasses must override if the first child is not the scene element.
-     * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
-     */
-    canvas() {
-      return this._el && this._el.firstChild;
-    },
-
-    /**
-     * Get / set the origin coordinates of the visualization.
-     */
-    origin(origin) {
-      if (arguments.length) {
-        this._origin = origin || [0, 0];
-        return this;
-      } else {
-        return this._origin.slice();
-      }
-    },
-
-    /**
-     * Get / set the scenegraph root.
-     */
-    scene(scene) {
-      if (!arguments.length) return this._scene;
-      this._scene = scene;
-      return this;
-    },
-
-    /**
-     * Add an event handler. Subclasses should override this method.
-     */
-    on()
-    /*type, handler*/
-    {},
-
-    /**
-     * Remove an event handler. Subclasses should override this method.
-     */
-    off()
-    /*type, handler*/
-    {},
-
-    /**
-     * Utility method for finding the array index of an event handler.
-     * @param {Array} h - An array of registered event handlers.
-     * @param {string} type - The event type.
-     * @param {function} handler - The event handler instance to find.
-     * @return {number} - The handler's array index or -1 if not registered.
-     */
-    _handlerIndex(h, type, handler) {
-      for (let i = h ? h.length : 0; --i >= 0;) {
-        if (h[i].type === type && (!handler || h[i].handler === handler)) {
-          return i;
-        }
-      }
-
-      return -1;
-    },
-
-    /**
-     * Returns an array with registered event handlers.
-     * @param {string} [type] - The event type to query. Any annotations
-     *   are ignored; for example, for the argument "click.foo", ".foo" will
-     *   be ignored and the method returns all "click" handlers. If type is
-     *   null or unspecified, this method returns handlers for all types.
-     * @return {Array} - A new array containing all registered event handlers.
-     */
-    handlers(type) {
-      const h = this._handlers,
-            a = [];
-
-      if (type) {
-        a.push(...h[this.eventName(type)]);
-      } else {
-        for (const k in h) {
-          a.push(...h[k]);
-        }
-      }
-
-      return a;
-    },
-
-    /**
-     * Parses an event name string to return the specific event type.
-     * For example, given "click.foo" returns "click"
-     * @param {string} name - The input event type string.
-     * @return {string} - A string with the event type only.
-     */
-    eventName(name) {
-      const i = name.indexOf('.');
-      return i < 0 ? name : name.slice(0, i);
-    },
-
-    /**
-     * Handle hyperlink navigation in response to an item.href value.
-     * @param {Event} event - The event triggering hyperlink navigation.
-     * @param {Item} item - The scenegraph item.
-     * @param {string} href - The URL to navigate to.
-     */
-    handleHref(event, item, href) {
-      this._loader.sanitize(href, {
-        context: 'href'
-      }).then(opt => {
-        const e = new MouseEvent(event.type, event),
-              a = domCreate(null, 'a');
-
-        for (const name in opt) a.setAttribute(name, opt[name]);
-
-        a.dispatchEvent(e);
-      }).catch(() => {
-        /* do nothing */
-      });
-    },
-
-    /**
-     * Handle tooltip display in response to an item.tooltip value.
-     * @param {Event} event - The event triggering tooltip display.
-     * @param {Item} item - The scenegraph item.
-     * @param {boolean} show - A boolean flag indicating whether
-     *   to show or hide a tooltip for the given item.
-     */
-    handleTooltip(event, item, show) {
-      if (item && item.tooltip != null) {
-        item = resolveItem(item, event, this.canvas(), this._origin);
-        const value = show && item && item.tooltip || null;
-
-        this._tooltip.call(this._obj, this, event, item, value);
-      }
-    },
-
-    /**
-     * Returns the size of a scenegraph item and its position relative
-     * to the viewport.
-     * @param {Item} item - The scenegraph item.
-     * @return {object} - A bounding box object (compatible with the
-     *   DOMRect type) consisting of x, y, width, heigh, top, left,
-     *   right, and bottom properties.
-     */
-    getItemBoundingClientRect(item) {
-      const el = this.canvas();
-      if (!el) return;
-      const rect = el.getBoundingClientRect(),
-            origin = this._origin,
-            bounds = item.bounds,
-            width = bounds.width(),
-            height = bounds.height();
-      let x = bounds.x1 + origin[0] + rect.left,
-          y = bounds.y1 + origin[1] + rect.top; // translate coordinate for each parent group
-
-      while (item.mark && (item = item.mark.group)) {
-        x += item.x || 0;
-        y += item.y || 0;
-      } // return DOMRect-compatible bounding box
-
-
-      return {
-        x,
-        y,
-        width,
-        height,
-        left: x,
-        top: y,
-        right: x + width,
-        bottom: y + height
-      };
-    }
-
-  };
-
-  /**
-   * Create a new Renderer instance.
-   * @param {object} [loader] - Optional loader instance for
-   *   image and href URL sanitization. If not specified, a
-   *   standard loader instance will be generated.
-   * @constructor
-   */
-
-  function Renderer(loader) {
-    this._el = null;
-    this._bgcolor = null;
-    this._loader = new ResourceLoader(loader);
-  }
-  Renderer.prototype = {
-    /**
-     * Initialize a new Renderer instance.
-     * @param {DOMElement} el - The containing DOM element for the display.
-     * @param {number} width - The coordinate width of the display, in pixels.
-     * @param {number} height - The coordinate height of the display, in pixels.
-     * @param {Array<number>} origin - The origin of the display, in pixels.
-     *   The coordinate system will be translated to this point.
-     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
-     *   the width and height to determine the final pixel size.
-     * @return {Renderer} - This renderer instance.
-     */
-    initialize(el, width, height, origin, scaleFactor) {
-      this._el = el;
-      return this.resize(width, height, origin, scaleFactor);
-    },
-
-    /**
-     * Returns the parent container element for a visualization.
-     * @return {DOMElement} - The containing DOM element.
-     */
-    element() {
-      return this._el;
-    },
-
-    /**
-     * Returns the scene element (e.g., canvas or SVG) of the visualization
-     * Subclasses must override if the first child is not the scene element.
-     * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
-     */
-    canvas() {
-      return this._el && this._el.firstChild;
-    },
-
-    /**
-     * Get / set the background color.
-     */
-    background(bgcolor) {
-      if (arguments.length === 0) return this._bgcolor;
-      this._bgcolor = bgcolor;
-      return this;
-    },
-
-    /**
-     * Resize the display.
-     * @param {number} width - The new coordinate width of the display, in pixels.
-     * @param {number} height - The new coordinate height of the display, in pixels.
-     * @param {Array<number>} origin - The new origin of the display, in pixels.
-     *   The coordinate system will be translated to this point.
-     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
-     *   the width and height to determine the final pixel size.
-     * @return {Renderer} - This renderer instance;
-     */
-    resize(width, height, origin, scaleFactor) {
-      this._width = width;
-      this._height = height;
-      this._origin = origin || [0, 0];
-      this._scale = scaleFactor || 1;
-      return this;
-    },
-
-    /**
-     * Report a dirty item whose bounds should be redrawn.
-     * This base class method does nothing. Subclasses that perform
-     * incremental should implement this method.
-     * @param {Item} item - The dirty item whose bounds should be redrawn.
-     */
-    dirty()
-    /*item*/
-    {},
-
-    /**
-     * Render an input scenegraph, potentially with a set of dirty items.
-     * This method will perform an immediate rendering with available resources.
-     * The renderer may also need to perform image loading to perform a complete
-     * render. This process can lead to asynchronous re-rendering of the scene
-     * after this method returns. To receive notification when rendering is
-     * complete, use the renderAsync method instead.
-     * @param {object} scene - The root mark of a scenegraph to render.
-     * @return {Renderer} - This renderer instance.
-     */
-    render(scene) {
-      const r = this; // bind arguments into a render call, and cache it
-      // this function may be subsequently called for async redraw
-
-      r._call = function () {
-        r._render(scene);
-      }; // invoke the renderer
-
-
-      r._call(); // clear the cached call for garbage collection
-      // async redraws will stash their own copy
-
-
-      r._call = null;
-      return r;
-    },
-
-    /**
-     * Internal rendering method. Renderer subclasses should override this
-     * method to actually perform rendering.
-     * @param {object} scene - The root mark of a scenegraph to render.
-     */
-    _render()
-    /*scene*/
-    {// subclasses to override
-    },
-
-    /**
-     * Asynchronous rendering method. Similar to render, but returns a Promise
-     * that resolves when all rendering is completed. Sometimes a renderer must
-     * perform image loading to get a complete rendering. The returned
-     * Promise will not resolve until this process completes.
-     * @param {object} scene - The root mark of a scenegraph to render.
-     * @return {Promise} - A Promise that resolves when rendering is complete.
-     */
-    renderAsync(scene) {
-      const r = this.render(scene);
-      return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
-    },
-
-    /**
-     * Internal method for asynchronous resource loading.
-     * Proxies method calls to the ImageLoader, and tracks loading
-     * progress to invoke a re-render once complete.
-     * @param {string} method - The method name to invoke on the ImageLoader.
-     * @param {string} uri - The URI for the requested resource.
-     * @return {Promise} - A Promise that resolves to the requested resource.
-     */
-    _load(method, uri) {
-      var r = this,
-          p = r._loader[method](uri);
-
-      if (!r._ready) {
-        // re-render the scene when loading completes
-        const call = r._call;
-        r._ready = r._loader.ready().then(redraw => {
-          if (redraw) call();
-          r._ready = null;
-        });
-      }
-
-      return p;
-    },
-
-    /**
-     * Sanitize a URL to include as a hyperlink in the rendered scene.
-     * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
-     * image loading progress and invokes a re-render once complete.
-     * @param {string} uri - The URI string to sanitize.
-     * @return {Promise} - A Promise that resolves to the sanitized URL.
-     */
-    sanitizeURL(uri) {
-      return this._load('sanitizeURL', uri);
-    },
-
-    /**
-     * Requests an image to include in the rendered scene.
-     * This method proxies a call to ImageLoader.loadImage, but also tracks
-     * image loading progress and invokes a re-render once complete.
-     * @param {string} uri - The URI string of the image.
-     * @return {Promise} - A Promise that resolves to the loaded Image.
-     */
-    loadImage(uri) {
-      return this._load('loadImage', uri);
-    }
-
-  };
-
-  const KeyDownEvent = 'keydown';
-  const KeyPressEvent = 'keypress';
-  const KeyUpEvent = 'keyup';
-  const DragEnterEvent = 'dragenter';
-  const DragLeaveEvent = 'dragleave';
-  const DragOverEvent = 'dragover';
-  const MouseDownEvent = 'mousedown';
-  const MouseUpEvent = 'mouseup';
-  const MouseMoveEvent = 'mousemove';
-  const MouseOutEvent = 'mouseout';
-  const MouseOverEvent = 'mouseover';
-  const ClickEvent = 'click';
-  const DoubleClickEvent = 'dblclick';
-  const WheelEvent = 'wheel';
-  const MouseWheelEvent = 'mousewheel';
-  const TouchStartEvent = 'touchstart';
-  const TouchMoveEvent = 'touchmove';
-  const TouchEndEvent = 'touchend';
-  const Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
-  const TooltipShowEvent = MouseMoveEvent;
-  const TooltipHideEvent = MouseOutEvent;
-  const HrefEvent = ClickEvent;
-
-  function CanvasHandler(loader, tooltip) {
-    Handler.call(this, loader, tooltip);
-    this._down = null;
-    this._touch = null;
-    this._first = true;
-    this._events = {};
-  }
-
-  const eventBundle = type => type === TouchStartEvent || type === TouchMoveEvent || type === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type]; // lazily add listeners to the canvas as needed
-
-
-  function eventListenerCheck(handler, type) {
-    eventBundle(type).forEach(_ => addEventListener(handler, _));
-  }
-
-  function addEventListener(handler, type) {
-    const canvas = handler.canvas();
-
-    if (canvas && !handler._events[type]) {
-      handler._events[type] = 1;
-      canvas.addEventListener(type, handler[type] ? evt => handler[type](evt) : evt => handler.fire(type, evt));
-    }
-  }
-
-  function move(moveEvent, overEvent, outEvent) {
-    return function (evt) {
-      const a = this._active,
-            p = this.pickEvent(evt);
-
-      if (p === a) {
-        // active item and picked item are the same
-        this.fire(moveEvent, evt); // fire move
-      } else {
-        // active item and picked item are different
-        if (!a || !a.exit) {
-          // fire out for prior active item
-          // suppress if active item was removed from scene
-          this.fire(outEvent, evt);
-        }
-
-        this._active = p; // set new active item
-
-        this.fire(overEvent, evt); // fire over for new active item
-
-        this.fire(moveEvent, evt); // fire move for new active item
-      }
-    };
-  }
-
-  function inactive(type) {
-    return function (evt) {
-      this.fire(type, evt);
-      this._active = null;
-    };
-  }
-
-  vegaUtil.inherits(CanvasHandler, Handler, {
-    initialize(el, origin, obj) {
-      this._canvas = el && domFind(el, 'canvas'); // add minimal events required for proper state management
-
-      [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach(type => eventListenerCheck(this, type));
-      return Handler.prototype.initialize.call(this, el, origin, obj);
-    },
-
-    // return the backing canvas instance
-    canvas() {
-      return this._canvas;
-    },
-
-    // retrieve the current canvas context
-    context() {
-      return this._canvas.getContext('2d');
-    },
-
-    // supported events
-    events: Events,
-
-    // to keep old versions of firefox happy
-    DOMMouseScroll(evt) {
-      this.fire(MouseWheelEvent, evt);
-    },
-
-    mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),
-    dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),
-    mouseout: inactive(MouseOutEvent),
-    dragleave: inactive(DragLeaveEvent),
-
-    mousedown(evt) {
-      this._down = this._active;
-      this.fire(MouseDownEvent, evt);
-    },
-
-    click(evt) {
-      if (this._down === this._active) {
-        this.fire(ClickEvent, evt);
-        this._down = null;
-      }
-    },
-
-    touchstart(evt) {
-      this._touch = this.pickEvent(evt.changedTouches[0]);
-
-      if (this._first) {
-        this._active = this._touch;
-        this._first = false;
-      }
-
-      this.fire(TouchStartEvent, evt, true);
-    },
-
-    touchmove(evt) {
-      this.fire(TouchMoveEvent, evt, true);
-    },
-
-    touchend(evt) {
-      this.fire(TouchEndEvent, evt, true);
-      this._touch = null;
-    },
-
-    // fire an event
-    fire(type, evt, touch) {
-      const a = touch ? this._touch : this._active,
-            h = this._handlers[type]; // set event type relative to scenegraph items
-
-      evt.vegaType = type; // handle hyperlinks and tooltips first
-
-      if (type === HrefEvent && a && a.href) {
-        this.handleHref(evt, a, a.href);
-      } else if (type === TooltipShowEvent || type === TooltipHideEvent) {
-        this.handleTooltip(evt, a, type !== TooltipHideEvent);
-      } // invoke all registered handlers
-
-
-      if (h) {
-        for (let i = 0, len = h.length; i < len; ++i) {
-          h[i].handler.call(this._obj, evt, a);
-        }
-      }
-    },
-
-    // add an event handler
-    on(type, handler) {
-      const name = this.eventName(type),
-            h = this._handlers,
-            i = this._handlerIndex(h[name], type, handler);
-
-      if (i < 0) {
-        eventListenerCheck(this, type);
-        (h[name] || (h[name] = [])).push({
-          type: type,
-          handler: handler
-        });
-      }
-
-      return this;
-    },
-
-    // remove an event handler
-    off(type, handler) {
-      const name = this.eventName(type),
-            h = this._handlers[name],
-            i = this._handlerIndex(h, type, handler);
-
-      if (i >= 0) {
-        h.splice(i, 1);
-      }
-
-      return this;
-    },
-
-    pickEvent(evt) {
-      const p = point(evt, this._canvas),
-            o = this._origin;
-      return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
-    },
-
-    // find the scenegraph item at the current mouse position
-    // x, y -- the absolute x, y mouse coordinates on the canvas element
-    // gx, gy -- the relative coordinates within the current group
-    pick(scene, x, y, gx, gy) {
-      const g = this.context(),
-            mark = Marks[scene.marktype];
-      return mark.pick.call(this, g, scene, x, y, gx, gy);
-    }
-
-  });
-
-  function devicePixelRatio() {
-    return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;
-  }
-
-  var pixelRatio = devicePixelRatio();
-  function resize (canvas, width, height, origin, scaleFactor, opt) {
-    const inDOM = typeof HTMLElement !== 'undefined' && canvas instanceof HTMLElement && canvas.parentNode != null,
-          context = canvas.getContext('2d'),
-          ratio = inDOM ? pixelRatio : scaleFactor;
-    canvas.width = width * ratio;
-    canvas.height = height * ratio;
-
-    for (const key in opt) {
-      context[key] = opt[key];
-    }
-
-    if (inDOM && ratio !== 1) {
-      canvas.style.width = width + 'px';
-      canvas.style.height = height + 'px';
-    }
-
-    context.pixelRatio = ratio;
-    context.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
-    return canvas;
-  }
-
-  function CanvasRenderer(loader) {
-    Renderer.call(this, loader);
-    this._options = {};
-    this._redraw = false;
-    this._dirty = new Bounds();
-    this._tempb = new Bounds();
-  }
-  const base$1 = Renderer.prototype;
-
-  const viewBounds = (origin, width, height) => new Bounds().set(0, 0, width, height).translate(-origin[0], -origin[1]);
-
-  function clipToBounds(g, b, origin) {
-    // expand bounds by 1 pixel, then round to pixel boundaries
-    b.expand(1).round(); // align to base pixel grid in case of non-integer scaling (#2425)
-
-    if (g.pixelRatio % 1) {
-      b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
-    } // to avoid artifacts translate if origin has fractional pixels
-
-
-    b.translate(-(origin[0] % 1), -(origin[1] % 1)); // set clip path
-
-    g.beginPath();
-    g.rect(b.x1, b.y1, b.width(), b.height());
-    g.clip();
-    return b;
-  }
-
-  vegaUtil.inherits(CanvasRenderer, Renderer, {
-    initialize(el, width, height, origin, scaleFactor, options) {
-      this._options = options || {};
-      this._canvas = this._options.externalContext ? null : vegaCanvas.canvas(1, 1, this._options.type); // instantiate a small canvas
-
-      if (el && this._canvas) {
-        domClear(el, 0).appendChild(this._canvas);
-
-        this._canvas.setAttribute('class', 'marks');
-      } // this method will invoke resize to size the canvas appropriately
-
-
-      return base$1.initialize.call(this, el, width, height, origin, scaleFactor);
-    },
-
-    resize(width, height, origin, scaleFactor) {
-      base$1.resize.call(this, width, height, origin, scaleFactor);
-
-      if (this._canvas) {
-        // configure canvas size and transform
-        resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
-      } else {
-        // external context needs to be scaled and positioned to origin
-        const ctx = this._options.externalContext;
-        if (!ctx) vegaUtil.error('CanvasRenderer is missing a valid canvas or context');
-        ctx.scale(this._scale, this._scale);
-        ctx.translate(this._origin[0], this._origin[1]);
-      }
-
-      this._redraw = true;
-      return this;
-    },
-
-    canvas() {
-      return this._canvas;
-    },
-
-    context() {
-      return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);
-    },
-
-    dirty(item) {
-      const b = this._tempb.clear().union(item.bounds);
-
-      let g = item.mark.group;
-
-      while (g) {
-        b.translate(g.x || 0, g.y || 0);
-        g = g.mark.group;
-      }
-
-      this._dirty.union(b);
-    },
-
-    _render(scene) {
-      const g = this.context(),
-            o = this._origin,
-            w = this._width,
-            h = this._height,
-            db = this._dirty,
-            vb = viewBounds(o, w, h); // setup
-
-      g.save();
-      const b = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
-      this.clear(-o[0], -o[1], w, h); // render
-
-      this.draw(g, scene, b); // takedown
-
-      g.restore();
-      db.clear();
-      return this;
-    },
-
-    draw(ctx, scene, bounds) {
-      const mark = Marks[scene.marktype];
-      if (scene.clip) clip(ctx, scene);
-      mark.draw.call(this, ctx, scene, bounds);
-      if (scene.clip) ctx.restore();
-    },
-
-    clear(x, y, w, h) {
-      const opt = this._options,
-            g = this.context();
-
-      if (opt.type !== 'pdf' && !opt.externalContext) {
-        // calling clear rect voids vector output in pdf mode
-        // and could remove external context content (#2615)
-        g.clearRect(x, y, w, h);
-      }
-
-      if (this._bgcolor != null) {
-        g.fillStyle = this._bgcolor;
-        g.fillRect(x, y, w, h);
-      }
-    }
-
-  });
-
-  function SVGHandler(loader, tooltip) {
-    Handler.call(this, loader, tooltip);
-    const h = this;
-    h._hrefHandler = listener(h, (evt, item) => {
-      if (item && item.href) h.handleHref(evt, item, item.href);
-    });
-    h._tooltipHandler = listener(h, (evt, item) => {
-      h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
-    });
-  } // wrap an event listener for the SVG DOM
-
-  const listener = (context, handler) => evt => {
-    let item = evt.target.__data__;
-    item = Array.isArray(item) ? item[0] : item;
-    evt.vegaType = evt.type;
-    handler.call(context._obj, evt, item);
-  };
-
-  vegaUtil.inherits(SVGHandler, Handler, {
-    initialize(el, origin, obj) {
-      let svg = this._svg;
-
-      if (svg) {
-        svg.removeEventListener(HrefEvent, this._hrefHandler);
-        svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
-        svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
-      }
-
-      this._svg = svg = el && domFind(el, 'svg');
-
-      if (svg) {
-        svg.addEventListener(HrefEvent, this._hrefHandler);
-        svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
-        svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
-      }
-
-      return Handler.prototype.initialize.call(this, el, origin, obj);
-    },
-
-    canvas() {
-      return this._svg;
-    },
-
-    // add an event handler
-    on(type, handler) {
-      const name = this.eventName(type),
-            h = this._handlers,
-            i = this._handlerIndex(h[name], type, handler);
-
-      if (i < 0) {
-        const x = {
-          type,
-          handler,
-          listener: listener(this, handler)
-        };
-        (h[name] || (h[name] = [])).push(x);
-
-        if (this._svg) {
-          this._svg.addEventListener(name, x.listener);
-        }
-      }
-
-      return this;
-    },
-
-    // remove an event handler
-    off(type, handler) {
-      const name = this.eventName(type),
-            h = this._handlers[name],
-            i = this._handlerIndex(h, type, handler);
-
-      if (i >= 0) {
-        if (this._svg) {
-          this._svg.removeEventListener(name, h[i].listener);
-        }
-
-        h.splice(i, 1);
-      }
-
-      return this;
-    }
-
-  });
-
-  const ARIA_HIDDEN = 'aria-hidden';
-  const ARIA_LABEL = 'aria-label';
-  const ARIA_ROLE = 'role';
-  const ARIA_ROLEDESCRIPTION = 'aria-roledescription';
-  const GRAPHICS_OBJECT = 'graphics-object';
-  const GRAPHICS_SYMBOL = 'graphics-symbol';
-
-  const bundle = (role, roledesc, label) => ({
-    [ARIA_ROLE]: role,
-    [ARIA_ROLEDESCRIPTION]: roledesc,
-    [ARIA_LABEL]: label || undefined
-  }); // these roles are covered by related roles
-  // we can ignore them, no need to generate attributes
-
-
-  const AriaIgnore = vegaUtil.toSet(['axis-domain', 'axis-grid', 'axis-label', 'axis-tick', 'axis-title', 'legend-band', 'legend-entry', 'legend-gradient', 'legend-label', 'legend-title', 'legend-symbol', 'title']); // aria attribute generators for guide roles
-
-  const AriaGuides = {
-    'axis': {
-      desc: 'axis',
-      caption: axisCaption
-    },
-    'legend': {
-      desc: 'legend',
-      caption: legendCaption
-    },
-    'title-text': {
-      desc: 'title',
-      caption: item => `Title text '${titleCaption(item)}'`
-    },
-    'title-subtitle': {
-      desc: 'subtitle',
-      caption: item => `Subtitle text '${titleCaption(item)}'`
-    }
-  }; // aria properties generated for mark item encoding channels
-
-  const AriaEncode = {
-    ariaRole: ARIA_ROLE,
-    ariaRoleDescription: ARIA_ROLEDESCRIPTION,
-    description: ARIA_LABEL
-  };
-  function ariaItemAttributes(emit, item) {
-    const hide = item.aria === false;
-    emit(ARIA_HIDDEN, hide || undefined);
-
-    if (hide || item.description == null) {
-      for (const prop in AriaEncode) {
-        emit(AriaEncode[prop], undefined);
-      }
-    } else {
-      const type = item.mark.marktype;
-      emit(ARIA_LABEL, item.description);
-      emit(ARIA_ROLE, item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
-      emit(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type} mark`);
-    }
-  }
-  function ariaMarkAttributes(mark) {
-    return mark.aria === false ? {
-      [ARIA_HIDDEN]: true
-    } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);
-  }
-
-  function ariaMark(mark) {
-    const type = mark.marktype;
-    const recurse = type === 'group' || type === 'text' || mark.items.some(_ => _.description != null && _.aria !== false);
-    return bundle(recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type} mark container`, mark.description);
-  }
-
-  function ariaGuide(mark, opt) {
-    try {
-      const item = mark.items[0],
-            caption = opt.caption || (() => '');
-
-      return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
-    } catch (err) {
-      return null;
-    }
-  }
-
-  function titleCaption(item) {
-    return vegaUtil.array(item.text).join(' ');
-  }
-
-  function axisCaption(item) {
-    const datum = item.datum,
-          orient = item.orient,
-          title = datum.title ? extractTitle(item) : null,
-          ctx = item.context,
-          scale = ctx.scales[datum.scale].value,
-          locale = ctx.dataflow.locale(),
-          type = scale.type,
-          xy = orient === 'left' || orient === 'right' ? 'Y' : 'X';
-    return `${xy}-axis` + (title ? ` titled '${title}'` : '') + ` for a ${vegaScale.isDiscrete(type) ? 'discrete' : type} scale` + ` with ${vegaScale.domainCaption(locale, scale, item)}`;
-  }
-
-  function legendCaption(item) {
-    const datum = item.datum,
-          title = datum.title ? extractTitle(item) : null,
-          type = `${datum.type || ''} legend`.trim(),
-          scales = datum.scales,
-          props = Object.keys(scales),
-          ctx = item.context,
-          scale = ctx.scales[scales[props[0]]].value,
-          locale = ctx.dataflow.locale();
-    return capitalize(type) + (title ? ` titled '${title}'` : '') + ` for ${channelCaption(props)}` + ` with ${vegaScale.domainCaption(locale, scale, item)}`;
-  }
-
-  function extractTitle(item) {
-    try {
-      return vegaUtil.array(vegaUtil.peek(item.items).items[0].text).join(' ');
-    } catch (err) {
-      return null;
-    }
-  }
-
-  function channelCaption(props) {
-    props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));
-    return props.length < 2 ? props[0] : props.slice(0, -1).join(', ') + ' and ' + vegaUtil.peek(props);
-  }
-
-  function capitalize(s) {
-    return s.length ? s[0].toUpperCase() + s.slice(1) : s;
-  }
-
-  const innerText = val => (val + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
-
-  const attrText = val => innerText(val).replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
-
-  function markup() {
-    let buf = '',
-        outer = '',
-        inner = '';
-
-    const stack = [],
-          clear = () => outer = inner = '',
-          push = tag => {
-      if (outer) {
-        buf += `${outer}>${inner}`;
-        clear();
-      }
-
-      stack.push(tag);
-    },
-          attr = (name, value) => {
-      if (value != null) outer += ` ${name}="${attrText(value)}"`;
-      return m;
-    },
-          m = {
-      open(tag, ...attrs) {
-        push(tag);
-        outer = '<' + tag;
-
-        for (const set of attrs) {
-          for (const key in set) attr(key, set[key]);
-        }
-
-        return m;
-      },
-
-      close() {
-        const tag = stack.pop();
-
-        if (outer) {
-          buf += outer + (inner ? `>${inner}</${tag}>` : '/>');
-        } else {
-          buf += `</${tag}>`;
-        }
-
-        clear();
-        return m;
-      },
-
-      attr,
-      text: t => (inner += innerText(t), m),
-      toString: () => buf
-    };
-
-    return m;
-  }
-  const serializeXML = node => _serialize(markup(), node) + '';
-
-  function _serialize(m, node) {
-    m.open(node.tagName);
-
-    if (node.hasAttributes()) {
-      const attrs = node.attributes,
-            n = attrs.length;
-
-      for (let i = 0; i < n; ++i) {
-        m.attr(attrs[i].name, attrs[i].value);
-      }
-    }
-
-    if (node.hasChildNodes()) {
-      const children = node.childNodes,
-            n = children.length;
-
-      for (let i = 0; i < n; i++) {
-        const child = children[i];
-        child.nodeType === 3 // text node
-        ? m.text(child.nodeValue) : _serialize(m, child);
-      }
-    }
-
-    return m.close();
-  }
-
-  const styles = {
-    fill: 'fill',
-    fillOpacity: 'fill-opacity',
-    stroke: 'stroke',
-    strokeOpacity: 'stroke-opacity',
-    strokeWidth: 'stroke-width',
-    strokeCap: 'stroke-linecap',
-    strokeJoin: 'stroke-linejoin',
-    strokeDash: 'stroke-dasharray',
-    strokeDashOffset: 'stroke-dashoffset',
-    strokeMiterLimit: 'stroke-miterlimit',
-    opacity: 'opacity',
-    blend: 'mix-blend-mode'
-  }; // ensure miter limit default is consistent with canvas (#2498)
-
-  const rootAttributes = {
-    'fill': 'none',
-    'stroke-miterlimit': 10
-  };
-
-  const RootIndex = 0,
-        xmlns = 'http://www.w3.org/2000/xmlns/',
-        svgns = metadata.xmlns;
-  function SVGRenderer(loader) {
-    Renderer.call(this, loader);
-    this._dirtyID = 0;
-    this._dirty = [];
-    this._svg = null;
-    this._root = null;
-    this._defs = null;
-  }
-  const base = Renderer.prototype;
-  vegaUtil.inherits(SVGRenderer, Renderer, {
-    /**
-     * Initialize a new SVGRenderer instance.
-     * @param {DOMElement} el - The containing DOM element for the display.
-     * @param {number} width - The coordinate width of the display, in pixels.
-     * @param {number} height - The coordinate height of the display, in pixels.
-     * @param {Array<number>} origin - The origin of the display, in pixels.
-     *   The coordinate system will be translated to this point.
-     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
-     *   the width and height to determine the final pixel size.
-     * @return {SVGRenderer} - This renderer instance.
-     */
-    initialize(el, width, height, origin, scaleFactor) {
-      // create the svg definitions cache
-      this._defs = {};
-
-      this._clearDefs();
-
-      if (el) {
-        this._svg = domChild(el, 0, 'svg', svgns);
-
-        this._svg.setAttributeNS(xmlns, 'xmlns', svgns);
-
-        this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);
-
-        this._svg.setAttribute('version', metadata['version']);
-
-        this._svg.setAttribute('class', 'marks');
-
-        domClear(el, 1); // set the svg root group
-
-        this._root = domChild(this._svg, RootIndex, 'g', svgns);
-        setAttributes(this._root, rootAttributes); // ensure no additional child elements
-
-        domClear(this._svg, RootIndex + 1);
-      } // set background color if defined
-
-
-      this.background(this._bgcolor);
-      return base.initialize.call(this, el, width, height, origin, scaleFactor);
-    },
-
-    /**
-     * Get / set the background color.
-     */
-    background(bgcolor) {
-      if (arguments.length && this._svg) {
-        this._svg.style.setProperty('background-color', bgcolor);
-      }
-
-      return base.background.apply(this, arguments);
-    },
-
-    /**
-     * Resize the display.
-     * @param {number} width - The new coordinate width of the display, in pixels.
-     * @param {number} height - The new coordinate height of the display, in pixels.
-     * @param {Array<number>} origin - The new origin of the display, in pixels.
-     *   The coordinate system will be translated to this point.
-     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
-     *   the width and height to determine the final pixel size.
-     * @return {SVGRenderer} - This renderer instance;
-     */
-    resize(width, height, origin, scaleFactor) {
-      base.resize.call(this, width, height, origin, scaleFactor);
-
-      if (this._svg) {
-        setAttributes(this._svg, {
-          width: this._width * this._scale,
-          height: this._height * this._scale,
-          viewBox: `0 0 ${this._width} ${this._height}`
-        });
-
-        this._root.setAttribute('transform', `translate(${this._origin})`);
-      }
-
-      this._dirty = [];
-      return this;
-    },
-
-    /**
-     * Returns the SVG element of the visualization.
-     * @return {DOMElement} - The SVG element.
-     */
-    canvas() {
-      return this._svg;
-    },
-
-    /**
-     * Returns an SVG text string for the rendered content,
-     * or null if this renderer is currently headless.
-     */
-    svg() {
-      const svg = this._svg,
-            bg = this._bgcolor;
-      if (!svg) return null;
-      let node;
-
-      if (bg) {
-        svg.removeAttribute('style');
-        node = domChild(svg, RootIndex, 'rect', svgns);
-        setAttributes(node, {
-          width: this._width,
-          height: this._height,
-          fill: bg
-        });
-      }
-
-      const text = serializeXML(svg);
-
-      if (bg) {
-        svg.removeChild(node);
-
-        this._svg.style.setProperty('background-color', bg);
-      }
-
-      return text;
-    },
-
-    /**
-     * Internal rendering method.
-     * @param {object} scene - The root mark of a scenegraph to render.
-     */
-    _render(scene) {
-      // perform spot updates and re-render markup
-      if (this._dirtyCheck()) {
-        if (this._dirtyAll) this._clearDefs();
-        this.mark(this._root, scene);
-        domClear(this._root, 1);
-      }
-
-      this.defs();
-      this._dirty = [];
-      ++this._dirtyID;
-      return this;
-    },
-
-    // -- Manage rendering of items marked as dirty --
-
-    /**
-     * Flag a mark item as dirty.
-     * @param {Item} item - The mark item.
-     */
-    dirty(item) {
-      if (item.dirty !== this._dirtyID) {
-        item.dirty = this._dirtyID;
-
-        this._dirty.push(item);
-      }
-    },
-
-    /**
-     * Check if a mark item is considered dirty.
-     * @param {Item} item - The mark item.
-     */
-    isDirty(item) {
-      return this._dirtyAll || !item._svg || item.dirty === this._dirtyID;
-    },
-
-    /**
-     * Internal method to check dirty status and, if possible,
-     * make targetted updates without a full rendering pass.
-     */
-    _dirtyCheck() {
-      this._dirtyAll = true;
-      const items = this._dirty;
-      if (!items.length || !this._dirtyID) return true;
-      const id = ++this._dirtyID;
-      let item, mark, type, mdef, i, n, o;
-
-      for (i = 0, n = items.length; i < n; ++i) {
-        item = items[i];
-        mark = item.mark;
-
-        if (mark.marktype !== type) {
-          // memoize mark instance lookup
-          type = mark.marktype;
-          mdef = Marks[type];
-        }
-
-        if (mark.zdirty && mark.dirty !== id) {
-          this._dirtyAll = false;
-          dirtyParents(item, id);
-          mark.items.forEach(i => {
-            i.dirty = id;
-          });
-        }
-
-        if (mark.zdirty) continue; // handle in standard drawing pass
-
-        if (item.exit) {
-          // EXIT
-          if (mdef.nested && mark.items.length) {
-            // if nested mark with remaining points, update instead
-            o = mark.items[0];
-            if (o._svg) this._update(mdef, o._svg, o);
-          } else if (item._svg) {
-            // otherwise remove from DOM
-            o = item._svg.parentNode;
-            if (o) o.removeChild(item._svg);
-          }
-
-          item._svg = null;
-          continue;
-        }
-
-        item = mdef.nested ? mark.items[0] : item;
-        if (item._update === id) continue; // already visited
-
-        if (!item._svg || !item._svg.ownerSVGElement) {
-          // ENTER
-          this._dirtyAll = false;
-          dirtyParents(item, id);
-        } else {
-          // IN-PLACE UPDATE
-          this._update(mdef, item._svg, item);
-        }
-
-        item._update = id;
-      }
-
-      return !this._dirtyAll;
-    },
-
-    // -- Construct & maintain scenegraph to SVG mapping ---
-
-    /**
-     * Render a set of mark items.
-     * @param {SVGElement} el - The parent element in the SVG tree.
-     * @param {object} scene - The mark parent to render.
-     * @param {SVGElement} prev - The previous sibling in the SVG tree.
-     */
-    mark(el, scene, prev) {
-      if (!this.isDirty(scene)) return scene._svg;
-      const svg = this._svg,
-            mdef = Marks[scene.marktype],
-            events = scene.interactive === false ? 'none' : null,
-            isGroup = mdef.tag === 'g';
-      let sibling = null,
-          i = 0;
-      const parent = bind(scene, el, prev, 'g', svg);
-      parent.setAttribute('class', cssClass(scene)); // apply aria attributes to parent container element
-
-      const aria = ariaMarkAttributes(scene);
-
-      for (const key in aria) setAttribute(parent, key, aria[key]);
-
-      if (!isGroup) {
-        setAttribute(parent, 'pointer-events', events);
-      }
-
-      setAttribute(parent, 'clip-path', scene.clip ? clip$1(this, scene, scene.group) : null);
-
-      const process = item => {
-        const dirty = this.isDirty(item),
-              node = bind(item, parent, sibling, mdef.tag, svg);
-
-        if (dirty) {
-          this._update(mdef, node, item);
-
-          if (isGroup) recurse(this, node, item);
-        }
-
-        sibling = node;
-        ++i;
-      };
-
-      if (mdef.nested) {
-        if (scene.items.length) process(scene.items[0]);
-      } else {
-        visit(scene, process);
-      }
-
-      domClear(parent, i);
-      return parent;
-    },
-
-    /**
-     * Update the attributes of an SVG element for a mark item.
-     * @param {object} mdef - The mark definition object
-     * @param {SVGElement} el - The SVG element.
-     * @param {Item} item - The mark item.
-     */
-    _update(mdef, el, item) {
-      // set dom element and values cache
-      // provides access to emit method
-      element = el;
-      values = el.__values__; // apply aria-specific properties
-
-      ariaItemAttributes(emit, item); // apply svg attributes
-
-      mdef.attr(emit, item, this); // some marks need special treatment
-
-      const extra = mark_extras[mdef.type];
-      if (extra) extra.call(this, mdef, el, item); // apply svg style attributes
-      // note: element state may have been modified by 'extra' method
-
-      if (element) this.style(element, item);
-    },
-
-    /**
-     * Update the presentation attributes of an SVG element for a mark item.
-     * @param {SVGElement} el - The SVG element.
-     * @param {Item} item - The mark item.
-     */
-    style(el, item) {
-      if (item == null) return;
-
-      for (const prop in styles) {
-        let value = prop === 'font' ? fontFamily(item) : item[prop];
-        if (value === values[prop]) continue;
-        const name = styles[prop];
-
-        if (value == null) {
-          el.removeAttribute(name);
-        } else {
-          if (isGradient(value)) {
-            value = gradientRef(value, this._defs.gradient, href());
-          }
-
-          el.setAttribute(name, value + '');
-        }
-
-        values[prop] = value;
-      }
-    },
-
-    /**
-     * Render SVG defs, as needed.
-     * Must be called *after* marks have been processed to ensure the
-     * collected state is current and accurate.
-     */
-    defs() {
-      const svg = this._svg,
-            defs = this._defs;
-      let el = defs.el,
-          index = 0;
-
-      for (const id in defs.gradient) {
-        if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);
-        index = updateGradient(el, defs.gradient[id], index);
-      }
-
-      for (const id in defs.clipping) {
-        if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);
-        index = updateClipping(el, defs.clipping[id], index);
-      } // clean-up
-
-
-      if (el) {
-        index === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index);
-      }
-    },
-
-    /**
-     * Clear defs caches.
-     */
-    _clearDefs() {
-      const def = this._defs;
-      def.gradient = {};
-      def.clipping = {};
-    }
-
-  }); // mark ancestor chain with a dirty id
-
-  function dirtyParents(item, id) {
-    for (; item && item.dirty !== id; item = item.mark.group) {
-      item.dirty = id;
-
-      if (item.mark && item.mark.dirty !== id) {
-        item.mark.dirty = id;
-      } else return;
-    }
-  } // update gradient definitions
-
-
-  function updateGradient(el, grad, index) {
-    let i, n, stop;
-
-    if (grad.gradient === 'radial') {
-      // SVG radial gradients automatically transform to normalized bbox
-      // coordinates, in a way that is cumbersome to replicate in canvas.
-      // We wrap the radial gradient in a pattern element, allowing us to
-      // maintain a circular gradient that matches what canvas provides.
-      let pt = domChild(el, index++, 'pattern', svgns);
-      setAttributes(pt, {
-        id: patternPrefix + grad.id,
-        viewBox: '0,0,1,1',
-        width: '100%',
-        height: '100%',
-        preserveAspectRatio: 'xMidYMid slice'
-      });
-      pt = domChild(pt, 0, 'rect', svgns);
-      setAttributes(pt, {
-        width: 1,
-        height: 1,
-        fill: `url(${href()}#${grad.id})`
-      });
-      el = domChild(el, index++, 'radialGradient', svgns);
-      setAttributes(el, {
-        id: grad.id,
-        fx: grad.x1,
-        fy: grad.y1,
-        fr: grad.r1,
-        cx: grad.x2,
-        cy: grad.y2,
-        r: grad.r2
-      });
-    } else {
-      el = domChild(el, index++, 'linearGradient', svgns);
-      setAttributes(el, {
-        id: grad.id,
-        x1: grad.x1,
-        x2: grad.x2,
-        y1: grad.y1,
-        y2: grad.y2
-      });
-    }
-
-    for (i = 0, n = grad.stops.length; i < n; ++i) {
-      stop = domChild(el, i, 'stop', svgns);
-      stop.setAttribute('offset', grad.stops[i].offset);
-      stop.setAttribute('stop-color', grad.stops[i].color);
-    }
-
-    domClear(el, i);
-    return index;
-  } // update clipping path definitions
-
-
-  function updateClipping(el, clip, index) {
-    let mask;
-    el = domChild(el, index, 'clipPath', svgns);
-    el.setAttribute('id', clip.id);
-
-    if (clip.path) {
-      mask = domChild(el, 0, 'path', svgns);
-      mask.setAttribute('d', clip.path);
-    } else {
-      mask = domChild(el, 0, 'rect', svgns);
-      setAttributes(mask, {
-        x: 0,
-        y: 0,
-        width: clip.width,
-        height: clip.height
-      });
-    }
-
-    domClear(el, 1);
-    return index + 1;
-  } // Recursively process group contents.
-
-
-  function recurse(renderer, el, group) {
-    el = el.lastChild.previousSibling;
-    let prev,
-        idx = 0;
-    visit(group, item => {
-      prev = renderer.mark(el, item, prev);
-      ++idx;
-    }); // remove any extraneous DOM elements
-
-    domClear(el, 1 + idx);
-  } // Bind a scenegraph item to an SVG DOM element.
-  // Create new SVG elements as needed.
-
-
-  function bind(item, el, sibling, tag, svg) {
-    let node = item._svg,
-        doc; // create a new dom node if needed
-
-    if (!node) {
-      doc = el.ownerDocument;
-      node = domCreate(doc, tag, svgns);
-      item._svg = node;
-
-      if (item.mark) {
-        node.__data__ = item;
-        node.__values__ = {
-          fill: 'default'
-        }; // if group, create background, content, and foreground elements
-
-        if (tag === 'g') {
-          const bg = domCreate(doc, 'path', svgns);
-          node.appendChild(bg);
-          bg.__data__ = item;
-          const cg = domCreate(doc, 'g', svgns);
-          node.appendChild(cg);
-          cg.__data__ = item;
-          const fg = domCreate(doc, 'path', svgns);
-          node.appendChild(fg);
-          fg.__data__ = item;
-          fg.__values__ = {
-            fill: 'default'
-          };
-        }
-      }
-    } // (re-)insert if (a) not contained in SVG or (b) sibling order has changed
-
-
-    if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
-      el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
-    }
-
-    return node;
-  } // check if two nodes are ordered siblings
-
-
-  function siblingCheck(node, sibling) {
-    return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same
-  } // -- Set attributes & styles on SVG elements ---
-
-
-  let element = null,
-      // temp var for current SVG element
-  values = null; // temp var for current values hash
-  // Extra configuration for certain mark types
-
-  const mark_extras = {
-    group(mdef, el, item) {
-      const fg = element = el.childNodes[2];
-      values = fg.__values__;
-      mdef.foreground(emit, item, this);
-      values = el.__values__; // use parent's values hash
-
-      element = el.childNodes[1];
-      mdef.content(emit, item, this);
-      const bg = element = el.childNodes[0];
-      mdef.background(emit, item, this);
-      const value = item.mark.interactive === false ? 'none' : null;
-
-      if (value !== values.events) {
-        setAttribute(fg, 'pointer-events', value);
-        setAttribute(bg, 'pointer-events', value);
-        values.events = value;
-      }
-
-      if (item.strokeForeground && item.stroke) {
-        const fill = item.fill;
-        setAttribute(fg, 'display', null); // set style of background
-
-        this.style(bg, item);
-        setAttribute(bg, 'stroke', null); // set style of foreground
-
-        if (fill) item.fill = null;
-        values = fg.__values__;
-        this.style(fg, item);
-        if (fill) item.fill = fill; // leave element null to prevent downstream styling
-
-        element = null;
-      } else {
-        // ensure foreground is ignored
-        setAttribute(fg, 'display', 'none');
-      }
-    },
-
-    image(mdef, el, item) {
-      if (item.smooth === false) {
-        setStyle(el, 'image-rendering', 'optimizeSpeed');
-        setStyle(el, 'image-rendering', 'pixelated');
-      } else {
-        setStyle(el, 'image-rendering', null);
-      }
-    },
-
-    text(mdef, el, item) {
-      const tl = textLines(item);
-      let key, value, doc, lh;
-
-      if (vegaUtil.isArray(tl)) {
-        // multi-line text
-        value = tl.map(_ => textValue(item, _));
-        key = value.join('\n'); // content cache key
-
-        if (key !== values.text) {
-          domClear(el, 0);
-          doc = el.ownerDocument;
-          lh = lineHeight(item);
-          value.forEach((t, i) => {
-            const ts = domCreate(doc, 'tspan', svgns);
-            ts.__data__ = item; // data binding
-
-            ts.textContent = t;
-
-            if (i) {
-              ts.setAttribute('x', 0);
-              ts.setAttribute('dy', lh);
-            }
-
-            el.appendChild(ts);
-          });
-          values.text = key;
-        }
-      } else {
-        // single-line text
-        value = textValue(item, tl);
-
-        if (value !== values.text) {
-          el.textContent = value;
-          values.text = value;
-        }
-      }
-
-      setAttribute(el, 'font-family', fontFamily(item));
-      setAttribute(el, 'font-size', fontSize(item) + 'px');
-      setAttribute(el, 'font-style', item.fontStyle);
-      setAttribute(el, 'font-variant', item.fontVariant);
-      setAttribute(el, 'font-weight', item.fontWeight);
-    }
-
-  };
-
-  function emit(name, value, ns) {
-    // early exit if value is unchanged
-    if (value === values[name]) return; // use appropriate method given namespace (ns)
-
-    if (ns) {
-      setAttributeNS(element, name, value, ns);
-    } else {
-      setAttribute(element, name, value);
-    } // note current value for future comparison
-
-
-    values[name] = value;
-  }
-
-  function setStyle(el, name, value) {
-    if (value !== values[name]) {
-      if (value == null) {
-        el.style.removeProperty(name);
-      } else {
-        el.style.setProperty(name, value + '');
-      }
-
-      values[name] = value;
-    }
-  }
-
-  function setAttributes(el, attrs) {
-    for (const key in attrs) {
-      setAttribute(el, key, attrs[key]);
-    }
-  }
-
-  function setAttribute(el, name, value) {
-    if (value != null) {
-      // if value is provided, update DOM attribute
-      el.setAttribute(name, value);
-    } else {
-      // else remove DOM attribute
-      el.removeAttribute(name);
-    }
-  }
-
-  function setAttributeNS(el, name, value, ns) {
-    if (value != null) {
-      // if value is provided, update DOM attribute
-      el.setAttributeNS(ns, name, value);
-    } else {
-      // else remove DOM attribute
-      el.removeAttributeNS(ns, name);
-    }
-  }
-
-  function href() {
-    let loc;
-    return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
-  }
-
-  function SVGStringRenderer(loader) {
-    Renderer.call(this, loader);
-    this._text = null;
-    this._defs = {
-      gradient: {},
-      clipping: {}
-    };
-  }
-  vegaUtil.inherits(SVGStringRenderer, Renderer, {
-    /**
-     * Returns the rendered SVG text string,
-     * or null if rendering has not yet occurred.
-     */
-    svg() {
-      return this._text;
-    },
-
-    /**
-     * Internal rendering method.
-     * @param {object} scene - The root mark of a scenegraph to render.
-     */
-    _render(scene) {
-      const m = markup(); // svg tag
-
-      m.open('svg', vegaUtil.extend({}, metadata, {
-        class: 'marks',
-        width: this._width * this._scale,
-        height: this._height * this._scale,
-        viewBox: `0 0 ${this._width} ${this._height}`
-      })); // background, if defined
-
-      const bg = this._bgcolor;
-
-      if (bg && bg !== 'transparent' && bg !== 'none') {
-        m.open('rect', {
-          width: this._width,
-          height: this._height,
-          fill: bg
-        }).close();
-      } // root content group
-
-
-      m.open('g', rootAttributes, {
-        transform: 'translate(' + this._origin + ')'
-      });
-      this.mark(m, scene);
-      m.close(); // </g>
-      // defs
-
-      this.defs(m); // get SVG text string
-
-      this._text = m.close() + '';
-      return this;
-    },
-
-    /**
-     * Render a set of mark items.
-     * @param {object} m - The markup context.
-     * @param {object} scene - The mark parent to render.
-     */
-    mark(m, scene) {
-      const mdef = Marks[scene.marktype],
-            tag = mdef.tag,
-            attrList = [ariaItemAttributes, mdef.attr]; // render opening group tag
-
-      m.open('g', {
-        'class': cssClass(scene),
-        'clip-path': scene.clip ? clip$1(this, scene, scene.group) : null
-      }, ariaMarkAttributes(scene), {
-        'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null
-      }); // render contained elements
-
-      const process = item => {
-        const href = this.href(item);
-        if (href) m.open('a', href);
-        m.open(tag, this.attr(scene, item, attrList, tag !== 'g' ? tag : null));
-
-        if (tag === 'text') {
-          const tl = textLines(item);
-
-          if (vegaUtil.isArray(tl)) {
-            // multi-line text
-            const attrs = {
-              x: 0,
-              dy: lineHeight(item)
-            };
-
-            for (let i = 0; i < tl.length; ++i) {
-              m.open('tspan', i ? attrs : null).text(textValue(item, tl[i])).close();
-            }
-          } else {
-            // single-line text
-            m.text(textValue(item, tl));
-          }
-        } else if (tag === 'g') {
-          const fore = item.strokeForeground,
-                fill = item.fill,
-                stroke = item.stroke;
-
-          if (fore && stroke) {
-            item.stroke = null;
-          }
-
-          m.open('path', this.attr(scene, item, mdef.background, 'bgrect')).close(); // recurse for group content
-
-          m.open('g', this.attr(scene, item, mdef.content));
-          visit(item, scene => this.mark(m, scene));
-          m.close();
-
-          if (fore && stroke) {
-            if (fill) item.fill = null;
-            item.stroke = stroke;
-            m.open('path', this.attr(scene, item, mdef.foreground, 'bgrect')).close();
-            if (fill) item.fill = fill;
-          } else {
-            m.open('path', this.attr(scene, item, mdef.foreground, 'bgfore')).close();
-          }
-        }
-
-        m.close(); // </tag>
-
-        if (href) m.close(); // </a>
-      };
-
-      if (mdef.nested) {
-        if (scene.items && scene.items.length) process(scene.items[0]);
-      } else {
-        visit(scene, process);
-      } // render closing group tag
-
-
-      return m.close(); // </g>
-    },
-
-    /**
-     * Get href attributes for a hyperlinked mark item.
-     * @param {Item} item - The mark item.
-     */
-    href(item) {
-      const href = item.href;
-      let attr;
-
-      if (href) {
-        if (attr = this._hrefs && this._hrefs[href]) {
-          return attr;
-        } else {
-          this.sanitizeURL(href).then(attr => {
-            // rewrite to use xlink namespace
-            attr['xlink:href'] = attr.href;
-            attr.href = null;
-            (this._hrefs || (this._hrefs = {}))[href] = attr;
-          });
-        }
-      }
-
-      return null;
-    },
-
-    /**
-     * Get an object of SVG attributes for a mark item.
-     * @param {object} scene - The mark parent.
-     * @param {Item} item - The mark item.
-     * @param {array|function} attrs - One or more attribute emitters.
-     * @param {string} tag - The tag being rendered.
-     */
-    attr(scene, item, attrs, tag) {
-      const object = {},
-            emit = (name, value, ns, prefixed) => {
-        object[prefixed || name] = value;
-      }; // apply mark specific attributes
-
-
-      if (Array.isArray(attrs)) {
-        attrs.forEach(fn => fn(emit, item, this));
-      } else {
-        attrs(emit, item, this);
-      } // apply style attributes
-
-
-      if (tag) {
-        style(object, item, scene, tag, this._defs);
-      }
-
-      return object;
-    },
-
-    /**
-     * Render SVG defs, as needed.
-     * Must be called *after* marks have been processed to ensure the
-     * collected state is current and accurate.
-     * @param {object} m - The markup context.
-     */
-    defs(m) {
-      const gradient = this._defs.gradient,
-            clipping = this._defs.clipping,
-            count = Object.keys(gradient).length + Object.keys(clipping).length;
-      if (count === 0) return; // nothing to do
-
-      m.open('defs');
-
-      for (const id in gradient) {
-        const def = gradient[id],
-              stops = def.stops;
-
-        if (def.gradient === 'radial') {
-          // SVG radial gradients automatically transform to normalized bbox
-          // coordinates, in a way that is cumbersome to replicate in canvas.
-          // We wrap the radial gradient in a pattern element, allowing us to
-          // maintain a circular gradient that matches what canvas provides.
-          m.open('pattern', {
-            id: patternPrefix + id,
-            viewBox: '0,0,1,1',
-            width: '100%',
-            height: '100%',
-            preserveAspectRatio: 'xMidYMid slice'
-          });
-          m.open('rect', {
-            width: '1',
-            height: '1',
-            fill: 'url(#' + id + ')'
-          }).close();
-          m.close(); // </pattern>
-
-          m.open('radialGradient', {
-            id: id,
-            fx: def.x1,
-            fy: def.y1,
-            fr: def.r1,
-            cx: def.x2,
-            cy: def.y2,
-            r: def.r2
-          });
-        } else {
-          m.open('linearGradient', {
-            id: id,
-            x1: def.x1,
-            x2: def.x2,
-            y1: def.y1,
-            y2: def.y2
-          });
-        }
-
-        for (let i = 0; i < stops.length; ++i) {
-          m.open('stop', {
-            offset: stops[i].offset,
-            'stop-color': stops[i].color
-          }).close();
-        }
-
-        m.close();
-      }
-
-      for (const id in clipping) {
-        const def = clipping[id];
-        m.open('clipPath', {
-          id: id
-        });
-
-        if (def.path) {
-          m.open('path', {
-            d: def.path
-          }).close();
-        } else {
-          m.open('rect', {
-            x: 0,
-            y: 0,
-            width: def.width,
-            height: def.height
-          }).close();
-        }
-
-        m.close();
-      }
-
-      m.close();
-    }
-
-  }); // Helper function for attr for style presentation attributes
-
-  function style(s, item, scene, tag, defs) {
-    if (item == null) return s;
-
-    if (tag === 'bgrect' && scene.interactive === false) {
-      s['pointer-events'] = 'none';
-    }
-
-    if (tag === 'bgfore') {
-      if (scene.interactive === false) {
-        s['pointer-events'] = 'none';
-      }
-
-      s.display = 'none';
-      if (item.fill !== null) return s;
-    }
-
-    if (tag === 'image' && item.smooth === false) {
-      s.style = 'image-rendering: optimizeSpeed; image-rendering: pixelated;';
-    }
-
-    if (tag === 'text') {
-      s['font-family'] = fontFamily(item);
-      s['font-size'] = fontSize(item) + 'px';
-      s['font-style'] = item.fontStyle;
-      s['font-variant'] = item.fontVariant;
-      s['font-weight'] = item.fontWeight;
-    }
-
-    for (const prop in styles) {
-      let value = item[prop];
-      const name = styles[prop];
-
-      if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ; else if (value != null) {
-        if (isGradient(value)) {
-          value = gradientRef(value, defs.gradient, '');
-        }
-
-        s[name] = value;
-      }
-    }
-
-    return s;
-  }
-
-  const Canvas = 'canvas';
-  const PNG = 'png';
-  const SVG = 'svg';
-  const None = 'none';
-  const RenderType = {
-    Canvas: Canvas,
-    PNG: PNG,
-    SVG: SVG,
-    None: None
-  };
-  const modules = {};
-  modules[Canvas] = modules[PNG] = {
-    renderer: CanvasRenderer,
-    headless: CanvasRenderer,
-    handler: CanvasHandler
-  };
-  modules[SVG] = {
-    renderer: SVGRenderer,
-    headless: SVGStringRenderer,
-    handler: SVGHandler
-  };
-  modules[None] = {};
-  function renderModule(name, _) {
-    name = String(name || '').toLowerCase();
-
-    if (arguments.length > 1) {
-      modules[name] = _;
-      return this;
-    } else {
-      return modules[name];
-    }
-  }
-
-  function intersect(scene, bounds, filter) {
-    const hits = [],
-          // intersection results
-    box = new Bounds().union(bounds),
-          // defensive copy
-    type = scene.marktype;
-    return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : vegaUtil.error('Intersect scene must be mark node or group item.');
-  }
-
-  function intersectMark(mark, box, filter, hits) {
-    if (visitMark(mark, box, filter)) {
-      const items = mark.items,
-            type = mark.marktype,
-            n = items.length;
-      let i = 0;
-
-      if (type === 'group') {
-        for (; i < n; ++i) {
-          intersectGroup(items[i], box, filter, hits);
-        }
-      } else {
-        for (const test = Marks[type].isect; i < n; ++i) {
-          const item = items[i];
-          if (intersectItem(item, box, test)) hits.push(item);
-        }
-      }
-    }
-
-    return hits;
-  }
-
-  function visitMark(mark, box, filter) {
-    // process if bounds intersect and if
-    // (1) mark is a group mark (so we must recurse), or
-    // (2) mark is interactive and passes filter
-    return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));
-  }
-
-  function intersectGroup(group, box, filter, hits) {
-    // test intersect against group
-    // skip groups by default unless filter says otherwise
-    if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {
-      hits.push(group);
-    } // recursively test children marks
-    // translate box to group coordinate space
-
-
-    const marks = group.items,
-          n = marks && marks.length;
-
-    if (n) {
-      const x = group.x || 0,
-            y = group.y || 0;
-      box.translate(-x, -y);
-
-      for (let i = 0; i < n; ++i) {
-        intersectMark(marks[i], box, filter, hits);
-      }
-
-      box.translate(x, y);
-    }
-
-    return hits;
-  }
-
-  function intersectItem(item, box, test) {
-    // test bounds enclosure, bounds intersection, then detailed test
-    const bounds = item.bounds;
-    return box.encloses(bounds) || box.intersects(bounds) && test(item, box);
-  }
-
-  const clipBounds = new Bounds();
-  function boundClip (mark) {
-    const clip = mark.clip;
-
-    if (vegaUtil.isFunction(clip)) {
-      clip(boundContext(clipBounds.clear()));
-    } else if (clip) {
-      clipBounds.set(0, 0, mark.group.width, mark.group.height);
-    } else return;
-
-    mark.bounds.intersect(clipBounds);
-  }
-
-  const TOLERANCE = 1e-9;
-  function sceneEqual(a, b, key) {
-    return a === b ? true : key === 'path' ? pathEqual(a, b) : a instanceof Date && b instanceof Date ? +a === +b : vegaUtil.isNumber(a) && vegaUtil.isNumber(b) ? Math.abs(a - b) <= TOLERANCE : !a || !b || !vegaUtil.isObject(a) && !vegaUtil.isObject(b) ? a == b : objectEqual(a, b);
-  }
-  function pathEqual(a, b) {
-    return sceneEqual(pathParse(a), pathParse(b));
-  }
-
-  function objectEqual(a, b) {
-    var ka = Object.keys(a),
-        kb = Object.keys(b),
-        key,
-        i;
-    if (ka.length !== kb.length) return false;
-    ka.sort();
-    kb.sort();
-
-    for (i = ka.length - 1; i >= 0; i--) {
-      if (ka[i] != kb[i]) return false;
-    }
-
-    for (i = ka.length - 1; i >= 0; i--) {
-      key = ka[i];
-      if (!sceneEqual(a[key], b[key], key)) return false;
-    }
-
-    return typeof a === typeof b;
-  }
-
-  function resetSVGDefIds() {
-    resetSVGClipId();
-    resetSVGGradientId();
-  }
-
-  exports.Bounds = Bounds;
-  exports.CanvasHandler = CanvasHandler;
-  exports.CanvasRenderer = CanvasRenderer;
-  exports.Gradient = Gradient;
-  exports.GroupItem = GroupItem;
-  exports.Handler = Handler;
-  exports.Item = Item;
-  exports.Marks = Marks;
-  exports.RenderType = RenderType;
-  exports.Renderer = Renderer;
-  exports.ResourceLoader = ResourceLoader;
-  exports.SVGHandler = SVGHandler;
-  exports.SVGRenderer = SVGRenderer;
-  exports.SVGStringRenderer = SVGStringRenderer;
-  exports.Scenegraph = Scenegraph;
-  exports.boundClip = boundClip;
-  exports.boundContext = boundContext;
-  exports.boundItem = boundItem;
-  exports.boundMark = boundMark;
-  exports.boundStroke = boundStroke;
-  exports.domChild = domChild;
-  exports.domClear = domClear;
-  exports.domCreate = domCreate;
-  exports.domFind = domFind;
-  exports.font = font;
-  exports.fontFamily = fontFamily;
-  exports.fontSize = fontSize;
-  exports.intersect = intersect;
-  exports.intersectBoxLine = intersectBoxLine;
-  exports.intersectPath = intersectPath;
-  exports.intersectPoint = intersectPoint;
-  exports.intersectRule = intersectRule;
-  exports.lineHeight = lineHeight;
-  exports.markup = markup;
-  exports.multiLineOffset = multiLineOffset;
-  exports.pathCurves = curves;
-  exports.pathEqual = pathEqual;
-  exports.pathParse = pathParse;
-  exports.pathRectangle = vg_rect;
-  exports.pathRender = pathRender;
-  exports.pathSymbols = symbols;
-  exports.pathTrail = vg_trail;
-  exports.point = point;
-  exports.renderModule = renderModule;
-  exports.resetSVGClipId = resetSVGClipId;
-  exports.resetSVGDefIds = resetSVGDefIds;
-  exports.sceneEqual = sceneEqual;
-  exports.sceneFromJSON = sceneFromJSON;
-  exports.scenePickVisit = pickVisit;
-  exports.sceneToJSON = sceneToJSON;
-  exports.sceneVisit = visit;
-  exports.sceneZOrder = zorder;
-  exports.serializeXML = serializeXML;
-  exports.textMetrics = textMetrics;
-
-  Object.defineProperty(exports, '__esModule', { value: true });
-
-})));
diff --git a/node_modules/vega-scenegraph/build/vega-scenegraph.min.js b/node_modules/vega-scenegraph/build/vega-scenegraph.min.js
deleted file mode 100644
index ed573d8..0000000
--- a/node_modules/vega-scenegraph/build/vega-scenegraph.min.js
+++ /dev/null
@@ -1,2 +0,0 @@
-!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("vega-util"),require("vega-canvas"),require("vega-loader"),require("vega-scale")):"function"==typeof define&&define.amd?define(["exports","vega-util","vega-canvas","vega-loader","vega-scale"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).vega={},t.vega,t.vega,t.vega,t.vega)}(this,(function(t,i,n,e,s){"use strict";let r=0;const o="p_";function h(t){return t&&t.gradient}function a(t,i,n){const e=t.gradient;let s=t.id,h="radial"===e?o:"";return s||(s=t.id="gradient_"+r++,"radial"===e?(t.x1=l(t.x1,.5),t.y1=l(t.y1,.5),t.r1=l(t.r1,0),t.x2=l(t.x2,.5),t.y2=l(t.y2,.5),t.r2=l(t.r2,.5),h=o):(t.x1=l(t.x1,0),t.y1=l(t.y1,0),t.x2=l(t.x2,1),t.y2=l(t.y2,0))),i[s]=t,"url("+(n||"")+"#"+h+s+")"}function l(t,i){return null!=t?t:i}const c=Math.PI,u=2*c,_=1e-6,f=u-_;function d(){this._x0=this._y0=this._x1=this._y1=null,this._=""}function p(){return new d}function y(t){return function(){return t}}d.prototype=p.prototype={constructor:d,moveTo:function(t,i){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+i)},closePath:function(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")},lineTo:function(t,i){this._+="L"+(this._x1=+t)+","+(this._y1=+i)},quadraticCurveTo:function(t,i,n,e){this._+="Q"+ +t+","+ +i+","+(this._x1=+n)+","+(this._y1=+e)},bezierCurveTo:function(t,i,n,e,s,r){this._+="C"+ +t+","+ +i+","+ +n+","+ +e+","+(this._x1=+s)+","+(this._y1=+r)},arcTo:function(t,i,n,e,s){t=+t,i=+i,n=+n,e=+e,s=+s;var r=this._x1,o=this._y1,h=n-t,a=e-i,l=r-t,u=o-i,f=l*l+u*u;if(s<0)throw new Error("negative radius: "+s);if(null===this._x1)this._+="M"+(this._x1=t)+","+(this._y1=i);else if(f>_)if(Math.abs(u*h-a*l)>_&&s){var d=n-r,p=e-o,y=h*h+a*a,x=d*d+p*p,g=Math.sqrt(y),v=Math.sqrt(f),m=s*Math.tan((c-Math.acos((y+f-x)/(2*g*v)))/2),b=m/v,k=m/g;Math.abs(b-1)>_&&(this._+="L"+(t+b*l)+","+(i+b*u)),this._+="A"+s+","+s+",0,0,"+ +(u*d>l*p)+","+(this._x1=t+k*h)+","+(this._y1=i+k*a)}else this._+="L"+(this._x1=t)+","+(this._y1=i);else;},arc:function(t,i,n,e,s,r){t=+t,i=+i,r=!!r;var o=(n=+n)*Math.cos(e),h=n*Math.sin(e),a=t+o,l=i+h,d=1^r,p=r?e-s:s-e;if(n<0)throw new Error("negative radius: "+n);null===this._x1?this._+="M"+a+","+l:(Math.abs(this._x1-a)>_||Math.abs(this._y1-l)>_)&&(this._+="L"+a+","+l),n&&(p<0&&(p=p%u+u),p>f?this._+="A"+n+","+n+",0,1,"+d+","+(t-o)+","+(i-h)+"A"+n+","+n+",0,1,"+d+","+(this._x1=a)+","+(this._y1=l):p>_&&(this._+="A"+n+","+n+",0,"+ +(p>=c)+","+d+","+(this._x1=t+n*Math.cos(s))+","+(this._y1=i+n*Math.sin(s))))},rect:function(t,i,n,e){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+i)+"h"+ +n+"v"+ +e+"h"+-n+"Z"},toString:function(){return this._}};var x=Math.abs,g=Math.atan2,v=Math.cos,m=Math.max,b=Math.min,k=Math.sin,w=Math.sqrt,T=1e-12,M=Math.PI,A=M/2,S=2*M;function C(t){return t>1?0:t<-1?M:Math.acos(t)}function N(t){return t>=1?A:t<=-1?-A:Math.asin(t)}function z(t){return t.innerRadius}function R(t){return t.outerRadius}function P(t){return t.startAngle}function E(t){return t.endAngle}function L(t){return t&&t.padAngle}function q(t,i,n,e,s,r,o,h){var a=n-t,l=e-i,c=o-s,u=h-r,_=u*a-c*l;if(!(_*_<T))return[t+(_=(c*(i-r)-u*(t-s))/_)*a,i+_*l]}function O(t,i,n,e,s,r,o){var h=t-n,a=i-e,l=(o?r:-r)/w(h*h+a*a),c=l*a,u=-l*h,_=t+c,f=i+u,d=n+c,p=e+u,y=(_+d)/2,x=(f+p)/2,g=d-_,v=p-f,b=g*g+v*v,k=s-r,T=_*p-d*f,M=(v<0?-1:1)*w(m(0,k*k*b-T*T)),A=(T*v-g*M)/b,S=(-T*g-v*M)/b,C=(T*v+g*M)/b,N=(-T*g+v*M)/b,z=A-y,R=S-x,P=C-y,E=N-x;return z*z+R*R>P*P+E*E&&(A=C,S=N),{cx:A,cy:S,x01:-c,y01:-u,x11:A*(s/k-1),y11:S*(s/k-1)}}function D(t){return"object"==typeof t&&"length"in t?t:Array.from(t)}function I(t){this._context=t}function $(t){return new I(t)}function V(t){return t[0]}function H(t){return t[1]}function j(t,i){var n=y(!0),e=null,s=$,r=null;function o(o){var h,a,l,c=(o=D(o)).length,u=!1;for(null==e&&(r=s(l=p())),h=0;h<=c;++h)!(h<c&&n(a=o[h],h,o))===u&&((u=!u)?r.lineStart():r.lineEnd()),u&&r.point(+t(a,h,o),+i(a,h,o));if(l)return r=null,l+""||null}return t="function"==typeof t?t:void 0===t?V:y(t),i="function"==typeof i?i:void 0===i?H:y(i),o.x=function(i){return arguments.length?(t="function"==typeof i?i:y(+i),o):t},o.y=function(t){return arguments.length?(i="function"==typeof t?t:y(+t),o):i},o.defined=function(t){return arguments.length?(n="function"==typeof t?t:y(!!t),o):n},o.curve=function(t){return arguments.length?(s=t,null!=e&&(r=s(e)),o):s},o.context=function(t){return arguments.length?(null==t?e=r=null:r=s(e=t),o):e},o}function B(t,i,n){var e=null,s=y(!0),r=null,o=$,h=null;function a(a){var l,c,u,_,f,d=(a=D(a)).length,y=!1,x=new Array(d),g=new Array(d);for(null==r&&(h=o(f=p())),l=0;l<=d;++l){if(!(l<d&&s(_=a[l],l,a))===y)if(y=!y)c=l,h.areaStart(),h.lineStart();else{for(h.lineEnd(),h.lineStart(),u=l-1;u>=c;--u)h.point(x[u],g[u]);h.lineEnd(),h.areaEnd()}y&&(x[l]=+t(_,l,a),g[l]=+i(_,l,a),h.point(e?+e(_,l,a):x[l],n?+n(_,l,a):g[l]))}if(f)return h=null,f+""||null}function l(){return j().defined(s).curve(o).context(r)}return t="function"==typeof t?t:void 0===t?V:y(+t),i="function"==typeof i?i:y(void 0===i?0:+i),n="function"==typeof n?n:void 0===n?H:y(+n),a.x=function(i){return arguments.length?(t="function"==typeof i?i:y(+i),e=null,a):t},a.x0=function(i){return arguments.length?(t="function"==typeof i?i:y(+i),a):t},a.x1=function(t){return arguments.length?(e=null==t?null:"function"==typeof t?t:y(+t),a):e},a.y=function(t){return arguments.length?(i="function"==typeof t?t:y(+t),n=null,a):i},a.y0=function(t){return arguments.length?(i="function"==typeof t?t:y(+t),a):i},a.y1=function(t){return arguments.length?(n=null==t?null:"function"==typeof t?t:y(+t),a):n},a.lineX0=a.lineY0=function(){return l().x(t).y(i)},a.lineY1=function(){return l().x(t).y(n)},a.lineX1=function(){return l().x(e).y(i)},a.defined=function(t){return arguments.length?(s="function"==typeof t?t:y(!!t),a):s},a.curve=function(t){return arguments.length?(o=t,null!=r&&(h=o(r)),a):o},a.context=function(t){return arguments.length?(null==t?r=h=null:h=o(r=t),a):r},a}I.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,i){switch(t=+t,i=+i,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,i):this._context.moveTo(t,i);break;case 1:this._point=2;default:this._context.lineTo(t,i)}}};var G={draw:function(t,i){var n=Math.sqrt(i/M);t.moveTo(n,0),t.arc(0,0,n,0,S)}};function W(){}function X(t,i,n){t._context.bezierCurveTo((2*t._x0+t._x1)/3,(2*t._y0+t._y1)/3,(t._x0+2*t._x1)/3,(t._y0+2*t._y1)/3,(t._x0+4*t._x1+i)/6,(t._y0+4*t._y1+n)/6)}function U(t){this._context=t}function F(t){this._context=t}function Y(t){this._context=t}function J(t,i){this._basis=new U(t),this._beta=i}U.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN,this._point=0},lineEnd:function(){switch(this._point){case 3:X(this,this._x1,this._y1);case 2:this._context.lineTo(this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,i){switch(t=+t,i=+i,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,i):this._context.moveTo(t,i);break;case 1:this._point=2;break;case 2:this._point=3,this._context.lineTo((5*this._x0+this._x1)/6,(5*this._y0+this._y1)/6);default:X(this,t,i)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=i}},F.prototype={areaStart:W,areaEnd:W,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._y0=this._y1=this._y2=this._y3=this._y4=NaN,this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x2,this._y2),this._context.closePath();break;case 2:this._context.moveTo((this._x2+2*this._x3)/3,(this._y2+2*this._y3)/3),this._context.lineTo((this._x3+2*this._x2)/3,(this._y3+2*this._y2)/3),this._context.closePath();break;case 3:this.point(this._x2,this._y2),this.point(this._x3,this._y3),this.point(this._x4,this._y4)}},point:function(t,i){switch(t=+t,i=+i,this._point){case 0:this._point=1,this._x2=t,this._y2=i;break;case 1:this._point=2,this._x3=t,this._y3=i;break;case 2:this._point=3,this._x4=t,this._y4=i,this._context.moveTo((this._x0+4*this._x1+t)/6,(this._y0+4*this._y1+i)/6);break;default:X(this,t,i)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=i}},Y.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN,this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,i){switch(t=+t,i=+i,this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;var n=(this._x0+4*this._x1+t)/6,e=(this._y0+4*this._y1+i)/6;this._line?this._context.lineTo(n,e):this._context.moveTo(n,e);break;case 3:this._point=4;default:X(this,t,i)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=i}},J.prototype={lineStart:function(){this._x=[],this._y=[],this._basis.lineStart()},lineEnd:function(){var t=this._x,i=this._y,n=t.length-1;if(n>0)for(var e,s=t[0],r=i[0],o=t[n]-s,h=i[n]-r,a=-1;++a<=n;)e=a/n,this._basis.point(this._beta*t[a]+(1-this._beta)*(s+e*o),this._beta*i[a]+(1-this._beta)*(r+e*h));this._x=this._y=null,this._basis.lineEnd()},point:function(t,i){this._x.push(+t),this._y.push(+i)}};var Z=function t(i){function n(t){return 1===i?new U(t):new J(t,i)}return n.beta=function(i){return t(+i)},n}(.85);function Q(t,i,n){t._context.bezierCurveTo(t._x1+t._k*(t._x2-t._x0),t._y1+t._k*(t._y2-t._y0),t._x2+t._k*(t._x1-i),t._y2+t._k*(t._y1-n),t._x2,t._y2)}function K(t,i){this._context=t,this._k=(1-i)/6}K.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:Q(this,this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,i){switch(t=+t,i=+i,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,i):this._context.moveTo(t,i);break;case 1:this._point=2,this._x1=t,this._y1=i;break;case 2:this._point=3;default:Q(this,t,i)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=i}};var tt=function t(i){function n(t){return new K(t,i)}return n.tension=function(i){return t(+i)},n}(0);function it(t,i){this._context=t,this._k=(1-i)/6}it.prototype={areaStart:W,areaEnd:W,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN,this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x3,this._y3),this._context.closePath();break;case 2:this._context.lineTo(this._x3,this._y3),this._context.closePath();break;case 3:this.point(this._x3,this._y3),this.point(this._x4,this._y4),this.point(this._x5,this._y5)}},point:function(t,i){switch(t=+t,i=+i,this._point){case 0:this._point=1,this._x3=t,this._y3=i;break;case 1:this._point=2,this._context.moveTo(this._x4=t,this._y4=i);break;case 2:this._point=3,this._x5=t,this._y5=i;break;default:Q(this,t,i)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=i}};var nt=function t(i){function n(t){return new it(t,i)}return n.tension=function(i){return t(+i)},n}(0);function et(t,i){this._context=t,this._k=(1-i)/6}et.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,i){switch(t=+t,i=+i,this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3,this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:Q(this,t,i)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=i}};var st=function t(i){function n(t){return new et(t,i)}return n.tension=function(i){return t(+i)},n}(0);function rt(t,i,n){var e=t._x1,s=t._y1,r=t._x2,o=t._y2;if(t._l01_a>T){var h=2*t._l01_2a+3*t._l01_a*t._l12_a+t._l12_2a,a=3*t._l01_a*(t._l01_a+t._l12_a);e=(e*h-t._x0*t._l12_2a+t._x2*t._l01_2a)/a,s=(s*h-t._y0*t._l12_2a+t._y2*t._l01_2a)/a}if(t._l23_a>T){var l=2*t._l23_2a+3*t._l23_a*t._l12_a+t._l12_2a,c=3*t._l23_a*(t._l23_a+t._l12_a);r=(r*l+t._x1*t._l23_2a-i*t._l12_2a)/c,o=(o*l+t._y1*t._l23_2a-n*t._l12_2a)/c}t._context.bezierCurveTo(e,s,r,o,t._x2,t._y2)}function ot(t,i){this._context=t,this._alpha=i}ot.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:this.point(this._x2,this._y2)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,i){if(t=+t,i=+i,this._point){var n=this._x2-t,e=this._y2-i;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(n*n+e*e,this._alpha))}switch(this._point){case 0:this._point=1,this._line?this._context.lineTo(t,i):this._context.moveTo(t,i);break;case 1:this._point=2;break;case 2:this._point=3;default:rt(this,t,i)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=i}};var ht=function t(i){function n(t){return i?new ot(t,i):new K(t,0)}return n.alpha=function(i){return t(+i)},n}(.5);function at(t,i){this._context=t,this._alpha=i}at.prototype={areaStart:W,areaEnd:W,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x3,this._y3),this._context.closePath();break;case 2:this._context.lineTo(this._x3,this._y3),this._context.closePath();break;case 3:this.point(this._x3,this._y3),this.point(this._x4,this._y4),this.point(this._x5,this._y5)}},point:function(t,i){if(t=+t,i=+i,this._point){var n=this._x2-t,e=this._y2-i;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(n*n+e*e,this._alpha))}switch(this._point){case 0:this._point=1,this._x3=t,this._y3=i;break;case 1:this._point=2,this._context.moveTo(this._x4=t,this._y4=i);break;case 2:this._point=3,this._x5=t,this._y5=i;break;default:rt(this,t,i)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=i}};var lt=function t(i){function n(t){return i?new at(t,i):new it(t,0)}return n.alpha=function(i){return t(+i)},n}(.5);function ct(t,i){this._context=t,this._alpha=i}ct.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,i){if(t=+t,i=+i,this._point){var n=this._x2-t,e=this._y2-i;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(n*n+e*e,this._alpha))}switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3,this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:rt(this,t,i)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=i}};var ut=function t(i){function n(t){return i?new ct(t,i):new et(t,0)}return n.alpha=function(i){return t(+i)},n}(.5);function _t(t){this._context=t}function ft(t){return t<0?-1:1}function dt(t,i,n){var e=t._x1-t._x0,s=i-t._x1,r=(t._y1-t._y0)/(e||s<0&&-0),o=(n-t._y1)/(s||e<0&&-0),h=(r*s+o*e)/(e+s);return(ft(r)+ft(o))*Math.min(Math.abs(r),Math.abs(o),.5*Math.abs(h))||0}function pt(t,i){var n=t._x1-t._x0;return n?(3*(t._y1-t._y0)/n-i)/2:i}function yt(t,i,n){var e=t._x0,s=t._y0,r=t._x1,o=t._y1,h=(r-e)/3;t._context.bezierCurveTo(e+h,s+h*i,r-h,o-h*n,r,o)}function xt(t){this._context=t}function gt(t){this._context=new vt(t)}function vt(t){this._context=t}function mt(t){this._context=t}function bt(t){var i,n,e=t.length-1,s=new Array(e),r=new Array(e),o=new Array(e);for(s[0]=0,r[0]=2,o[0]=t[0]+2*t[1],i=1;i<e-1;++i)s[i]=1,r[i]=4,o[i]=4*t[i]+2*t[i+1];for(s[e-1]=2,r[e-1]=7,o[e-1]=8*t[e-1]+t[e],i=1;i<e;++i)n=s[i]/r[i-1],r[i]-=n,o[i]-=n*o[i-1];for(s[e-1]=o[e-1]/r[e-1],i=e-2;i>=0;--i)s[i]=(o[i]-s[i+1])/r[i];for(r[e-1]=(t[e]+s[e-1])/2,i=0;i<e-1;++i)r[i]=2*t[i+1]-s[i+1];return[s,r]}function kt(t,i){this._context=t,this._t=i}_t.prototype={areaStart:W,areaEnd:W,lineStart:function(){this._point=0},lineEnd:function(){this._point&&this._context.closePath()},point:function(t,i){t=+t,i=+i,this._point?this._context.lineTo(t,i):(this._point=1,this._context.moveTo(t,i))}},xt.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=this._t0=NaN,this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x1,this._y1);break;case 3:yt(this,this._t0,pt(this,this._t0))}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,i){var n=NaN;if(i=+i,(t=+t)!==this._x1||i!==this._y1){switch(this._point){case 0:this._point=1,this._line?this._context.lineTo(t,i):this._context.moveTo(t,i);break;case 1:this._point=2;break;case 2:this._point=3,yt(this,pt(this,n=dt(this,t,i)),n);break;default:yt(this,this._t0,n=dt(this,t,i))}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=i,this._t0=n}}},(gt.prototype=Object.create(xt.prototype)).point=function(t,i){xt.prototype.point.call(this,i,t)},vt.prototype={moveTo:function(t,i){this._context.moveTo(i,t)},closePath:function(){this._context.closePath()},lineTo:function(t,i){this._context.lineTo(i,t)},bezierCurveTo:function(t,i,n,e,s,r){this._context.bezierCurveTo(i,t,e,n,r,s)}},mt.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=[],this._y=[]},lineEnd:function(){var t=this._x,i=this._y,n=t.length;if(n)if(this._line?this._context.lineTo(t[0],i[0]):this._context.moveTo(t[0],i[0]),2===n)this._context.lineTo(t[1],i[1]);else for(var e=bt(t),s=bt(i),r=0,o=1;o<n;++r,++o)this._context.bezierCurveTo(e[0][r],s[0][r],e[1][r],s[1][r],t[o],i[o]);(this._line||0!==this._line&&1===n)&&this._context.closePath(),this._line=1-this._line,this._x=this._y=null},point:function(t,i){this._x.push(+t),this._y.push(+i)}},kt.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=this._y=NaN,this._point=0},lineEnd:function(){0<this._t&&this._t<1&&2===this._point&&this._context.lineTo(this._x,this._y),(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line>=0&&(this._t=1-this._t,this._line=1-this._line)},point:function(t,i){switch(t=+t,i=+i,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,i):this._context.moveTo(t,i);break;case 1:this._point=2;default:if(this._t<=0)this._context.lineTo(this._x,i),this._context.lineTo(t,i);else{var n=this._x*(1-this._t)+t*this._t;this._context.lineTo(n,this._y),this._context.lineTo(n,i)}}this._x=t,this._y=i}};const wt={basis:{curve:function(t){return new U(t)}},"basis-closed":{curve:function(t){return new F(t)}},"basis-open":{curve:function(t){return new Y(t)}},bundle:{curve:Z,tension:"beta",value:.85},cardinal:{curve:tt,tension:"tension",value:0},"cardinal-open":{curve:st,tension:"tension",value:0},"cardinal-closed":{curve:nt,tension:"tension",value:0},"catmull-rom":{curve:ht,tension:"alpha",value:.5},"catmull-rom-closed":{curve:lt,tension:"alpha",value:.5},"catmull-rom-open":{curve:ut,tension:"alpha",value:.5},linear:{curve:$},"linear-closed":{curve:function(t){return new _t(t)}},monotone:{horizontal:function(t){return new gt(t)},vertical:function(t){return new xt(t)}},natural:{curve:function(t){return new mt(t)}},step:{curve:function(t){return new kt(t,.5)}},"step-after":{curve:function(t){return new kt(t,1)}},"step-before":{curve:function(t){return new kt(t,0)}}};function Tt(t,n,e){var s=i.hasOwnProperty(wt,t)&&wt[t],r=null;return s&&(r=s.curve||s[n||"vertical"],s.tension&&null!=e&&(r=r[s.tension](e))),r}const Mt={m:2,l:2,h:1,v:1,c:6,s:4,q:4,t:2,a:7},At=[/([MLHVCSQTAZmlhvcsqtaz])/g,/###/,/(\.\d+)(\.\d)/g,/(\d)([-+])/g,/\s|,|###/];function St(t){const i=[];let n,e,s,r,o,h,a,l,c,u;const _=t.slice().replace(At[0],"###$1").split(At[1]).slice(1);for(a=0,c=_.length;a<c;++a){for(n=_[a],e=n.slice(1).trim().replace(At[2],"$1###$2").replace(At[3],"$1###$2").split(At[4]),o=n.charAt(0),s=[o],l=0,u=e.length;l<u;++l)(r=+e[l])===r&&s.push(r);if(h=Mt[o.toLowerCase()],s.length-1>h){const t=s.length;for(l=1,i.push([o].concat(s.slice(l,l+=h))),o="M"===o?"L":"m"===o?"l":o;l<t;l+=h)i.push([o].concat(s.slice(l,l+h)))}else i.push(s)}return i}const Ct=Math.PI/180,Nt=Math.PI/2,zt=2*Math.PI,Rt=Math.sqrt(3)/2;var Pt={},Et={},Lt=[].join;function qt(t){const i=Lt.call(t);if(Et[i])return Et[i];var n=t[0],e=t[1],s=t[2],r=t[3],o=t[4],h=t[5],a=t[6],l=t[7];const c=l*o,u=-a*h,_=a*o,f=l*h,d=Math.cos(s),p=Math.sin(s),y=Math.cos(r),x=Math.sin(r),g=.5*(r-s),v=Math.sin(.5*g),m=8/3*v*v/Math.sin(g),b=n+d-m*p,k=e+p+m*d,w=n+y,T=e+x,M=w+m*x,A=T-m*y;return Et[i]=[c*b+u*k,_*b+f*k,c*M+u*A,_*M+f*A,c*w+u*T,_*w+f*T]}const Ot=["l",0,0,0,0,0,0,0];function Dt(t,i,n){const e=Ot[0]=t[0];if("a"===e||"A"===e)Ot[1]=i*t[1],Ot[2]=n*t[2],Ot[3]=t[3],Ot[4]=t[4],Ot[5]=t[5],Ot[6]=i*t[6],Ot[7]=n*t[7];else if("h"===e||"H"===e)Ot[1]=i*t[1];else if("v"===e||"V"===e)Ot[1]=n*t[1];else for(var s=1,r=t.length;s<r;++s)Ot[s]=(s%2==1?i:n)*t[s];return Ot}function It(t,i,n,e,s,r){var o,h,a,l,c,u=null,_=0,f=0,d=0,p=0;null==n&&(n=0),null==e&&(e=0),null==s&&(s=1),null==r&&(r=s),t.beginPath&&t.beginPath();for(var y=0,x=i.length;y<x;++y){switch(o=i[y],1===s&&1===r||(o=Dt(o,s,r)),o[0]){case"l":_+=o[1],f+=o[2],t.lineTo(_+n,f+e);break;case"L":_=o[1],f=o[2],t.lineTo(_+n,f+e);break;case"h":_+=o[1],t.lineTo(_+n,f+e);break;case"H":_=o[1],t.lineTo(_+n,f+e);break;case"v":f+=o[1],t.lineTo(_+n,f+e);break;case"V":f=o[1],t.lineTo(_+n,f+e);break;case"m":_+=o[1],f+=o[2],t.moveTo(_+n,f+e);break;case"M":_=o[1],f=o[2],t.moveTo(_+n,f+e);break;case"c":h=_+o[5],a=f+o[6],d=_+o[3],p=f+o[4],t.bezierCurveTo(_+o[1]+n,f+o[2]+e,d+n,p+e,h+n,a+e),_=h,f=a;break;case"C":_=o[5],f=o[6],d=o[3],p=o[4],t.bezierCurveTo(o[1]+n,o[2]+e,d+n,p+e,_+n,f+e);break;case"s":h=_+o[3],a=f+o[4],d=2*_-d,p=2*f-p,t.bezierCurveTo(d+n,p+e,_+o[1]+n,f+o[2]+e,h+n,a+e),d=_+o[1],p=f+o[2],_=h,f=a;break;case"S":h=o[3],a=o[4],d=2*_-d,p=2*f-p,t.bezierCurveTo(d+n,p+e,o[1]+n,o[2]+e,h+n,a+e),_=h,f=a,d=o[1],p=o[2];break;case"q":h=_+o[3],a=f+o[4],d=_+o[1],p=f+o[2],t.quadraticCurveTo(d+n,p+e,h+n,a+e),_=h,f=a;break;case"Q":h=o[3],a=o[4],t.quadraticCurveTo(o[1]+n,o[2]+e,h+n,a+e),_=h,f=a,d=o[1],p=o[2];break;case"t":h=_+o[1],a=f+o[2],null===u[0].match(/[QqTt]/)?(d=_,p=f):"t"===u[0]?(d=2*_-l,p=2*f-c):"q"===u[0]&&(d=2*_-d,p=2*f-p),l=d,c=p,t.quadraticCurveTo(d+n,p+e,h+n,a+e),f=a,d=(_=h)+o[1],p=f+o[2];break;case"T":h=o[1],a=o[2],d=2*_-d,p=2*f-p,t.quadraticCurveTo(d+n,p+e,h+n,a+e),_=h,f=a;break;case"a":$t(t,_+n,f+e,[o[1],o[2],o[3],o[4],o[5],o[6]+_+n,o[7]+f+e]),_+=o[6],f+=o[7];break;case"A":$t(t,_+n,f+e,[o[1],o[2],o[3],o[4],o[5],o[6]+n,o[7]+e]),_=o[6],f=o[7];break;case"z":case"Z":t.closePath()}u=o}}function $t(t,i,n,e){const s=function(t,i,n,e,s,r,o,h,a){const l=Lt.call(arguments);if(Pt[l])return Pt[l];const c=o*Ct,u=Math.sin(c),_=Math.cos(c),f=_*(h-t)*.5+u*(a-i)*.5,d=_*(a-i)*.5-u*(h-t)*.5;let p=f*f/((n=Math.abs(n))*n)+d*d/((e=Math.abs(e))*e);p>1&&(p=Math.sqrt(p),n*=p,e*=p);const y=_/n,x=u/n,g=-u/e,v=_/e,m=y*h+x*a,b=g*h+v*a,k=y*t+x*i,w=g*t+v*i;let T=1/((k-m)*(k-m)+(w-b)*(w-b))-.25;T<0&&(T=0);let M=Math.sqrt(T);r==s&&(M=-M);const A=.5*(m+k)-M*(w-b),S=.5*(b+w)+M*(k-m),C=Math.atan2(b-S,m-A);let N=Math.atan2(w-S,k-A)-C;N<0&&1===r?N+=zt:N>0&&0===r&&(N-=zt);const z=Math.ceil(Math.abs(N/(Nt+.001))),R=[];for(let t=0;t<z;++t){const i=C+t*N/z,s=C+(t+1)*N/z;R[t]=[A,S,i,s,n,e,u,_]}return Pt[l]=R}(e[5],e[6],e[0],e[1],e[3],e[4],e[2],i,n);for(let i=0;i<s.length;++i){const n=qt(s[i]);t.bezierCurveTo(n[0],n[1],n[2],n[3],n[4],n[5])}}const Vt=.5773502691896257,Ht={circle:{draw:function(t,i){const n=Math.sqrt(i)/2;t.moveTo(n,0),t.arc(0,0,n,0,zt)}},cross:{draw:function(t,i){var n=Math.sqrt(i)/2,e=n/2.5;t.moveTo(-n,-e),t.lineTo(-n,e),t.lineTo(-e,e),t.lineTo(-e,n),t.lineTo(e,n),t.lineTo(e,e),t.lineTo(n,e),t.lineTo(n,-e),t.lineTo(e,-e),t.lineTo(e,-n),t.lineTo(-e,-n),t.lineTo(-e,-e),t.closePath()}},diamond:{draw:function(t,i){const n=Math.sqrt(i)/2;t.moveTo(-n,0),t.lineTo(0,-n),t.lineTo(n,0),t.lineTo(0,n),t.closePath()}},square:{draw:function(t,i){var n=Math.sqrt(i),e=-n/2;t.rect(e,e,n,n)}},arrow:{draw:function(t,i){var n=Math.sqrt(i)/2,e=n/7,s=n/2.5,r=n/8;t.moveTo(-e,n),t.lineTo(e,n),t.lineTo(e,-r),t.lineTo(s,-r),t.lineTo(0,-n),t.lineTo(-s,-r),t.lineTo(-e,-r),t.closePath()}},wedge:{draw:function(t,i){var n=Math.sqrt(i)/2,e=Rt*n,s=e-n*Vt,r=n/4;t.moveTo(0,-e-s),t.lineTo(-r,e-s),t.lineTo(r,e-s),t.closePath()}},triangle:{draw:function(t,i){var n=Math.sqrt(i)/2,e=Rt*n,s=e-n*Vt;t.moveTo(0,-e-s),t.lineTo(-n,e-s),t.lineTo(n,e-s),t.closePath()}},"triangle-up":{draw:function(t,i){var n=Math.sqrt(i)/2,e=Rt*n;t.moveTo(0,-e),t.lineTo(-n,e),t.lineTo(n,e),t.closePath()}},"triangle-down":{draw:function(t,i){var n=Math.sqrt(i)/2,e=Rt*n;t.moveTo(0,e),t.lineTo(-n,-e),t.lineTo(n,-e),t.closePath()}},"triangle-right":{draw:function(t,i){var n=Math.sqrt(i)/2,e=Rt*n;t.moveTo(e,0),t.lineTo(-e,-n),t.lineTo(-e,n),t.closePath()}},"triangle-left":{draw:function(t,i){var n=Math.sqrt(i)/2,e=Rt*n;t.moveTo(-e,0),t.lineTo(e,-n),t.lineTo(e,n),t.closePath()}},stroke:{draw:function(t,i){const n=Math.sqrt(i)/2;t.moveTo(-n,0),t.lineTo(n,0)}}};function jt(t){return i.hasOwnProperty(Ht,t)?Ht[t]:function(t){if(!i.hasOwnProperty(Bt,t)){const i=St(t);Bt[t]={draw:function(t,n){It(t,i,0,0,Math.sqrt(n)/2)}}}return Bt[t]}(t)}var Bt={};const Gt=.448084975506;function Wt(t){return t.x}function Xt(t){return t.y}function Ut(t){return t.width}function Ft(t){return t.height}function Yt(t){return"function"==typeof t?t:()=>+t}function Jt(t,i,n){return Math.max(i,Math.min(t,n))}function Zt(){var t=Wt,i=Xt,n=Ut,e=Ft,s=Yt(0),r=s,o=s,h=s,a=null;function l(l,c,u){var _,f=null!=c?c:+t.call(this,l),d=null!=u?u:+i.call(this,l),y=+n.call(this,l),x=+e.call(this,l),g=Math.min(y,x)/2,v=Jt(+s.call(this,l),0,g),m=Jt(+r.call(this,l),0,g),b=Jt(+o.call(this,l),0,g),k=Jt(+h.call(this,l),0,g);if(a||(a=_=p()),v<=0&&m<=0&&b<=0&&k<=0)a.rect(f,d,y,x);else{var w=f+y,T=d+x;a.moveTo(f+v,d),a.lineTo(w-m,d),a.bezierCurveTo(w-Gt*m,d,w,d+Gt*m,w,d+m),a.lineTo(w,T-k),a.bezierCurveTo(w,T-Gt*k,w-Gt*k,T,w-k,T),a.lineTo(f+b,T),a.bezierCurveTo(f+Gt*b,T,f,T-Gt*b,f,T-b),a.lineTo(f,d+v),a.bezierCurveTo(f,d+Gt*v,f+Gt*v,d,f+v,d),a.closePath()}if(_)return a=null,_+""||null}return l.x=function(i){return arguments.length?(t=Yt(i),l):t},l.y=function(t){return arguments.length?(i=Yt(t),l):i},l.width=function(t){return arguments.length?(n=Yt(t),l):n},l.height=function(t){return arguments.length?(e=Yt(t),l):e},l.cornerRadius=function(t,i,n,e){return arguments.length?(s=Yt(t),r=null!=i?Yt(i):s,h=null!=n?Yt(n):s,o=null!=e?Yt(e):r,l):s},l.context=function(t){return arguments.length?(a=null==t?null:t,l):a},l}function Qt(){var t,i,n,e,s,r,o,h,a=null;function l(t,i,n){const e=n/2;if(s){var l=o-i,c=t-r;if(l||c){var u=Math.sqrt(l*l+c*c),_=(l/=u)*h,f=(c/=u)*h,d=Math.atan2(c,l);a.moveTo(r-_,o-f),a.lineTo(t-l*e,i-c*e),a.arc(t,i,e,d-Math.PI,d),a.lineTo(r+_,o+f),a.arc(r,o,h,d,d+Math.PI)}else a.arc(t,i,e,0,zt);a.closePath()}else s=1;r=t,o=i,h=e}function c(r){var o,h,c,u=r.length,_=!1;for(null==a&&(a=c=p()),o=0;o<=u;++o)!(o<u&&e(h=r[o],o,r))===_&&(_=!_)&&(s=0),_&&l(+t(h,o,r),+i(h,o,r),+n(h,o,r));if(c)return a=null,c+""||null}return c.x=function(i){return arguments.length?(t=i,c):t},c.y=function(t){return arguments.length?(i=t,c):i},c.size=function(t){return arguments.length?(n=t,c):n},c.defined=function(t){return arguments.length?(e=t,c):e},c.context=function(t){return arguments.length?(a=null==t?null:t,c):a},c}function Kt(t,i){return null!=t?t:i}const ti=t=>t.x||0,ii=t=>t.y||0,ni=t=>!(!1===t.defined),ei=function(){var t=z,i=R,n=y(0),e=null,s=P,r=E,o=L,h=null;function a(){var a,l,c=+t.apply(this,arguments),u=+i.apply(this,arguments),_=s.apply(this,arguments)-A,f=r.apply(this,arguments)-A,d=x(f-_),y=f>_;if(h||(h=a=p()),u<c&&(l=u,u=c,c=l),u>T)if(d>S-T)h.moveTo(u*v(_),u*k(_)),h.arc(0,0,u,_,f,!y),c>T&&(h.moveTo(c*v(f),c*k(f)),h.arc(0,0,c,f,_,y));else{var m,z,R=_,P=f,E=_,L=f,D=d,I=d,$=o.apply(this,arguments)/2,V=$>T&&(e?+e.apply(this,arguments):w(c*c+u*u)),H=b(x(u-c)/2,+n.apply(this,arguments)),j=H,B=H;if(V>T){var G=N(V/c*k($)),W=N(V/u*k($));(D-=2*G)>T?(E+=G*=y?1:-1,L-=G):(D=0,E=L=(_+f)/2),(I-=2*W)>T?(R+=W*=y?1:-1,P-=W):(I=0,R=P=(_+f)/2)}var X=u*v(R),U=u*k(R),F=c*v(L),Y=c*k(L);if(H>T){var J,Z=u*v(P),Q=u*k(P),K=c*v(E),tt=c*k(E);if(d<M&&(J=q(X,U,K,tt,Z,Q,F,Y))){var it=X-J[0],nt=U-J[1],et=Z-J[0],st=Q-J[1],rt=1/k(C((it*et+nt*st)/(w(it*it+nt*nt)*w(et*et+st*st)))/2),ot=w(J[0]*J[0]+J[1]*J[1]);j=b(H,(c-ot)/(rt-1)),B=b(H,(u-ot)/(rt+1))}}I>T?B>T?(m=O(K,tt,X,U,u,B,y),z=O(Z,Q,F,Y,u,B,y),h.moveTo(m.cx+m.x01,m.cy+m.y01),B<H?h.arc(m.cx,m.cy,B,g(m.y01,m.x01),g(z.y01,z.x01),!y):(h.arc(m.cx,m.cy,B,g(m.y01,m.x01),g(m.y11,m.x11),!y),h.arc(0,0,u,g(m.cy+m.y11,m.cx+m.x11),g(z.cy+z.y11,z.cx+z.x11),!y),h.arc(z.cx,z.cy,B,g(z.y11,z.x11),g(z.y01,z.x01),!y))):(h.moveTo(X,U),h.arc(0,0,u,R,P,!y)):h.moveTo(X,U),c>T&&D>T?j>T?(m=O(F,Y,Z,Q,c,-j,y),z=O(X,U,K,tt,c,-j,y),h.lineTo(m.cx+m.x01,m.cy+m.y01),j<H?h.arc(m.cx,m.cy,j,g(m.y01,m.x01),g(z.y01,z.x01),!y):(h.arc(m.cx,m.cy,j,g(m.y01,m.x01),g(m.y11,m.x11),!y),h.arc(0,0,c,g(m.cy+m.y11,m.cx+m.x11),g(z.cy+z.y11,z.cx+z.x11),y),h.arc(z.cx,z.cy,j,g(z.y11,z.x11),g(z.y01,z.x01),!y))):h.arc(0,0,c,L,E,y):h.lineTo(F,Y)}else h.moveTo(0,0);if(h.closePath(),a)return h=null,a+""||null}return a.centroid=function(){var n=(+t.apply(this,arguments)+ +i.apply(this,arguments))/2,e=(+s.apply(this,arguments)+ +r.apply(this,arguments))/2-M/2;return[v(e)*n,k(e)*n]},a.innerRadius=function(i){return arguments.length?(t="function"==typeof i?i:y(+i),a):t},a.outerRadius=function(t){return arguments.length?(i="function"==typeof t?t:y(+t),a):i},a.cornerRadius=function(t){return arguments.length?(n="function"==typeof t?t:y(+t),a):n},a.padRadius=function(t){return arguments.length?(e=null==t?null:"function"==typeof t?t:y(+t),a):e},a.startAngle=function(t){return arguments.length?(s="function"==typeof t?t:y(+t),a):s},a.endAngle=function(t){return arguments.length?(r="function"==typeof t?t:y(+t),a):r},a.padAngle=function(t){return arguments.length?(o="function"==typeof t?t:y(+t),a):o},a.context=function(t){return arguments.length?(h=null==t?null:t,a):h},a}().startAngle((t=>t.startAngle||0)).endAngle((t=>t.endAngle||0)).padAngle((t=>t.padAngle||0)).innerRadius((t=>t.innerRadius||0)).outerRadius((t=>t.outerRadius||0)).cornerRadius((t=>t.cornerRadius||0)),si=B().x(ti).y1(ii).y0((t=>(t.y||0)+(t.height||0))).defined(ni),ri=B().y(ii).x1(ti).x0((t=>(t.x||0)+(t.width||0))).defined(ni),oi=j().x(ti).y(ii).defined(ni),hi=Zt().x(ti).y(ii).width((t=>t.width||0)).height((t=>t.height||0)).cornerRadius((t=>Kt(t.cornerRadiusTopLeft,t.cornerRadius)||0),(t=>Kt(t.cornerRadiusTopRight,t.cornerRadius)||0),(t=>Kt(t.cornerRadiusBottomRight,t.cornerRadius)||0),(t=>Kt(t.cornerRadiusBottomLeft,t.cornerRadius)||0)),ai=function(t,i){var n=null;function e(){var e;if(n||(n=e=p()),t.apply(this,arguments).draw(n,+i.apply(this,arguments)),e)return n=null,e+""||null}return t="function"==typeof t?t:y(t||G),i="function"==typeof i?i:y(void 0===i?64:+i),e.type=function(i){return arguments.length?(t="function"==typeof i?i:y(i),e):t},e.size=function(t){return arguments.length?(i="function"==typeof t?t:y(+t),e):i},e.context=function(t){return arguments.length?(n=null==t?null:t,e):n},e}().type((t=>jt(t.shape||"circle"))).size((t=>Kt(t.size,64))),li=Qt().x(ti).y(ii).defined(ni).size((t=>t.size||1));function ci(t){return t.cornerRadius||t.cornerRadiusTopLeft||t.cornerRadiusTopRight||t.cornerRadiusBottomRight||t.cornerRadiusBottomLeft}function ui(t,i,n,e){return hi.context(t)(i,n,e)}var _i=1;function fi(){_i=1}function di(t,n,e){var s=n.clip,r=t._defs,o=n.clip_id||(n.clip_id="clip"+_i++),h=r.clipping[o]||(r.clipping[o]={id:o});return i.isFunction(s)?h.path=s(null):ci(e)?h.path=ui(null,e,0,0):(h.width=e.width||0,h.height=e.height||0),"url(#"+o+")"}function pi(t){this.clear(),t&&this.union(t)}function yi(t){this.mark=t,this.bounds=this.bounds||new pi}function xi(t){yi.call(this,t),this.items=this.items||[]}function gi(t){this._pending=0,this._loader=t||e.loader()}function vi(t){t._pending+=1}function mi(t){t._pending-=1}function bi(t,i,n){if(i.stroke&&0!==i.opacity&&0!==i.strokeOpacity){const e=null!=i.strokeWidth?+i.strokeWidth:1;t.expand(e+(n?function(t,i){return t.strokeJoin&&"miter"!==t.strokeJoin?0:i}(i,e):0))}return t}pi.prototype={clone(){return new pi(this)},clear(){return this.x1=+Number.MAX_VALUE,this.y1=+Number.MAX_VALUE,this.x2=-Number.MAX_VALUE,this.y2=-Number.MAX_VALUE,this},empty(){return this.x1===+Number.MAX_VALUE&&this.y1===+Number.MAX_VALUE&&this.x2===-Number.MAX_VALUE&&this.y2===-Number.MAX_VALUE},equals(t){return this.x1===t.x1&&this.y1===t.y1&&this.x2===t.x2&&this.y2===t.y2},set(t,i,n,e){return n<t?(this.x2=t,this.x1=n):(this.x1=t,this.x2=n),e<i?(this.y2=i,this.y1=e):(this.y1=i,this.y2=e),this},add(t,i){return t<this.x1&&(this.x1=t),i<this.y1&&(this.y1=i),t>this.x2&&(this.x2=t),i>this.y2&&(this.y2=i),this},expand(t){return this.x1-=t,this.y1-=t,this.x2+=t,this.y2+=t,this},round(){return this.x1=Math.floor(this.x1),this.y1=Math.floor(this.y1),this.x2=Math.ceil(this.x2),this.y2=Math.ceil(this.y2),this},scale(t){return this.x1*=t,this.y1*=t,this.x2*=t,this.y2*=t,this},translate(t,i){return this.x1+=t,this.x2+=t,this.y1+=i,this.y2+=i,this},rotate(t,i,n){const e=this.rotatedPoints(t,i,n);return this.clear().add(e[0],e[1]).add(e[2],e[3]).add(e[4],e[5]).add(e[6],e[7])},rotatedPoints(t,i,n){var{x1:e,y1:s,x2:r,y2:o}=this,h=Math.cos(t),a=Math.sin(t),l=i-i*h+n*a,c=n-i*a-n*h;return[h*e-a*s+l,a*e+h*s+c,h*e-a*o+l,a*e+h*o+c,h*r-a*s+l,a*r+h*s+c,h*r-a*o+l,a*r+h*o+c]},union(t){return t.x1<this.x1&&(this.x1=t.x1),t.y1<this.y1&&(this.y1=t.y1),t.x2>this.x2&&(this.x2=t.x2),t.y2>this.y2&&(this.y2=t.y2),this},intersect(t){return t.x1>this.x1&&(this.x1=t.x1),t.y1>this.y1&&(this.y1=t.y1),t.x2<this.x2&&(this.x2=t.x2),t.y2<this.y2&&(this.y2=t.y2),this},encloses(t){return t&&this.x1<=t.x1&&this.x2>=t.x2&&this.y1<=t.y1&&this.y2>=t.y2},alignsWith(t){return t&&(this.x1==t.x1||this.x2==t.x2||this.y1==t.y1||this.y2==t.y2)},intersects(t){return t&&!(this.x2<t.x1||this.x1>t.x2||this.y2<t.y1||this.y1>t.y2)},contains(t,i){return!(t<this.x1||t>this.x2||i<this.y1||i>this.y2)},width(){return this.x2-this.x1},height(){return this.y2-this.y1}},i.inherits(xi,yi),gi.prototype={pending(){return this._pending},sanitizeURL(t){const i=this;return vi(i),i._loader.sanitize(t,{context:"href"}).then((t=>(mi(i),t))).catch((()=>(mi(i),null)))},loadImage(t){const e=this,s=n.image();return vi(e),e._loader.sanitize(t,{context:"image"}).then((t=>{const n=t.href;if(!n||!s)throw{url:n};const r=new s,o=i.hasOwnProperty(t,"crossOrigin")?t.crossOrigin:"anonymous";return null!=o&&(r.crossOrigin=o),r.onload=()=>mi(e),r.onerror=()=>mi(e),r.src=n,r})).catch((t=>(mi(e),{complete:!1,width:0,height:0,src:t&&t.url||""})))},ready(){const t=this;return new Promise((i=>{!function n(e){t.pending()?setTimeout((()=>{n(!0)}),10):i(e)}(!1)}))}};const ki=zt-1e-8;let wi,Ti,Mi,Ai,Si,Ci,Ni,zi;const Ri=(t,i)=>wi.add(t,i),Pi=(t,i)=>Ri(Ti=t,Mi=i),Ei=t=>Ri(t,wi.y1),Li=t=>Ri(wi.x1,t),qi=(t,i)=>Si*t+Ni*i,Oi=(t,i)=>Ci*t+zi*i,Di=(t,i)=>Ri(qi(t,i),Oi(t,i)),Ii=(t,i)=>Pi(qi(t,i),Oi(t,i));function $i(t,i){return wi=t,i?(Ai=i*Ct,Si=zi=Math.cos(Ai),Ci=Math.sin(Ai),Ni=-Ci):(Si=zi=1,Ai=Ci=Ni=0),Vi}const Vi={beginPath(){},closePath(){},moveTo:Ii,lineTo:Ii,rect(t,i,n,e){Ai?(Di(t+n,i),Di(t+n,i+e),Di(t,i+e),Ii(t,i)):(Ri(t+n,i+e),Pi(t,i))},quadraticCurveTo(t,i,n,e){const s=qi(t,i),r=Oi(t,i),o=qi(n,e),h=Oi(n,e);Hi(Ti,s,o,Ei),Hi(Mi,r,h,Li),Pi(o,h)},bezierCurveTo(t,i,n,e,s,r){const o=qi(t,i),h=Oi(t,i),a=qi(n,e),l=Oi(n,e),c=qi(s,r),u=Oi(s,r);ji(Ti,o,a,c,Ei),ji(Mi,h,l,u,Li),Pi(c,u)},arc(t,i,n,e,s,r){if(e+=Ai,s+=Ai,Ti=n*Math.cos(s)+t,Mi=n*Math.sin(s)+i,Math.abs(s-e)>ki)Ri(t-n,i-n),Ri(t+n,i+n);else{const o=e=>Ri(n*Math.cos(e)+t,n*Math.sin(e)+i);let h,a;if(o(e),o(s),s!==e)if((e%=zt)<0&&(e+=zt),(s%=zt)<0&&(s+=zt),s<e&&(r=!r,h=e,e=s,s=h),r)for(s-=zt,h=e-e%Nt,a=0;a<4&&h>s;++a,h-=Nt)o(h);else for(h=e-e%Nt+Nt,a=0;a<4&&h<s;++a,h+=Nt)o(h)}}};function Hi(t,i,n,e){const s=(t-i)/(t+n-2*i);0<s&&s<1&&e(t+(i-t)*s)}function ji(t,i,n,e,s){const r=e-t+3*i-3*n,o=t+n-2*i,h=t-i;let a,l=0,c=0;Math.abs(r)>1e-14?(a=o*o+h*r,a>=0&&(a=Math.sqrt(a),l=(-o+a)/r,c=(-o-a)/r)):l=.5*h/o,0<l&&l<1&&s(Bi(l,t,i,n,e)),0<c&&c<1&&s(Bi(c,t,i,n,e))}function Bi(t,i,n,e,s){const r=1-t,o=r*r,h=t*t;return o*r*i+3*o*t*n+3*r*h*e+h*t*s}var Gi=(Gi=n.canvas(1,1))?Gi.getContext("2d"):null;const Wi=new pi;function Xi(t){return function(i,n){if(!Gi)return!0;t(Gi,i),Wi.clear().union(i.bounds).intersect(n).round();const{x1:e,y1:s,x2:r,y2:o}=Wi;for(let t=s;t<=o;++t)for(let i=e;i<=r;++i)if(Gi.isPointInPath(i,t))return!0;return!1}}function Ui(t,i){return i.contains(t.x||0,t.y||0)}function Fi(t,i){const n=t.x||0,e=t.y||0,s=t.width||0,r=t.height||0;return i.intersects(Wi.set(n,e,n+s,e+r))}function Yi(t,i){const n=t.x||0,e=t.y||0;return Ji(i,n,e,null!=t.x2?t.x2:n,null!=t.y2?t.y2:e)}function Ji(t,i,n,e,s){const{x1:r,y1:o,x2:h,y2:a}=t,l=e-i,c=s-n;let u,_,f,d,p=0,y=1;for(d=0;d<4;++d){if(0===d&&(u=-l,_=-(r-i)),1===d&&(u=l,_=h-i),2===d&&(u=-c,_=-(o-n)),3===d&&(u=c,_=a-n),Math.abs(u)<1e-10&&_<0)return!1;if(f=_/u,u<0){if(f>y)return!1;f>p&&(p=f)}else if(u>0){if(f<p)return!1;f<y&&(y=f)}}return!0}function Zi(t,i){t.globalCompositeOperation=i.blend||"source-over"}function Qi(t,i){return null==t?i:t}function Ki(t,i){const n=i.length;for(let e=0;e<n;++e)t.addColorStop(i[e].offset,i[e].color);return t}function tn(t,i,e){const s=e.width(),r=e.height();let o;if("radial"===i.gradient)o=t.createRadialGradient(e.x1+Qi(i.x1,.5)*s,e.y1+Qi(i.y1,.5)*r,Math.max(s,r)*Qi(i.r1,0),e.x1+Qi(i.x2,.5)*s,e.y1+Qi(i.y2,.5)*r,Math.max(s,r)*Qi(i.r2,.5));else{const h=Qi(i.x1,0),a=Qi(i.y1,0),l=Qi(i.x2,1),c=Qi(i.y2,0);if(h!==l&&a!==c&&s!==r){const e=n.canvas(Math.ceil(s),Math.ceil(r)),o=e.getContext("2d");return o.scale(s,r),o.fillStyle=Ki(o.createLinearGradient(h,a,l,c),i.stops),o.fillRect(0,0,s,r),t.createPattern(e,"no-repeat")}o=t.createLinearGradient(e.x1+h*s,e.y1+a*r,e.x1+l*s,e.y1+c*r)}return Ki(o,i.stops)}function nn(t,i,n){return h(n)?tn(t,n,i.bounds):n}function en(t,i,n){return(n*=null==i.fillOpacity?1:i.fillOpacity)>0&&(t.globalAlpha=n,t.fillStyle=nn(t,i,i.fill),!0)}var sn=[];function rn(t,i,n){var e=null!=(e=i.strokeWidth)?e:1;return!(e<=0)&&((n*=null==i.strokeOpacity?1:i.strokeOpacity)>0&&(t.globalAlpha=n,t.strokeStyle=nn(t,i,i.stroke),t.lineWidth=e,t.lineCap=i.strokeCap||"butt",t.lineJoin=i.strokeJoin||"miter",t.miterLimit=i.strokeMiterLimit||10,t.setLineDash&&(t.setLineDash(i.strokeDash||sn),t.lineDashOffset=i.strokeDashOffset||0),!0))}function on(t,i){return t.zindex-i.zindex||t.index-i.index}function hn(t){if(!t.zdirty)return t.zitems;var i,n,e,s=t.items,r=[];for(n=0,e=s.length;n<e;++n)(i=s[n]).index=n,i.zindex&&r.push(i);return t.zdirty=!1,t.zitems=r.sort(on)}function an(t,i){var n,e,s=t.items;if(!s||!s.length)return;const r=hn(t);if(r&&r.length){for(n=0,e=s.length;n<e;++n)s[n].zindex||i(s[n]);s=r}for(n=0,e=s.length;n<e;++n)i(s[n])}function ln(t,i){var n,e,s=t.items;if(!s||!s.length)return null;const r=hn(t);for(r&&r.length&&(s=r),e=s.length;--e>=0;)if(n=i(s[e]))return n;if(s===r)for(e=(s=t.items).length;--e>=0;)if(!s[e].zindex&&(n=i(s[e])))return n;return null}function cn(t){return function(i,n,e){an(n,(n=>{e&&!e.intersects(n.bounds)||_n(t,i,n,n)}))}}function un(t){return function(i,n,e){!n.items.length||e&&!e.intersects(n.bounds)||_n(t,i,n.items[0],n.items)}}function _n(t,i,n,e){var s=null==n.opacity?1:n.opacity;0!==s&&(t(i,e)||(Zi(i,n),n.fill&&en(i,n,s)&&i.fill(),n.stroke&&rn(i,n,s)&&i.stroke()))}function fn(t){return t=t||i.truthy,function(i,n,e,s,r,o){return e*=i.pixelRatio,s*=i.pixelRatio,ln(n,(n=>{const h=n.bounds;if((!h||h.contains(r,o))&&h)return t(i,n,e,s,r,o)?n:void 0}))}}function dn(t,i){return function(n,e,s,r){var o,h,a=Array.isArray(e)?e[0]:e,l=null==i?a.fill:i,c=a.stroke&&n.isPointInStroke;return c&&(o=a.strokeWidth,h=a.strokeCap,n.lineWidth=null!=o?o:1,n.lineCap=null!=h?h:"butt"),!t(n,e)&&(l&&n.isPointInPath(s,r)||c&&n.isPointInStroke(s,r))}}function pn(t){return fn(dn(t))}function yn(t,i){return"translate("+t+","+i+")"}function xn(t){return"rotate("+t+")"}function gn(t){return yn(t.x||0,t.y||0)}function vn(t,i,n){function e(t,n){var e=n.x||0,s=n.y||0,r=n.angle||0;t.translate(e,s),r&&t.rotate(r*=Ct),t.beginPath(),i(t,n),r&&t.rotate(-r),t.translate(-e,-s)}return{type:t,tag:"path",nested:!1,attr:function(t,n){t("transform",function(t){return yn(t.x||0,t.y||0)+(t.angle?" "+xn(t.angle):"")}(n)),t("d",i(null,n))},bound:function(t,n){return i($i(t,n.angle),n),bi(t,n).translate(n.x||0,n.y||0)},draw:cn(e),pick:pn(e),isect:n||Xi(e)}}var mn=vn("arc",(function(t,i){return ei.context(t)(i)}));function bn(t,i,n){function e(t,n){t.beginPath(),i(t,n)}const s=dn(e);return{type:t,tag:"path",nested:!0,attr:function(t,n){var e=n.mark.items;e.length&&t("d",i(null,e))},bound:function(t,n){var e=n.items;return 0===e.length?t:(i($i(t),e),bi(t,e[0]))},draw:un(e),pick:function(t,i,n,e,r,o){var h=i.items,a=i.bounds;return!h||!h.length||a&&!a.contains(r,o)?null:(n*=t.pixelRatio,e*=t.pixelRatio,s(t,h,n,e)?h[0]:null)},isect:Ui,tip:n}}var kn=bn("area",(function(t,i){const n=i[0],e=n.interpolate||"linear";return("horizontal"===n.orient?ri:si).curve(Tt(e,n.orient,n.tension)).context(t)(i)}),(function(t,i){for(var n,e,s="horizontal"===t[0].orient?i[1]:i[0],r="horizontal"===t[0].orient?"y":"x",o=t.length,h=1/0;--o>=0;)!1!==t[o].defined&&(e=Math.abs(t[o][r]-s))<h&&(h=e,n=t[o]);return n}));function wn(t,i){t.beginPath(),ci(i)?ui(t,i,0,0):t.rect(0,0,i.width||0,i.height||0),t.clip()}function Tn(t){const i=Qi(t.strokeWidth,1);return null!=t.strokeOffset?t.strokeOffset:t.stroke&&i>.5&&i<1.5?.5-Math.abs(i-1):0}function Mn(t,i){const n=Tn(i);t("d",ui(null,i,n,n))}function An(t,i,n,e){const s=Tn(i);t.beginPath(),ui(t,i,(n||0)+s,(e||0)+s)}const Sn=dn(An),Cn=dn(An,!1),Nn=dn(An,!0);var zn={type:"group",tag:"g",nested:!1,attr:function(t,i){t("transform",gn(i))},bound:function(t,i){if(!i.clip&&i.items){const n=i.items,e=n.length;for(let i=0;i<e;++i)t.union(n[i].bounds)}return(i.clip||i.width||i.height)&&!i.noBound&&t.add(0,0).add(i.width||0,i.height||0),bi(t,i),t.translate(i.x||0,i.y||0)},draw:function(t,i,n){an(i,(i=>{const e=i.x||0,s=i.y||0,r=i.strokeForeground,o=null==i.opacity?1:i.opacity;(i.stroke||i.fill)&&o&&(An(t,i,e,s),Zi(t,i),i.fill&&en(t,i,o)&&t.fill(),i.stroke&&!r&&rn(t,i,o)&&t.stroke()),t.save(),t.translate(e,s),i.clip&&wn(t,i),n&&n.translate(-e,-s),an(i,(i=>{this.draw(t,i,n)})),n&&n.translate(e,s),t.restore(),r&&i.stroke&&o&&(An(t,i,e,s),Zi(t,i),rn(t,i,o)&&t.stroke())}))},pick:function(t,i,n,e,s,r){if(i.bounds&&!i.bounds.contains(s,r)||!i.items)return null;const o=n*t.pixelRatio,h=e*t.pixelRatio;return ln(i,(a=>{let l,c,u;const _=a.bounds;if(_&&!_.contains(s,r))return;c=a.x||0,u=a.y||0;const f=c+(a.width||0),d=u+(a.height||0),p=a.clip;if(p&&(s<c||s>f||r<u||r>d))return;if(t.save(),t.translate(c,u),c=s-c,u=r-u,p&&ci(a)&&!Nn(t,a,o,h))return t.restore(),null;const y=a.strokeForeground,x=!1!==i.interactive;return x&&y&&a.stroke&&Cn(t,a,o,h)?(t.restore(),a):(l=ln(a,(t=>function(t,i,n){return(!1!==t.interactive||"group"===t.marktype)&&t.bounds&&t.bounds.contains(i,n)}(t,c,u)?this.pick(t,n,e,c,u):null)),!l&&x&&(a.fill||!y&&a.stroke)&&Sn(t,a,o,h)&&(l=a),t.restore(),l||null)}))},isect:Fi,content:function(t,i,n){t("clip-path",i.clip?di(n,i,i):null)},background:function(t,i){t("class","background"),t("aria-hidden",!0),Mn(t,i)},foreground:function(t,i){t("class","foreground"),t("aria-hidden",!0),i.strokeForeground?Mn(t,i):t("d","")}},Rn={xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",version:"1.1"};function Pn(t,i){var n=t.image;return(!n||t.url&&t.url!==n.url)&&(n={complete:!1,width:0,height:0},i.loadImage(t.url).then((i=>{t.image=i,t.image.url=t.url}))),n}function En(t,i){return null!=t.width?t.width:i&&i.width?!1!==t.aspect&&t.height?t.height*i.width/i.height:i.width:0}function Ln(t,i){return null!=t.height?t.height:i&&i.height?!1!==t.aspect&&t.width?t.width*i.height/i.width:i.height:0}function qn(t,i){return"center"===t?i/2:"right"===t?i:0}function On(t,i){return"middle"===t?i/2:"bottom"===t?i:0}var Dn={type:"image",tag:"image",nested:!1,attr:function(t,i,n){const e=Pn(i,n),s=En(i,e),r=Ln(i,e),o=(i.x||0)-qn(i.align,s),h=(i.y||0)-On(i.baseline,r);t("href",!e.src&&e.toDataURL?e.toDataURL():e.src||"",Rn["xmlns:xlink"],"xlink:href"),t("transform",yn(o,h)),t("width",s),t("height",r),t("preserveAspectRatio",!1===i.aspect?"none":"xMidYMid")},bound:function(t,i){const n=i.image,e=En(i,n),s=Ln(i,n),r=(i.x||0)-qn(i.align,e),o=(i.y||0)-On(i.baseline,s);return t.set(r,o,r+e,o+s)},draw:function(t,i,n){an(i,(i=>{if(n&&!n.intersects(i.bounds))return;const e=Pn(i,this);let s=En(i,e),r=Ln(i,e);if(0===s||0===r)return;let o,h,a,l,c=(i.x||0)-qn(i.align,s),u=(i.y||0)-On(i.baseline,r);!1!==i.aspect&&(h=e.width/e.height,a=i.width/i.height,h==h&&a==a&&h!==a&&(a<h?(l=s/h,u+=(r-l)/2,r=l):(l=r*h,c+=(s-l)/2,s=l))),(e.complete||e.toDataURL)&&(Zi(t,i),t.globalAlpha=null!=(o=i.opacity)?o:1,t.imageSmoothingEnabled=!1!==i.smooth,t.drawImage(e,c,u,s,r))}))},pick:fn(),isect:i.truthy,get:Pn,xOffset:qn,yOffset:On},In=bn("line",(function(t,i){const n=i[0],e=n.interpolate||"linear";return oi.curve(Tt(e,n.orient,n.tension)).context(t)(i)}),(function(t,i){for(var n,e,s=Math.pow(t[0].strokeWidth||1,2),r=t.length;--r>=0;)if(!1!==t[r].defined&&(n=t[r].x-i[0])*n+(e=t[r].y-i[1])*e<s)return t[r];return null}));function $n(t,i){var n=i.path;if(null==n)return!0;var e=i.x||0,s=i.y||0,r=i.scaleX||1,o=i.scaleY||1,h=(i.angle||0)*Ct,a=i.pathCache;a&&a.path===n||((i.pathCache=a=St(n)).path=n),h&&t.rotate&&t.translate?(t.translate(e,s),t.rotate(h),It(t,a,0,0,r,o),t.rotate(-h),t.translate(-e,-s)):It(t,a,e,s,r,o)}var Vn={type:"path",tag:"path",nested:!1,attr:function(t,i){var n=i.scaleX||1,e=i.scaleY||1;1===n&&1===e||t("vector-effect","non-scaling-stroke"),t("transform",function(t){return yn(t.x||0,t.y||0)+(t.angle?" "+xn(t.angle):"")+(t.scaleX||t.scaleY?" "+(i=t.scaleX||1,n=t.scaleY||1,"scale("+i+","+n+")"):"");var i,n}(i)),t("d",i.path)},bound:function(t,i){return $n($i(t,i.angle),i)?t.set(0,0,0,0):bi(t,i,!0)},draw:cn($n),pick:pn($n),isect:Xi($n)};function Hn(t,i){t.beginPath(),ui(t,i)}var jn={type:"rect",tag:"path",nested:!1,attr:function(t,i){t("d",ui(null,i))},bound:function(t,i){var n,e;return bi(t.set(n=i.x||0,e=i.y||0,n+i.width||0,e+i.height||0),i)},draw:cn(Hn),pick:pn(Hn),isect:Fi};function Bn(t,i,n){var e,s,r,o;return!(!i.stroke||!rn(t,i,n))&&(e=i.x||0,s=i.y||0,r=null!=i.x2?i.x2:e,o=null!=i.y2?i.y2:s,t.beginPath(),t.moveTo(e,s),t.lineTo(r,o),!0)}var Gn={type:"rule",tag:"line",nested:!1,attr:function(t,i){t("transform",gn(i)),t("x2",null!=i.x2?i.x2-(i.x||0):0),t("y2",null!=i.y2?i.y2-(i.y||0):0)},bound:function(t,i){var n,e;return bi(t.set(n=i.x||0,e=i.y||0,null!=i.x2?i.x2:n,null!=i.y2?i.y2:e),i)},draw:function(t,i,n){an(i,(i=>{if(!n||n.intersects(i.bounds)){var e=null==i.opacity?1:i.opacity;e&&Bn(t,i,e)&&(Zi(t,i),t.stroke())}}))},pick:fn((function(t,i,n,e){return!!t.isPointInStroke&&(Bn(t,i,1)&&t.isPointInStroke(n,e))})),isect:Yi},Wn=vn("shape",(function(t,i){return(i.mark.shape||i.shape).context(t)(i)})),Xn=vn("symbol",(function(t,i){return ai.context(t)(i)}),Ui);const Un=i.lruCache();var Fn={height:te,measureWidth:Qn,estimateWidth:Jn,width:Jn,canvas:Yn};function Yn(t){Fn.width=t&&Gi?Qn:Jn}function Jn(t,i){return Zn(ee(t,i),te(t))}function Zn(t,i){return~~(.8*t.length*i)}function Qn(t,i){return te(t)<=0||!(i=ee(t,i))?0:Kn(i,re(t))}function Kn(t,i){const n=`(${i}) ${t}`;let e=Un.get(n);return void 0===e&&(Gi.font=i,e=Gi.measureText(t).width,Un.set(n,e)),e}function te(t){return null!=t.fontSize?+t.fontSize||0:11}function ie(t){return null!=t.lineHeight?t.lineHeight:te(t)+2}function ne(t){return n=t.lineBreak&&t.text&&!i.isArray(t.text)?t.text.split(t.lineBreak):t.text,i.isArray(n)?n.length>1?n:n[0]:n;var n}function ee(t,i){const n=null==i?"":(i+"").trim();return t.limit>0&&n.length?function(t,i){var n=+t.limit,e=function(t){if(Fn.width===Qn){const i=re(t);return t=>Kn(t,i)}{const i=te(t);return t=>Zn(t,i)}}(t);if(e(i)<n)return i;var s,r=t.ellipsis||"…",o="rtl"===t.dir,h=0,a=i.length;if(n-=e(r),o){for(;h<a;)s=h+a>>>1,e(i.slice(s))>n?h=s+1:a=s;return r+i.slice(h)}for(;h<a;)s=1+(h+a>>>1),e(i.slice(0,s))<n?h=s:a=s-1;return i.slice(0,h)+r}(t,n):n}function se(t,i){var n=t.font;return(i&&n?String(n).replace(/"/g,"'"):n)||"sans-serif"}function re(t,i){return(t.fontStyle?t.fontStyle+" ":"")+(t.fontVariant?t.fontVariant+" ":"")+(t.fontWeight?t.fontWeight+" ":"")+te(t)+"px "+se(t,i)}function oe(t){var i=t.baseline,n=te(t);return Math.round("top"===i?.79*n:"middle"===i?.3*n:"bottom"===i?-.21*n:"line-top"===i?.29*n+.5*ie(t):"line-bottom"===i?.29*n-.5*ie(t):0)}Yn(!0);const he={left:"start",center:"middle",right:"end"},ae=new pi;function le(t){var i,n=t.x||0,e=t.y||0,s=t.radius||0;return s&&(i=(t.theta||0)-Nt,n+=s*Math.cos(i),e+=s*Math.sin(i)),ae.x1=n,ae.y1=e,ae}function ce(t,n,e){var s,r=Fn.height(n),o=n.align,h=le(n),a=h.x1,l=h.y1,c=n.dx||0,u=(n.dy||0)+oe(n)-Math.round(.8*r),_=ne(n);if(i.isArray(_)?(r+=ie(n)*(_.length-1),s=_.reduce(((t,i)=>Math.max(t,Fn.width(n,i))),0)):s=Fn.width(n,_),"center"===o?c-=s/2:"right"===o&&(c-=s),t.set(c+=a,u+=l,c+s,u+r),n.angle&&!e)t.rotate(n.angle*Ct,a,l);else if(2===e)return t.rotatedPoints(n.angle*Ct,a,l);return t}var ue={arc:mn,area:kn,group:zn,image:Dn,line:In,path:Vn,rect:jn,rule:Gn,shape:Wn,symbol:Xn,text:{type:"text",tag:"text",nested:!1,attr:function(t,i){var n,e=i.dx||0,s=(i.dy||0)+oe(i),r=le(i),o=r.x1,h=r.y1,a=i.angle||0;t("text-anchor",he[i.align]||"start"),a?(n=yn(o,h)+" "+xn(a),(e||s)&&(n+=" "+yn(e,s))):n=yn(o+e,h+s),t("transform",n)},bound:ce,draw:function(t,n,e){an(n,(n=>{var s,r,o,h,a,l,c,u=null==n.opacity?1:n.opacity;if(!(e&&!e.intersects(n.bounds)||0===u||n.fontSize<=0||null==n.text||0===n.text.length)){if(t.font=re(n),t.textAlign=n.align||"left",r=(s=le(n)).x1,o=s.y1,n.angle&&(t.save(),t.translate(r,o),t.rotate(n.angle*Ct),r=o=0),r+=n.dx||0,o+=(n.dy||0)+oe(n),l=ne(n),Zi(t,n),i.isArray(l))for(a=ie(n),h=0;h<l.length;++h)c=ee(n,l[h]),n.fill&&en(t,n,u)&&t.fillText(c,r,o),n.stroke&&rn(t,n,u)&&t.strokeText(c,r,o),o+=a;else c=ee(n,l),n.fill&&en(t,n,u)&&t.fillText(c,r,o),n.stroke&&rn(t,n,u)&&t.strokeText(c,r,o);n.angle&&t.restore()}}))},pick:fn((function(t,i,n,e,s,r){if(i.fontSize<=0)return!1;if(!i.angle)return!0;var o=le(i),h=o.x1,a=o.y1,l=ce(ae,i,1),c=-i.angle*Ct,u=Math.cos(c),_=Math.sin(c),f=u*s-_*r+(h-u*h+_*a),d=_*s+u*r+(a-_*h-u*a);return l.contains(f,d)})),isect:function(t,i){const n=ce(ae,t,2);return Ji(i,n[0],n[1],n[2],n[3])||Ji(i,n[0],n[1],n[4],n[5])||Ji(i,n[4],n[5],n[6],n[7])||Ji(i,n[2],n[3],n[6],n[7])}},trail:bn("trail",(function(t,i){return li.context(t)(i)}),(function(t,i){for(var n,e,s=t.length;--s>=0;)if(!1!==t[s].defined&&(n=t[s].x-i[0])*n+(e=t[s].y-i[1])*e<(n=t[s].size||1)*n)return t[s];return null}))};function _e(t,i,n){var e=ue[t.mark.marktype],s=i||e.bound;return e.nested&&(t=t.mark),s(t.bounds||(t.bounds=new pi),t,n)}var fe={mark:null};function de(t,i,n){var e,s,r,o,h=ue[t.marktype],a=h.bound,l=t.items,c=l&&l.length;if(h.nested)return c?r=l[0]:(fe.mark=t,r=fe),o=_e(r,a,n),i=i&&i.union(o)||o;if(i=i||t.bounds&&t.bounds.clear()||new pi,c)for(e=0,s=l.length;e<s;++e)i.union(_e(l[e],a,n));return t.bounds=i}const pe=["marktype","name","role","interactive","clip","items","zindex","x","y","width","height","align","baseline","fill","fillOpacity","opacity","blend","stroke","strokeOpacity","strokeWidth","strokeCap","strokeDash","strokeDashOffset","strokeForeground","strokeOffset","startAngle","endAngle","innerRadius","outerRadius","cornerRadius","padAngle","cornerRadiusTopLeft","cornerRadiusTopRight","cornerRadiusBottomLeft","cornerRadiusBottomRight","interpolate","tension","orient","defined","url","aspect","smooth","path","scaleX","scaleY","x2","y2","size","shape","text","angle","theta","radius","dir","dx","dy","ellipsis","limit","lineBreak","lineHeight","font","fontSize","fontWeight","fontStyle","fontVariant","description","aria","ariaRole","ariaRoleDescription"];function ye(t,i){return JSON.stringify(t,pe,i)}function xe(t){return ge("string"==typeof t?JSON.parse(t):t)}function ge(t){var i,n,e,s=t.marktype,r=t.items;if(r)for(n=0,e=r.length;n<e;++n)i=s?"mark":"group",r[n][i]=t,r[n].zindex&&(r[n][i].zdirty=!0),"group"===(s||i)&&ge(r[n]);return s&&de(t),t}function ve(t){arguments.length?this.root=xe(t):(this.root=me({marktype:"group",name:"root",role:"frame"}),this.root.items=[new xi(this.root)])}function me(t,i){const n={bounds:new pi,clip:!!t.clip,group:i,interactive:!1!==t.interactive,items:[],marktype:t.marktype,name:t.name||void 0,role:t.role||void 0,zindex:t.zindex||0};return null!=t.aria&&(n.aria=t.aria),t.description&&(n.description=t.description),n}function be(t,i,n){return!t&&"undefined"!=typeof document&&document.createElement&&(t=document),t?n?t.createElementNS(n,i):t.createElement(i):null}function ke(t,i){i=i.toLowerCase();for(var n=t.childNodes,e=0,s=n.length;e<s;++e)if(n[e].tagName.toLowerCase()===i)return n[e]}function we(t,i,n,e){var s,r=t.childNodes[i];return r&&r.tagName.toLowerCase()===n.toLowerCase()||(s=r||null,r=be(t.ownerDocument,n,e),t.insertBefore(r,s)),r}function Te(t,i){for(var n=t.childNodes,e=n.length;e>i;)t.removeChild(n[--e]);return t}function Me(t){return"mark-"+t.marktype+(t.role?" role-"+t.role:"")+(t.name?" "+t.name:"")}function Ae(t,i){const n=i.getBoundingClientRect();return[t.clientX-n.left-(i.clientLeft||0),t.clientY-n.top-(i.clientTop||0)]}function Se(t,i){this._active=null,this._handlers={},this._loader=t||e.loader(),this._tooltip=i||Ce}function Ce(t,i,n,e){t.element().setAttribute("title",e||"")}function Ne(t){this._el=null,this._bgcolor=null,this._loader=new gi(t)}ve.prototype={toJSON(t){return ye(this.root,t||0)},mark(t,i,n){const e=me(t,i=i||this.root.items[0]);return i.items[n]=e,e.zindex&&(e.group.zdirty=!0),e}},Se.prototype={initialize(t,i,n){return this._el=t,this._obj=n||null,this.origin(i)},element(){return this._el},canvas(){return this._el&&this._el.firstChild},origin(t){return arguments.length?(this._origin=t||[0,0],this):this._origin.slice()},scene(t){return arguments.length?(this._scene=t,this):this._scene},on(){},off(){},_handlerIndex(t,i,n){for(let e=t?t.length:0;--e>=0;)if(t[e].type===i&&(!n||t[e].handler===n))return e;return-1},handlers(t){const i=this._handlers,n=[];if(t)n.push(...i[this.eventName(t)]);else for(const t in i)n.push(...i[t]);return n},eventName(t){const i=t.indexOf(".");return i<0?t:t.slice(0,i)},handleHref(t,i,n){this._loader.sanitize(n,{context:"href"}).then((i=>{const n=new MouseEvent(t.type,t),e=be(null,"a");for(const t in i)e.setAttribute(t,i[t]);e.dispatchEvent(n)})).catch((()=>{}))},handleTooltip(t,i,n){if(i&&null!=i.tooltip){i=function(t,i,n,e){var s,r,o=t&&t.mark;if(o&&(s=ue[o.marktype]).tip){for((r=Ae(i,n))[0]-=e[0],r[1]-=e[1];t=t.mark.group;)r[0]-=t.x||0,r[1]-=t.y||0;t=s.tip(o.items,r)}return t}(i,t,this.canvas(),this._origin);const e=n&&i&&i.tooltip||null;this._tooltip.call(this._obj,this,t,i,e)}},getItemBoundingClientRect(t){const i=this.canvas();if(!i)return;const n=i.getBoundingClientRect(),e=this._origin,s=t.bounds,r=s.width(),o=s.height();let h=s.x1+e[0]+n.left,a=s.y1+e[1]+n.top;for(;t.mark&&(t=t.mark.group);)h+=t.x||0,a+=t.y||0;return{x:h,y:a,width:r,height:o,left:h,top:a,right:h+r,bottom:a+o}}},Ne.prototype={initialize(t,i,n,e,s){return this._el=t,this.resize(i,n,e,s)},element(){return this._el},canvas(){return this._el&&this._el.firstChild},background(t){return 0===arguments.length?this._bgcolor:(this._bgcolor=t,this)},resize(t,i,n,e){return this._width=t,this._height=i,this._origin=n||[0,0],this._scale=e||1,this},dirty(){},render(t){const i=this;return i._call=function(){i._render(t)},i._call(),i._call=null,i},_render(){},renderAsync(t){const i=this.render(t);return this._ready?this._ready.then((()=>i)):Promise.resolve(i)},_load(t,i){var n=this,e=n._loader[t](i);if(!n._ready){const t=n._call;n._ready=n._loader.ready().then((i=>{i&&t(),n._ready=null}))}return e},sanitizeURL(t){return this._load("sanitizeURL",t)},loadImage(t){return this._load("loadImage",t)}};const ze="dragenter",Re="dragleave",Pe="dragover",Ee="mousedown",Le="mousemove",qe="mouseout",Oe="mouseover",De="click",Ie="mousewheel",$e="touchstart",Ve="touchmove",He="touchend",je=["keydown","keypress","keyup",ze,Re,Pe,Ee,"mouseup",Le,qe,Oe,De,"dblclick","wheel",Ie,$e,Ve,He],Be=Le,Ge=qe,We=De;function Xe(t,i){Se.call(this,t,i),this._down=null,this._touch=null,this._first=!0,this._events={}}function Ue(t,i){(t=>t===$e||t===Ve||t===He?[$e,Ve,He]:[t])(i).forEach((i=>function(t,i){const n=t.canvas();n&&!t._events[i]&&(t._events[i]=1,n.addEventListener(i,t[i]?n=>t[i](n):n=>t.fire(i,n)))}(t,i)))}function Fe(t,i,n){return function(e){const s=this._active,r=this.pickEvent(e);r===s||(s&&s.exit||this.fire(n,e),this._active=r,this.fire(i,e)),this.fire(t,e)}}function Ye(t){return function(i){this.fire(t,i),this._active=null}}i.inherits(Xe,Se,{initialize(t,i,n){return this._canvas=t&&ke(t,"canvas"),[De,Ee,Le,qe,Re].forEach((t=>Ue(this,t))),Se.prototype.initialize.call(this,t,i,n)},canvas(){return this._canvas},context(){return this._canvas.getContext("2d")},events:je,DOMMouseScroll(t){this.fire(Ie,t)},mousemove:Fe(Le,Oe,qe),dragover:Fe(Pe,ze,Re),mouseout:Ye(qe),dragleave:Ye(Re),mousedown(t){this._down=this._active,this.fire(Ee,t)},click(t){this._down===this._active&&(this.fire(De,t),this._down=null)},touchstart(t){this._touch=this.pickEvent(t.changedTouches[0]),this._first&&(this._active=this._touch,this._first=!1),this.fire($e,t,!0)},touchmove(t){this.fire(Ve,t,!0)},touchend(t){this.fire(He,t,!0),this._touch=null},fire(t,i,n){const e=n?this._touch:this._active,s=this._handlers[t];if(i.vegaType=t,t===We&&e&&e.href?this.handleHref(i,e,e.href):t!==Be&&t!==Ge||this.handleTooltip(i,e,t!==Ge),s)for(let t=0,n=s.length;t<n;++t)s[t].handler.call(this._obj,i,e)},on(t,i){const n=this.eventName(t),e=this._handlers;return this._handlerIndex(e[n],t,i)<0&&(Ue(this,t),(e[n]||(e[n]=[])).push({type:t,handler:i})),this},off(t,i){const n=this.eventName(t),e=this._handlers[n],s=this._handlerIndex(e,t,i);return s>=0&&e.splice(s,1),this},pickEvent(t){const i=Ae(t,this._canvas),n=this._origin;return this.pick(this._scene,i[0],i[1],i[0]-n[0],i[1]-n[1])},pick(t,i,n,e,s){const r=this.context();return ue[t.marktype].pick.call(this,r,t,i,n,e,s)}});var Je="undefined"!=typeof window&&window.devicePixelRatio||1;function Ze(t){Ne.call(this,t),this._options={},this._redraw=!1,this._dirty=new pi,this._tempb=new pi}const Qe=Ne.prototype;function Ke(t,i){Se.call(this,t,i);const n=this;n._hrefHandler=ts(n,((t,i)=>{i&&i.href&&n.handleHref(t,i,i.href)})),n._tooltipHandler=ts(n,((t,i)=>{n.handleTooltip(t,i,t.type!==Ge)}))}i.inherits(Ze,Ne,{initialize(t,i,e,s,r,o){return this._options=o||{},this._canvas=this._options.externalContext?null:n.canvas(1,1,this._options.type),t&&this._canvas&&(Te(t,0).appendChild(this._canvas),this._canvas.setAttribute("class","marks")),Qe.initialize.call(this,t,i,e,s,r)},resize(t,n,e,s){if(Qe.resize.call(this,t,n,e,s),this._canvas)!function(t,i,n,e,s,r){const o="undefined"!=typeof HTMLElement&&t instanceof HTMLElement&&null!=t.parentNode,h=t.getContext("2d"),a=o?Je:s;t.width=i*a,t.height=n*a;for(const t in r)h[t]=r[t];o&&1!==a&&(t.style.width=i+"px",t.style.height=n+"px"),h.pixelRatio=a,h.setTransform(a,0,0,a,a*e[0],a*e[1])}(this._canvas,this._width,this._height,this._origin,this._scale,this._options.context);else{const t=this._options.externalContext;t||i.error("CanvasRenderer is missing a valid canvas or context"),t.scale(this._scale,this._scale),t.translate(this._origin[0],this._origin[1])}return this._redraw=!0,this},canvas(){return this._canvas},context(){return this._options.externalContext||(this._canvas?this._canvas.getContext("2d"):null)},dirty(t){const i=this._tempb.clear().union(t.bounds);let n=t.mark.group;for(;n;)i.translate(n.x||0,n.y||0),n=n.mark.group;this._dirty.union(i)},_render(t){const i=this.context(),n=this._origin,e=this._width,s=this._height,r=this._dirty,o=(h=n,a=e,l=s,(new pi).set(0,0,a,l).translate(-h[0],-h[1]));var h,a,l;i.save();const c=this._redraw||r.empty()?(this._redraw=!1,o.expand(1)):function(t,i,n){return i.expand(1).round(),t.pixelRatio%1&&i.scale(t.pixelRatio).round().scale(1/t.pixelRatio),i.translate(-n[0]%1,-n[1]%1),t.beginPath(),t.rect(i.x1,i.y1,i.width(),i.height()),t.clip(),i}(i,o.intersect(r),n);return this.clear(-n[0],-n[1],e,s),this.draw(i,t,c),i.restore(),r.clear(),this},draw(t,n,e){const s=ue[n.marktype];n.clip&&function(t,n){var e=n.clip;t.save(),i.isFunction(e)?(t.beginPath(),e(t),t.clip()):wn(t,n.group)}(t,n),s.draw.call(this,t,n,e),n.clip&&t.restore()},clear(t,i,n,e){const s=this._options,r=this.context();"pdf"===s.type||s.externalContext||r.clearRect(t,i,n,e),null!=this._bgcolor&&(r.fillStyle=this._bgcolor,r.fillRect(t,i,n,e))}});const ts=(t,i)=>n=>{let e=n.target.__data__;e=Array.isArray(e)?e[0]:e,n.vegaType=n.type,i.call(t._obj,n,e)};i.inherits(Ke,Se,{initialize(t,i,n){let e=this._svg;return e&&(e.removeEventListener(We,this._hrefHandler),e.removeEventListener(Be,this._tooltipHandler),e.removeEventListener(Ge,this._tooltipHandler)),this._svg=e=t&&ke(t,"svg"),e&&(e.addEventListener(We,this._hrefHandler),e.addEventListener(Be,this._tooltipHandler),e.addEventListener(Ge,this._tooltipHandler)),Se.prototype.initialize.call(this,t,i,n)},canvas(){return this._svg},on(t,i){const n=this.eventName(t),e=this._handlers;if(this._handlerIndex(e[n],t,i)<0){const s={type:t,handler:i,listener:ts(this,i)};(e[n]||(e[n]=[])).push(s),this._svg&&this._svg.addEventListener(n,s.listener)}return this},off(t,i){const n=this.eventName(t),e=this._handlers[n],s=this._handlerIndex(e,t,i);return s>=0&&(this._svg&&this._svg.removeEventListener(n,e[s].listener),e.splice(s,1)),this}});const is="aria-hidden",ns="aria-label",es="role",ss="aria-roledescription",rs="graphics-object",os="graphics-symbol",hs=(t,i,n)=>({[es]:t,[ss]:i,[ns]:n||void 0}),as=i.toSet(["axis-domain","axis-grid","axis-label","axis-tick","axis-title","legend-band","legend-entry","legend-gradient","legend-label","legend-title","legend-symbol","title"]),ls={axis:{desc:"axis",caption:function(t){const i=t.datum,n=t.orient,e=i.title?ds(t):null,r=t.context,o=r.scales[i.scale].value,h=r.dataflow.locale(),a=o.type;return("left"===n||"right"===n?"Y":"X")+"-axis"+(e?` titled '${e}'`:"")+` for a ${s.isDiscrete(a)?"discrete":a} scale`+` with ${s.domainCaption(h,o,t)}`}},legend:{desc:"legend",caption:function(t){const n=t.datum,e=n.title?ds(t):null,r=`${n.type||""} legend`.trim(),o=n.scales,h=Object.keys(o),a=t.context,l=a.scales[o[h[0]]].value,c=a.dataflow.locale();return u=r,(u.length?u[0].toUpperCase()+u.slice(1):u)+(e?` titled '${e}'`:"")+` for ${function(t){return(t=t.map((t=>t+("fill"===t||"stroke"===t?" color":"")))).length<2?t[0]:t.slice(0,-1).join(", ")+" and "+i.peek(t)}(h)}`+` with ${s.domainCaption(c,l,t)}`;var u}},"title-text":{desc:"title",caption:t=>`Title text '${fs(t)}'`},"title-subtitle":{desc:"subtitle",caption:t=>`Subtitle text '${fs(t)}'`}},cs={ariaRole:es,ariaRoleDescription:ss,description:ns};function us(t,i){const n=!1===i.aria;if(t(is,n||void 0),n||null==i.description)for(const i in cs)t(cs[i],void 0);else{const n=i.mark.marktype;t(ns,i.description),t(es,i.ariaRole||("group"===n?rs:os)),t(ss,i.ariaRoleDescription||`${n} mark`)}}function _s(t){return!1===t.aria?{[is]:!0}:as[t.role]?null:ls[t.role]?function(t,i){try{const n=t.items[0],e=i.caption||(()=>"");return hs(i.role||os,i.desc,n.description||e(n))}catch(t){return null}}(t,ls[t.role]):function(t){const i=t.marktype,n="group"===i||"text"===i||t.items.some((t=>null!=t.description&&!1!==t.aria));return hs(n?rs:os,`${i} mark container`,t.description)}(t)}function fs(t){return i.array(t.text).join(" ")}function ds(t){try{return i.array(i.peek(t.items).items[0].text).join(" ")}catch(t){return null}}const ps=t=>(t+"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");function ys(){let t="",i="",n="";const e=[],s=()=>i=n="",r=(t,n)=>{var e;return null!=n&&(i+=` ${t}="${e=n,ps(e).replace(/"/g,"&quot;").replace(/\t/g,"&#x9;").replace(/\n/g,"&#xA;").replace(/\r/g,"&#xD;")}"`),o},o={open(h,...a){(r=>{i&&(t+=`${i}>${n}`,s()),e.push(r)})(h),i="<"+h;for(const t of a)for(const i in t)r(i,t[i]);return o},close(){const r=e.pop();return t+=i?i+(n?`>${n}</${r}>`:"/>"):`</${r}>`,s(),o},attr:r,text:t=>(n+=ps(t),o),toString:()=>t};return o}const xs=t=>gs(ys(),t)+"";function gs(t,i){if(t.open(i.tagName),i.hasAttributes()){const n=i.attributes,e=n.length;for(let i=0;i<e;++i)t.attr(n[i].name,n[i].value)}if(i.hasChildNodes()){const n=i.childNodes,e=n.length;for(let i=0;i<e;i++){const e=n[i];3===e.nodeType?t.text(e.nodeValue):gs(t,e)}}return t.close()}const vs={fill:"fill",fillOpacity:"fill-opacity",stroke:"stroke",strokeOpacity:"stroke-opacity",strokeWidth:"stroke-width",strokeCap:"stroke-linecap",strokeJoin:"stroke-linejoin",strokeDash:"stroke-dasharray",strokeDashOffset:"stroke-dashoffset",strokeMiterLimit:"stroke-miterlimit",opacity:"opacity",blend:"mix-blend-mode"},ms={fill:"none","stroke-miterlimit":10},bs="http://www.w3.org/2000/xmlns/",ks=Rn.xmlns;function ws(t){Ne.call(this,t),this._dirtyID=0,this._dirty=[],this._svg=null,this._root=null,this._defs=null}const Ts=Ne.prototype;function Ms(t,i){for(;t&&t.dirty!==i;t=t.mark.group){if(t.dirty=i,!t.mark||t.mark.dirty===i)return;t.mark.dirty=i}}function As(t,i,n){let e,s,r;if("radial"===i.gradient){let e=we(t,n++,"pattern",ks);Ls(e,{id:o+i.id,viewBox:"0,0,1,1",width:"100%",height:"100%",preserveAspectRatio:"xMidYMid slice"}),e=we(e,0,"rect",ks),Ls(e,{width:1,height:1,fill:`url(${Os()}#${i.id})`}),Ls(t=we(t,n++,"radialGradient",ks),{id:i.id,fx:i.x1,fy:i.y1,fr:i.r1,cx:i.x2,cy:i.y2,r:i.r2})}else Ls(t=we(t,n++,"linearGradient",ks),{id:i.id,x1:i.x1,x2:i.x2,y1:i.y1,y2:i.y2});for(e=0,s=i.stops.length;e<s;++e)r=we(t,e,"stop",ks),r.setAttribute("offset",i.stops[e].offset),r.setAttribute("stop-color",i.stops[e].color);return Te(t,e),n}function Ss(t,i,n){let e;return(t=we(t,n,"clipPath",ks)).setAttribute("id",i.id),i.path?(e=we(t,0,"path",ks),e.setAttribute("d",i.path)):(e=we(t,0,"rect",ks),Ls(e,{x:0,y:0,width:i.width,height:i.height})),Te(t,1),n+1}function Cs(t,i,n,e,s){let r,o=t._svg;if(!o&&(r=i.ownerDocument,o=be(r,e,ks),t._svg=o,t.mark&&(o.__data__=t,o.__values__={fill:"default"},"g"===e))){const i=be(r,"path",ks);o.appendChild(i),i.__data__=t;const n=be(r,"g",ks);o.appendChild(n),n.__data__=t;const e=be(r,"path",ks);o.appendChild(e),e.__data__=t,e.__values__={fill:"default"}}return(o.ownerSVGElement!==s||function(t,i){return t.parentNode&&t.parentNode.childNodes.length>1&&t.previousSibling!=i}(o,n))&&i.insertBefore(o,n?n.nextSibling:i.firstChild),o}i.inherits(ws,Ne,{initialize(t,i,n,e,s){return this._defs={},this._clearDefs(),t&&(this._svg=we(t,0,"svg",ks),this._svg.setAttributeNS(bs,"xmlns",ks),this._svg.setAttributeNS(bs,"xmlns:xlink",Rn["xmlns:xlink"]),this._svg.setAttribute("version",Rn.version),this._svg.setAttribute("class","marks"),Te(t,1),this._root=we(this._svg,0,"g",ks),Ls(this._root,ms),Te(this._svg,1)),this.background(this._bgcolor),Ts.initialize.call(this,t,i,n,e,s)},background(t){return arguments.length&&this._svg&&this._svg.style.setProperty("background-color",t),Ts.background.apply(this,arguments)},resize(t,i,n,e){return Ts.resize.call(this,t,i,n,e),this._svg&&(Ls(this._svg,{width:this._width*this._scale,height:this._height*this._scale,viewBox:`0 0 ${this._width} ${this._height}`}),this._root.setAttribute("transform",`translate(${this._origin})`)),this._dirty=[],this},canvas(){return this._svg},svg(){const t=this._svg,i=this._bgcolor;if(!t)return null;let n;i&&(t.removeAttribute("style"),n=we(t,0,"rect",ks),Ls(n,{width:this._width,height:this._height,fill:i}));const e=xs(t);return i&&(t.removeChild(n),this._svg.style.setProperty("background-color",i)),e},_render(t){return this._dirtyCheck()&&(this._dirtyAll&&this._clearDefs(),this.mark(this._root,t),Te(this._root,1)),this.defs(),this._dirty=[],++this._dirtyID,this},dirty(t){t.dirty!==this._dirtyID&&(t.dirty=this._dirtyID,this._dirty.push(t))},isDirty(t){return this._dirtyAll||!t._svg||t.dirty===this._dirtyID},_dirtyCheck(){this._dirtyAll=!0;const t=this._dirty;if(!t.length||!this._dirtyID)return!0;const i=++this._dirtyID;let n,e,s,r,o,h,a;for(o=0,h=t.length;o<h;++o)n=t[o],e=n.mark,e.marktype!==s&&(s=e.marktype,r=ue[s]),e.zdirty&&e.dirty!==i&&(this._dirtyAll=!1,Ms(n,i),e.items.forEach((t=>{t.dirty=i}))),e.zdirty||(n.exit?(r.nested&&e.items.length?(a=e.items[0],a._svg&&this._update(r,a._svg,a)):n._svg&&(a=n._svg.parentNode,a&&a.removeChild(n._svg)),n._svg=null):(n=r.nested?e.items[0]:n,n._update!==i&&(n._svg&&n._svg.ownerSVGElement?this._update(r,n._svg,n):(this._dirtyAll=!1,Ms(n,i)),n._update=i)));return!this._dirtyAll},mark(t,i,n){if(!this.isDirty(i))return i._svg;const e=this._svg,s=ue[i.marktype],r=!1===i.interactive?"none":null,o="g"===s.tag;let h=null,a=0;const l=Cs(i,t,n,"g",e);l.setAttribute("class",Me(i));const c=_s(i);for(const t in c)qs(l,t,c[t]);o||qs(l,"pointer-events",r),qs(l,"clip-path",i.clip?di(this,i,i.group):null);const u=t=>{const i=this.isDirty(t),n=Cs(t,l,h,s.tag,e);i&&(this._update(s,n,t),o&&function(t,i,n){i=i.lastChild.previousSibling;let e,s=0;an(n,(n=>{e=t.mark(i,n,e),++s})),Te(i,1+s)}(this,n,t)),h=n,++a};return s.nested?i.items.length&&u(i.items[0]):an(i,u),Te(l,a),l},_update(t,i,n){Ns=i,zs=i.__values__,us(Ps,n),t.attr(Ps,n,this);const e=Rs[t.type];e&&e.call(this,t,i,n),Ns&&this.style(Ns,n)},style(t,i){if(null!=i)for(const n in vs){let e="font"===n?se(i):i[n];if(e===zs[n])continue;const s=vs[n];null==e?t.removeAttribute(s):(h(e)&&(e=a(e,this._defs.gradient,Os())),t.setAttribute(s,e+"")),zs[n]=e}},defs(){const t=this._svg,i=this._defs;let n=i.el,e=0;for(const s in i.gradient)n||(i.el=n=we(t,1,"defs",ks)),e=As(n,i.gradient[s],e);for(const s in i.clipping)n||(i.el=n=we(t,1,"defs",ks)),e=Ss(n,i.clipping[s],e);n&&(0===e?(t.removeChild(n),i.el=null):Te(n,e))},_clearDefs(){const t=this._defs;t.gradient={},t.clipping={}}});let Ns=null,zs=null;const Rs={group(t,i,n){const e=Ns=i.childNodes[2];zs=e.__values__,t.foreground(Ps,n,this),zs=i.__values__,Ns=i.childNodes[1],t.content(Ps,n,this);const s=Ns=i.childNodes[0];t.background(Ps,n,this);const r=!1===n.mark.interactive?"none":null;if(r!==zs.events&&(qs(e,"pointer-events",r),qs(s,"pointer-events",r),zs.events=r),n.strokeForeground&&n.stroke){const t=n.fill;qs(e,"display",null),this.style(s,n),qs(s,"stroke",null),t&&(n.fill=null),zs=e.__values__,this.style(e,n),t&&(n.fill=t),Ns=null}else qs(e,"display","none")},image(t,i,n){!1===n.smooth?(Es(i,"image-rendering","optimizeSpeed"),Es(i,"image-rendering","pixelated")):Es(i,"image-rendering",null)},text(t,n,e){const s=ne(e);let r,o,h,a;i.isArray(s)?(o=s.map((t=>ee(e,t))),r=o.join("\n"),r!==zs.text&&(Te(n,0),h=n.ownerDocument,a=ie(e),o.forEach(((t,i)=>{const s=be(h,"tspan",ks);s.__data__=e,s.textContent=t,i&&(s.setAttribute("x",0),s.setAttribute("dy",a)),n.appendChild(s)})),zs.text=r)):(o=ee(e,s),o!==zs.text&&(n.textContent=o,zs.text=o)),qs(n,"font-family",se(e)),qs(n,"font-size",te(e)+"px"),qs(n,"font-style",e.fontStyle),qs(n,"font-variant",e.fontVariant),qs(n,"font-weight",e.fontWeight)}};function Ps(t,i,n){i!==zs[t]&&(n?function(t,i,n,e){null!=n?t.setAttributeNS(e,i,n):t.removeAttributeNS(e,i)}(Ns,t,i,n):qs(Ns,t,i),zs[t]=i)}function Es(t,i,n){n!==zs[i]&&(null==n?t.style.removeProperty(i):t.style.setProperty(i,n+""),zs[i]=n)}function Ls(t,i){for(const n in i)qs(t,n,i[n])}function qs(t,i,n){null!=n?t.setAttribute(i,n):t.removeAttribute(i)}function Os(){let t;return"undefined"==typeof window?"":(t=window.location).hash?t.href.slice(0,-t.hash.length):t.href}function Ds(t){Ne.call(this,t),this._text=null,this._defs={gradient:{},clipping:{}}}i.inherits(Ds,Ne,{svg(){return this._text},_render(t){const n=ys();n.open("svg",i.extend({},Rn,{class:"marks",width:this._width*this._scale,height:this._height*this._scale,viewBox:`0 0 ${this._width} ${this._height}`}));const e=this._bgcolor;return e&&"transparent"!==e&&"none"!==e&&n.open("rect",{width:this._width,height:this._height,fill:e}).close(),n.open("g",ms,{transform:"translate("+this._origin+")"}),this.mark(n,t),n.close(),this.defs(n),this._text=n.close()+"",this},mark(t,n){const e=ue[n.marktype],s=e.tag,r=[us,e.attr];t.open("g",{class:Me(n),"clip-path":n.clip?di(this,n,n.group):null},_s(n),{"pointer-events":"g"!==s&&!1===n.interactive?"none":null});const o=o=>{const h=this.href(o);if(h&&t.open("a",h),t.open(s,this.attr(n,o,r,"g"!==s?s:null)),"text"===s){const n=ne(o);if(i.isArray(n)){const i={x:0,dy:ie(o)};for(let e=0;e<n.length;++e)t.open("tspan",e?i:null).text(ee(o,n[e])).close()}else t.text(ee(o,n))}else if("g"===s){const i=o.strokeForeground,s=o.fill,r=o.stroke;i&&r&&(o.stroke=null),t.open("path",this.attr(n,o,e.background,"bgrect")).close(),t.open("g",this.attr(n,o,e.content)),an(o,(i=>this.mark(t,i))),t.close(),i&&r?(s&&(o.fill=null),o.stroke=r,t.open("path",this.attr(n,o,e.foreground,"bgrect")).close(),s&&(o.fill=s)):t.open("path",this.attr(n,o,e.foreground,"bgfore")).close()}t.close(),h&&t.close()};return e.nested?n.items&&n.items.length&&o(n.items[0]):an(n,o),t.close()},href(t){const i=t.href;let n;if(i){if(n=this._hrefs&&this._hrefs[i])return n;this.sanitizeURL(i).then((t=>{t["xlink:href"]=t.href,t.href=null,(this._hrefs||(this._hrefs={}))[i]=t}))}return null},attr(t,i,n,e){const s={},r=(t,i,n,e)=>{s[e||t]=i};return Array.isArray(n)?n.forEach((t=>t(r,i,this))):n(r,i,this),e&&function(t,i,n,e,s){if(null==i)return t;"bgrect"===e&&!1===n.interactive&&(t["pointer-events"]="none");if("bgfore"===e&&(!1===n.interactive&&(t["pointer-events"]="none"),t.display="none",null!==i.fill))return t;"image"===e&&!1===i.smooth&&(t.style="image-rendering: optimizeSpeed; image-rendering: pixelated;");"text"===e&&(t["font-family"]=se(i),t["font-size"]=te(i)+"px",t["font-style"]=i.fontStyle,t["font-variant"]=i.fontVariant,t["font-weight"]=i.fontWeight);for(const n in vs){let e=i[n];const r=vs[n];("transparent"!==e||"fill"!==r&&"stroke"!==r)&&null!=e&&(h(e)&&(e=a(e,s.gradient,"")),t[r]=e)}}(s,i,t,e,this._defs),s},defs(t){const i=this._defs.gradient,n=this._defs.clipping;if(0!==Object.keys(i).length+Object.keys(n).length){t.open("defs");for(const n in i){const e=i[n],s=e.stops;"radial"===e.gradient?(t.open("pattern",{id:o+n,viewBox:"0,0,1,1",width:"100%",height:"100%",preserveAspectRatio:"xMidYMid slice"}),t.open("rect",{width:"1",height:"1",fill:"url(#"+n+")"}).close(),t.close(),t.open("radialGradient",{id:n,fx:e.x1,fy:e.y1,fr:e.r1,cx:e.x2,cy:e.y2,r:e.r2})):t.open("linearGradient",{id:n,x1:e.x1,x2:e.x2,y1:e.y1,y2:e.y2});for(let i=0;i<s.length;++i)t.open("stop",{offset:s[i].offset,"stop-color":s[i].color}).close();t.close()}for(const i in n){const e=n[i];t.open("clipPath",{id:i}),e.path?t.open("path",{d:e.path}).close():t.open("rect",{x:0,y:0,width:e.width,height:e.height}).close(),t.close()}t.close()}}});const Is="canvas",$s="none",Vs={Canvas:Is,PNG:"png",SVG:"svg",None:$s},Hs={};function js(t,i,n,e){if(function(t,i,n){return t.bounds&&i.intersects(t.bounds)&&("group"===t.marktype||!1!==t.interactive&&(!n||n(t)))}(t,i,n)){const s=t.items,r=t.marktype,o=s.length;let h=0;if("group"===r)for(;h<o;++h)Bs(s[h],i,n,e);else for(const t=ue[r].isect;h<o;++h){const n=s[h];Gs(n,i,t)&&e.push(n)}}return e}function Bs(t,i,n,e){n&&n(t.mark)&&Gs(t,i,ue.group.isect)&&e.push(t);const s=t.items,r=s&&s.length;if(r){const o=t.x||0,h=t.y||0;i.translate(-o,-h);for(let t=0;t<r;++t)js(s[t],i,n,e);i.translate(o,h)}return e}function Gs(t,i,n){const e=t.bounds;return i.encloses(e)||i.intersects(e)&&n(t,i)}Hs.canvas=Hs.png={renderer:Ze,headless:Ze,handler:Xe},Hs.svg={renderer:ws,headless:Ds,handler:Ke},Hs.none={};const Ws=new pi;function Xs(t,n,e){return t===n||("path"===e?Us(t,n):t instanceof Date&&n instanceof Date?+t==+n:i.isNumber(t)&&i.isNumber(n)?Math.abs(t-n)<=1e-9:t&&n&&(i.isObject(t)||i.isObject(n))?function(t,i){var n,e,s=Object.keys(t),r=Object.keys(i);if(s.length!==r.length)return!1;for(s.sort(),r.sort(),e=s.length-1;e>=0;e--)if(s[e]!=r[e])return!1;for(e=s.length-1;e>=0;e--)if(!Xs(t[n=s[e]],i[n],n))return!1;return typeof t==typeof i}(t,n):t==n)}function Us(t,i){return Xs(St(t),St(i))}t.Bounds=pi,t.CanvasHandler=Xe,t.CanvasRenderer=Ze,t.Gradient=function(t,i){var n,e=[];return n={gradient:"linear",x1:t?t[0]:0,y1:t?t[1]:0,x2:i?i[0]:1,y2:i?i[1]:0,stops:e,stop:function(t,i){return e.push({offset:t,color:i}),n}}},t.GroupItem=xi,t.Handler=Se,t.Item=yi,t.Marks=ue,t.RenderType=Vs,t.Renderer=Ne,t.ResourceLoader=gi,t.SVGHandler=Ke,t.SVGRenderer=ws,t.SVGStringRenderer=Ds,t.Scenegraph=ve,t.boundClip=function(t){const n=t.clip;if(i.isFunction(n))n($i(Ws.clear()));else{if(!n)return;Ws.set(0,0,t.group.width,t.group.height)}t.bounds.intersect(Ws)},t.boundContext=$i,t.boundItem=_e,t.boundMark=de,t.boundStroke=bi,t.domChild=we,t.domClear=Te,t.domCreate=be,t.domFind=ke,t.font=re,t.fontFamily=se,t.fontSize=te,t.intersect=function(t,n,e){const s=[],r=(new pi).union(n),o=t.marktype;return o?js(t,r,e,s):"group"===o?Bs(t,r,e,s):i.error("Intersect scene must be mark node or group item.")},t.intersectBoxLine=Ji,t.intersectPath=Xi,t.intersectPoint=Ui,t.intersectRule=Yi,t.lineHeight=ie,t.markup=ys,t.multiLineOffset=function(t){const n=ne(t);return(i.isArray(n)?n.length-1:0)*ie(t)},t.pathCurves=Tt,t.pathEqual=Us,t.pathParse=St,t.pathRectangle=Zt,t.pathRender=It,t.pathSymbols=jt,t.pathTrail=Qt,t.point=Ae,t.renderModule=function(t,i){return t=String(t||"").toLowerCase(),arguments.length>1?(Hs[t]=i,this):Hs[t]},t.resetSVGClipId=fi,t.resetSVGDefIds=function(){fi(),r=0},t.sceneEqual=Xs,t.sceneFromJSON=xe,t.scenePickVisit=ln,t.sceneToJSON=ye,t.sceneVisit=an,t.sceneZOrder=hn,t.serializeXML=xs,t.textMetrics=Fn,Object.defineProperty(t,"__esModule",{value:!0})}));
-//# sourceMappingURL=vega-scenegraph.min.js.map
diff --git a/node_modules/vega-scenegraph/build/vega-scenegraph.min.js.map b/node_modules/vega-scenegraph/build/vega-scenegraph.min.js.map
deleted file mode 100644
index d8bffc6..0000000
--- a/node_modules/vega-scenegraph/build/vega-scenegraph.min.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"vega-scenegraph.min.js","sources":["../src/Gradient.js","../../../node_modules/d3-path/src/path.js","../../../node_modules/d3-shape/src/constant.js","../../../node_modules/d3-shape/src/math.js","../../../node_modules/d3-shape/src/arc.js","../../../node_modules/d3-shape/src/array.js","../../../node_modules/d3-shape/src/curve/linear.js","../../../node_modules/d3-shape/src/point.js","../../../node_modules/d3-shape/src/line.js","../../../node_modules/d3-shape/src/area.js","../../../node_modules/d3-shape/src/symbol/circle.js","../../../node_modules/d3-shape/src/noop.js","../../../node_modules/d3-shape/src/curve/basis.js","../../../node_modules/d3-shape/src/curve/basisClosed.js","../../../node_modules/d3-shape/src/curve/basisOpen.js","../../../node_modules/d3-shape/src/curve/bundle.js","../../../node_modules/d3-shape/src/curve/cardinal.js","../../../node_modules/d3-shape/src/curve/cardinalClosed.js","../../../node_modules/d3-shape/src/curve/cardinalOpen.js","../../../node_modules/d3-shape/src/curve/catmullRom.js","../../../node_modules/d3-shape/src/curve/catmullRomClosed.js","../../../node_modules/d3-shape/src/curve/catmullRomOpen.js","../../../node_modules/d3-shape/src/curve/linearClosed.js","../../../node_modules/d3-shape/src/curve/monotone.js","../../../node_modules/d3-shape/src/curve/natural.js","../../../node_modules/d3-shape/src/curve/step.js","../src/path/curves.js","../src/path/parse.js","../src/util/constants.js","../src/path/arc.js","../src/path/render.js","../src/path/symbols.js","../src/path/rectangle.js","../src/path/trail.js","../src/path/shapes.js","../../../node_modules/d3-shape/src/symbol.js","../src/util/svg/clip.js","../src/Bounds.js","../src/Item.js","../src/GroupItem.js","../src/ResourceLoader.js","../src/bound/boundStroke.js","../src/bound/boundContext.js","../src/util/canvas/context.js","../src/util/intersect.js","../src/util/canvas/blend.js","../src/util/value.js","../src/util/canvas/gradient.js","../src/util/canvas/color.js","../src/util/canvas/fill.js","../src/util/canvas/stroke.js","../src/util/visit.js","../src/util/canvas/draw.js","../src/util/canvas/pick.js","../src/util/svg/transform.js","../src/marks/markItemPath.js","../src/marks/arc.js","../src/marks/markMultiItemPath.js","../src/marks/area.js","../src/util/pickPath.js","../src/util/canvas/clip.js","../src/marks/group.js","../src/util/svg/metadata.js","../src/marks/image.js","../src/marks/line.js","../src/marks/path.js","../src/marks/rect.js","../src/marks/rule.js","../src/marks/shape.js","../src/marks/symbol.js","../src/util/text.js","../src/marks/text.js","../src/marks/index.js","../src/marks/trail.js","../src/bound/boundItem.js","../src/bound/boundMark.js","../src/util/serialize.js","../src/Scenegraph.js","../src/util/dom.js","../src/util/point.js","../src/Handler.js","../src/Renderer.js","../src/util/resolveItem.js","../src/util/events.js","../src/CanvasHandler.js","../src/util/canvas/resize.js","../src/CanvasRenderer.js","../src/SVGHandler.js","../src/util/aria.js","../src/util/markup.js","../src/util/svg/styles.js","../src/SVGRenderer.js","../src/SVGStringRenderer.js","../src/modules.js","../src/intersect.js","../src/bound/boundClip.js","../src/util/equal.js","../index.js"],"sourcesContent":["let gradient_id = 0;\n\nexport function resetSVGGradientId() {\n  gradient_id = 0;\n}\n\nexport const patternPrefix = 'p_';\n\nexport function isGradient(value) {\n  return value && value.gradient;\n}\n\nexport function gradientRef(g, defs, base) {\n  const type = g.gradient;\n\n  let id = g.id,\n      prefix = type === 'radial' ? patternPrefix : '';\n\n  // check id, assign default values as needed\n  if (!id) {\n    id = g.id = 'gradient_' + (gradient_id++);\n    if (type === 'radial') {\n      g.x1 = get(g.x1, 0.5);\n      g.y1 = get(g.y1, 0.5);\n      g.r1 = get(g.r1, 0);\n      g.x2 = get(g.x2, 0.5);\n      g.y2 = get(g.y2, 0.5);\n      g.r2 = get(g.r2, 0.5);\n      prefix = patternPrefix;\n    } else {\n      g.x1 = get(g.x1, 0);\n      g.y1 = get(g.y1, 0);\n      g.x2 = get(g.x2, 1);\n      g.y2 = get(g.y2, 0);\n    }\n  }\n\n  // register definition\n  defs[id] = g;\n\n  // return url reference\n  return 'url(' + (base || '') + '#' + prefix + id + ')';\n}\n\nfunction get(val, def) {\n  return val != null ? val : def;\n}\n\nexport default function(p0, p1) {\n  var stops = [], gradient;\n  return gradient = {\n    gradient: 'linear',\n    x1: p0 ? p0[0] : 0,\n    y1: p0 ? p0[1] : 0,\n    x2: p1 ? p1[0] : 1,\n    y2: p1 ? p1[1] : 0,\n    stops: stops,\n    stop: function(offset, color) {\n      stops.push({offset: offset, color: color});\n      return gradient;\n    }\n  };\n}\n","const pi = Math.PI,\n    tau = 2 * pi,\n    epsilon = 1e-6,\n    tauEpsilon = tau - epsilon;\n\nfunction Path() {\n  this._x0 = this._y0 = // start of current subpath\n  this._x1 = this._y1 = null; // end of current subpath\n  this._ = \"\";\n}\n\nfunction path() {\n  return new Path;\n}\n\nPath.prototype = path.prototype = {\n  constructor: Path,\n  moveTo: function(x, y) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y);\n  },\n  closePath: function() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  },\n  lineTo: function(x, y) {\n    this._ += \"L\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  quadraticCurveTo: function(x1, y1, x, y) {\n    this._ += \"Q\" + (+x1) + \",\" + (+y1) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) {\n    this._ += \"C\" + (+x1) + \",\" + (+y1) + \",\" + (+x2) + \",\" + (+y2) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  arcTo: function(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n    var x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._ += \"M\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon));\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n      this._ += \"L\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      var x20 = x2 - x0,\n          y20 = y2 - y0,\n          l21_2 = x21 * x21 + y21 * y21,\n          l20_2 = x20 * x20 + y20 * y20,\n          l21 = Math.sqrt(l21_2),\n          l01 = Math.sqrt(l01_2),\n          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n          t01 = l / l01,\n          t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > epsilon) {\n        this._ += \"L\" + (x1 + t01 * x01) + \",\" + (y1 + t01 * y01);\n      }\n\n      this._ += \"A\" + r + \",\" + r + \",0,0,\" + (+(y01 * x20 > x01 * y20)) + \",\" + (this._x1 = x1 + t21 * x21) + \",\" + (this._y1 = y1 + t21 * y21);\n    }\n  },\n  arc: function(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r, ccw = !!ccw;\n    var dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._ += \"M\" + x0 + \",\" + y0;\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n      this._ += \"L\" + x0 + \",\" + y0;\n    }\n\n    // Is this arc empty? We’re done.\n    if (!r) return;\n\n    // Does the angle go the wrong way? Flip the direction.\n    if (da < 0) da = da % tau + tau;\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (x - dx) + \",\" + (y - dy) + \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (this._x1 = x0) + \",\" + (this._y1 = y0);\n    }\n\n    // Is this arc non-empty? Draw an arc!\n    else if (da > epsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,\" + (+(da >= pi)) + \",\" + cw + \",\" + (this._x1 = x + r * Math.cos(a1)) + \",\" + (this._y1 = y + r * Math.sin(a1));\n    }\n  },\n  rect: function(x, y, w, h) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y) + \"h\" + (+w) + \"v\" + (+h) + \"h\" + (-w) + \"Z\";\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\nexport default path;\n","export default function(x) {\n  return function constant() {\n    return x;\n  };\n}\n","export var abs = Math.abs;\nexport var atan2 = Math.atan2;\nexport var cos = Math.cos;\nexport var max = Math.max;\nexport var min = Math.min;\nexport var sin = Math.sin;\nexport var sqrt = Math.sqrt;\n\nexport var epsilon = 1e-12;\nexport var pi = Math.PI;\nexport var halfPi = pi / 2;\nexport var tau = 2 * pi;\n\nexport function acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\n\nexport function asin(x) {\n  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);\n}\n","import {path} from \"d3-path\";\nimport constant from \"./constant.js\";\nimport {abs, acos, asin, atan2, cos, epsilon, halfPi, max, min, pi, sin, sqrt, tau} from \"./math.js\";\n\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\n\nfunction arcPadAngle(d) {\n  return d && d.padAngle; // Note: optional!\n}\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var x10 = x1 - x0, y10 = y1 - y0,\n      x32 = x3 - x2, y32 = y3 - y2,\n      t = y32 * x10 - x32 * y10;\n  if (t * t < epsilon) return;\n  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;\n  return [x0 + t * x10, y0 + t * y10];\n}\n\n// Compute perpendicular offset line of length rc.\n// http://mathworld.wolfram.com/Circle-LineIntersection.html\nfunction cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n  var x01 = x0 - x1,\n      y01 = y0 - y1,\n      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),\n      ox = lo * y01,\n      oy = -lo * x01,\n      x11 = x0 + ox,\n      y11 = y0 + oy,\n      x10 = x1 + ox,\n      y10 = y1 + oy,\n      x00 = (x11 + x10) / 2,\n      y00 = (y11 + y10) / 2,\n      dx = x10 - x11,\n      dy = y10 - y11,\n      d2 = dx * dx + dy * dy,\n      r = r1 - rc,\n      D = x11 * y10 - x10 * y11,\n      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),\n      cx0 = (D * dy - dx * d) / d2,\n      cy0 = (-D * dx - dy * d) / d2,\n      cx1 = (D * dy + dx * d) / d2,\n      cy1 = (-D * dx + dy * d) / d2,\n      dx0 = cx0 - x00,\n      dy0 = cy0 - y00,\n      dx1 = cx1 - x00,\n      dy1 = cy1 - y00;\n\n  // Pick the closer of the two intersection points.\n  // TODO Is there a faster way to determine which intersection to use?\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox,\n    y01: -oy,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\n\nexport default function() {\n  var innerRadius = arcInnerRadius,\n      outerRadius = arcOuterRadius,\n      cornerRadius = constant(0),\n      padRadius = null,\n      startAngle = arcStartAngle,\n      endAngle = arcEndAngle,\n      padAngle = arcPadAngle,\n      context = null;\n\n  function arc() {\n    var buffer,\n        r,\n        r0 = +innerRadius.apply(this, arguments),\n        r1 = +outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) - halfPi,\n        a1 = endAngle.apply(this, arguments) - halfPi,\n        da = abs(a1 - a0),\n        cw = a1 > a0;\n\n    if (!context) context = buffer = path();\n\n    // Ensure that the outer radius is always larger than the inner radius.\n    if (r1 < r0) r = r1, r1 = r0, r0 = r;\n\n    // Is it a point?\n    if (!(r1 > epsilon)) context.moveTo(0, 0);\n\n    // Or is it a circle or annulus?\n    else if (da > tau - epsilon) {\n      context.moveTo(r1 * cos(a0), r1 * sin(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > epsilon) {\n        context.moveTo(r0 * cos(a1), r0 * sin(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    }\n\n    // Or is it a circular or annular sector?\n    else {\n      var a01 = a0,\n          a11 = a1,\n          a00 = a0,\n          a10 = a1,\n          da0 = da,\n          da1 = da,\n          ap = padAngle.apply(this, arguments) / 2,\n          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),\n          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),\n          rc0 = rc,\n          rc1 = rc,\n          t0,\n          t1;\n\n      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.\n      if (rp > epsilon) {\n        var p0 = asin(rp / r0 * sin(ap)),\n            p1 = asin(rp / r1 * sin(ap));\n        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;\n        else da0 = 0, a00 = a10 = (a0 + a1) / 2;\n        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;\n        else da1 = 0, a01 = a11 = (a0 + a1) / 2;\n      }\n\n      var x01 = r1 * cos(a01),\n          y01 = r1 * sin(a01),\n          x10 = r0 * cos(a10),\n          y10 = r0 * sin(a10);\n\n      // Apply rounded corners?\n      if (rc > epsilon) {\n        var x11 = r1 * cos(a11),\n            y11 = r1 * sin(a11),\n            x00 = r0 * cos(a00),\n            y00 = r0 * sin(a00),\n            oc;\n\n        // Restrict the corner radius according to the sector angle.\n        if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {\n          var ax = x01 - oc[0],\n              ay = y01 - oc[1],\n              bx = x11 - oc[0],\n              by = y11 - oc[1],\n              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),\n              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = min(rc, (r0 - lc) / (kc - 1));\n          rc1 = min(rc, (r1 - lc) / (kc + 1));\n        }\n      }\n\n      // Is the sector collapsed to a line?\n      if (!(da1 > epsilon)) context.moveTo(x01, y01);\n\n      // Does the sector’s outer ring have rounded corners?\n      else if (rc1 > epsilon) {\n        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n\n        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the outer ring just a circular arc?\n      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n\n      // Is there no inner ring, and it’s a circular sector?\n      // Or perhaps it’s an annular sector collapsed due to padding?\n      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);\n\n      // Does the sector’s inner ring (or point) have rounded corners?\n      else if (rc0 > epsilon) {\n        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n\n        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the inner ring just a circular arc?\n      else context.arc(0, 0, r0, a10, a00, cw);\n    }\n\n    context.closePath();\n\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  arc.centroid = function() {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,\n        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;\n    return [cos(a) * r, sin(a) * r];\n  };\n\n  arc.innerRadius = function(_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : innerRadius;\n  };\n\n  arc.outerRadius = function(_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : outerRadius;\n  };\n\n  arc.cornerRadius = function(_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : cornerRadius;\n  };\n\n  arc.padRadius = function(_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), arc) : padRadius;\n  };\n\n  arc.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : startAngle;\n  };\n\n  arc.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : endAngle;\n  };\n\n  arc.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : padAngle;\n  };\n\n  arc.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), arc) : context;\n  };\n\n  return arc;\n}\n","export var slice = Array.prototype.slice;\n\nexport default function(x) {\n  return typeof x === \"object\" && \"length\" in x\n    ? x // Array, TypedArray, NodeList, array-like\n    : Array.from(x); // Map, Set, iterable, string, or anything else\n}\n","function Linear(context) {\n  this._context = context;\n}\n\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: this._context.lineTo(x, y); break;\n    }\n  }\n};\n\nexport default function(context) {\n  return new Linear(context);\n}\n","export function x(p) {\n  return p[0];\n}\n\nexport function y(p) {\n  return p[1];\n}\n","import {path} from \"d3-path\";\nimport array from \"./array.js\";\nimport constant from \"./constant.js\";\nimport curveLinear from \"./curve/linear.js\";\nimport {x as pointX, y as pointY} from \"./point.js\";\n\nexport default function(x, y) {\n  var defined = constant(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  x = typeof x === \"function\" ? x : (x === undefined) ? pointX : constant(x);\n  y = typeof y === \"function\" ? y : (y === undefined) ? pointY : constant(y);\n\n  function line(data) {\n    var i,\n        n = (data = array(data)).length,\n        d,\n        defined0 = false,\n        buffer;\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) output.lineStart();\n        else output.lineEnd();\n      }\n      if (defined0) output.point(+x(d, i, data), +y(d, i, data));\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  line.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), line) : x;\n  };\n\n  line.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), line) : y;\n  };\n\n  line.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), line) : defined;\n  };\n\n  line.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n  };\n\n  line.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n  };\n\n  return line;\n}\n","import {path} from \"d3-path\";\nimport array from \"./array.js\";\nimport constant from \"./constant.js\";\nimport curveLinear from \"./curve/linear.js\";\nimport line from \"./line.js\";\nimport {x as pointX, y as pointY} from \"./point.js\";\n\nexport default function(x0, y0, y1) {\n  var x1 = null,\n      defined = constant(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  x0 = typeof x0 === \"function\" ? x0 : (x0 === undefined) ? pointX : constant(+x0);\n  y0 = typeof y0 === \"function\" ? y0 : (y0 === undefined) ? constant(0) : constant(+y0);\n  y1 = typeof y1 === \"function\" ? y1 : (y1 === undefined) ? pointY : constant(+y1);\n\n  function area(data) {\n    var i,\n        j,\n        k,\n        n = (data = array(data)).length,\n        d,\n        defined0 = false,\n        buffer,\n        x0z = new Array(n),\n        y0z = new Array(n);\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) {\n          j = i;\n          output.areaStart();\n          output.lineStart();\n        } else {\n          output.lineEnd();\n          output.lineStart();\n          for (k = i - 1; k >= j; --k) {\n            output.point(x0z[k], y0z[k]);\n          }\n          output.lineEnd();\n          output.areaEnd();\n        }\n      }\n      if (defined0) {\n        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);\n        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);\n      }\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  function arealine() {\n    return line().defined(defined).curve(curve).context(context);\n  }\n\n  area.x = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), x1 = null, area) : x0;\n  };\n\n  area.x0 = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), area) : x0;\n  };\n\n  area.x1 = function(_) {\n    return arguments.length ? (x1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : x1;\n  };\n\n  area.y = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), y1 = null, area) : y0;\n  };\n\n  area.y0 = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), area) : y0;\n  };\n\n  area.y1 = function(_) {\n    return arguments.length ? (y1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : y1;\n  };\n\n  area.lineX0 =\n  area.lineY0 = function() {\n    return arealine().x(x0).y(y0);\n  };\n\n  area.lineY1 = function() {\n    return arealine().x(x0).y(y1);\n  };\n\n  area.lineX1 = function() {\n    return arealine().x(x1).y(y0);\n  };\n\n  area.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), area) : defined;\n  };\n\n  area.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;\n  };\n\n  area.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;\n  };\n\n  return area;\n}\n","import {pi, tau} from \"../math.js\";\n\nexport default {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / pi);\n    context.moveTo(r, 0);\n    context.arc(0, 0, r, 0, tau);\n  }\n};\n","export default function() {}\n","export function point(that, x, y) {\n  that._context.bezierCurveTo(\n    (2 * that._x0 + that._x1) / 3,\n    (2 * that._y0 + that._y1) / 3,\n    (that._x0 + 2 * that._x1) / 3,\n    (that._y0 + 2 * that._y1) / 3,\n    (that._x0 + 4 * that._x1 + x) / 6,\n    (that._y0 + 4 * that._y1 + y) / 6\n  );\n}\n\nexport function Basis(context) {\n  this._context = context;\n}\n\nBasis.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3: point(this, this._x1, this._y1); // proceed\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nexport default function(context) {\n  return new Basis(context);\n}\n","import noop from \"../noop.js\";\nimport {point} from \"./basis.js\";\n\nfunction BasisClosed(context) {\n  this._context = context;\n}\n\nBasisClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x2, this._y2);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x2, this._y2);\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;\n      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;\n      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nexport default function(context) {\n  return new BasisClosed(context);\n}\n","import {point} from \"./basis.js\";\n\nfunction BasisOpen(context) {\n  this._context = context;\n}\n\nBasisOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;\n      case 3: this._point = 4; // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nexport default function(context) {\n  return new BasisOpen(context);\n}\n","import {Basis} from \"./basis.js\";\n\nfunction Bundle(context, beta) {\n  this._basis = new Basis(context);\n  this._beta = beta;\n}\n\nBundle.prototype = {\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n    this._basis.lineStart();\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        j = x.length - 1;\n\n    if (j > 0) {\n      var x0 = x[0],\n          y0 = y[0],\n          dx = x[j] - x0,\n          dy = y[j] - y0,\n          i = -1,\n          t;\n\n      while (++i <= j) {\n        t = i / j;\n        this._basis.point(\n          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),\n          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)\n        );\n      }\n    }\n\n    this._x = this._y = null;\n    this._basis.lineEnd();\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\nexport default (function custom(beta) {\n\n  function bundle(context) {\n    return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n  }\n\n  bundle.beta = function(beta) {\n    return custom(+beta);\n  };\n\n  return bundle;\n})(0.85);\n","export function point(that, x, y) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x),\n    that._y2 + that._k * (that._y1 - y),\n    that._x2,\n    that._y2\n  );\n}\n\nexport function Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: point(this, this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;\n      case 2: this._point = 3; // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(tension) {\n\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n","import noop from \"../noop.js\";\nimport {point} from \"./cardinal.js\";\n\nexport function CardinalClosed(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(tension) {\n\n  function cardinal(context) {\n    return new CardinalClosed(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n","import {point} from \"./cardinal.js\";\n\nexport function CardinalOpen(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(tension) {\n\n  function cardinal(context) {\n    return new CardinalOpen(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n","import {epsilon} from \"../math.js\";\nimport {Cardinal} from \"./cardinal.js\";\n\nexport function point(that, x, y) {\n  var x1 = that._x1,\n      y1 = that._y1,\n      x2 = that._x2,\n      y2 = that._y2;\n\n  if (that._l01_a > epsilon) {\n    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,\n        n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n  }\n\n  if (that._l23_a > epsilon) {\n    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,\n        m = 3 * that._l23_a * (that._l23_a + that._l12_a);\n    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;\n    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;\n  }\n\n  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);\n}\n\nfunction CatmullRom(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRom.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: this.point(this._x2, this._y2); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; // proceed\n      default: point(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n","import {CardinalClosed} from \"./cardinalClosed.js\";\nimport noop from \"../noop.js\";\nimport {point} from \"./catmullRom.js\";\n\nfunction CatmullRomClosed(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: point(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n","import {CardinalOpen} from \"./cardinalOpen.js\";\nimport {point} from \"./catmullRom.js\";\n\nfunction CatmullRomOpen(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // proceed\n      default: point(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n","import noop from \"../noop.js\";\n\nfunction LinearClosed(context) {\n  this._context = context;\n}\n\nLinearClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._point) this._context.closePath();\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    if (this._point) this._context.lineTo(x, y);\n    else this._point = 1, this._context.moveTo(x, y);\n  }\n};\n\nexport default function(context) {\n  return new LinearClosed(context);\n}\n","function sign(x) {\n  return x < 0 ? -1 : 1;\n}\n\n// Calculate the slopes of the tangents (Hermite-type interpolation) based on\n// the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n// NOV(II), P. 443, 1990.\nfunction slope3(that, x2, y2) {\n  var h0 = that._x1 - that._x0,\n      h1 = x2 - that._x1,\n      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),\n      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),\n      p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\n\n// Calculate a one-sided slope.\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0;\n  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n}\n\n// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n// \"you can express cubic Hermite interpolation in terms of cubic Bézier curves\n// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\nfunction point(that, t0, t1) {\n  var x0 = that._x0,\n      y0 = that._y0,\n      x1 = that._x1,\n      y1 = that._y1,\n      dx = (x1 - x0) / 3;\n  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);\n}\n\nfunction MonotoneX(context) {\n  this._context = context;\n}\n\nMonotoneX.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 =\n    this._t0 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n      case 3: point(this, this._t0, slope2(this, this._t0)); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    var t1 = NaN;\n\n    x = +x, y = +y;\n    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;\n      default: point(this, this._t0, t1 = slope3(this, x, y)); break;\n    }\n\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n    this._t0 = t1;\n  }\n}\n\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context);\n}\n\n(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {\n  MonotoneX.prototype.point.call(this, y, x);\n};\n\nfunction ReflectContext(context) {\n  this._context = context;\n}\n\nReflectContext.prototype = {\n  moveTo: function(x, y) { this._context.moveTo(y, x); },\n  closePath: function() { this._context.closePath(); },\n  lineTo: function(x, y) { this._context.lineTo(y, x); },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }\n};\n\nexport function monotoneX(context) {\n  return new MonotoneX(context);\n}\n\nexport function monotoneY(context) {\n  return new MonotoneY(context);\n}\n","function Natural(context) {\n  this._context = context;\n}\n\nNatural.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        n = x.length;\n\n    if (n) {\n      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);\n      if (n === 2) {\n        this._context.lineTo(x[1], y[1]);\n      } else {\n        var px = controlPoints(x),\n            py = controlPoints(y);\n        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);\n        }\n      }\n    }\n\n    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n    this._x = this._y = null;\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\n// See https://www.particleincell.com/2012/bezier-splines/ for derivation.\nfunction controlPoints(x) {\n  var i,\n      n = x.length - 1,\n      m,\n      a = new Array(n),\n      b = new Array(n),\n      r = new Array(n);\n  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];\n  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];\n  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];\n  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];\n  a[n - 1] = r[n - 1] / b[n - 1];\n  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];\n  b[n - 1] = (x[n] + a[n - 1]) / 2;\n  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];\n  return [a, b];\n}\n\nexport default function(context) {\n  return new Natural(context);\n}\n","function Step(context, t) {\n  this._context = context;\n  this._t = t;\n}\n\nStep.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: {\n        if (this._t <= 0) {\n          this._context.lineTo(this._x, y);\n          this._context.lineTo(x, y);\n        } else {\n          var x1 = this._x * (1 - this._t) + x * this._t;\n          this._context.lineTo(x1, this._y);\n          this._context.lineTo(x1, y);\n        }\n        break;\n      }\n    }\n    this._x = x, this._y = y;\n  }\n};\n\nexport default function(context) {\n  return new Step(context, 0.5);\n}\n\nexport function stepBefore(context) {\n  return new Step(context, 0);\n}\n\nexport function stepAfter(context) {\n  return new Step(context, 1);\n}\n","import {hasOwnProperty} from 'vega-util';\n\nimport {\n  curveBasis,\n  curveBasisClosed,\n  curveBasisOpen,\n  curveBundle,\n  curveCardinal,\n  curveCardinalClosed,\n  curveCardinalOpen,\n  curveCatmullRom,\n  curveCatmullRomClosed,\n  curveCatmullRomOpen,\n  curveLinear,\n  curveLinearClosed,\n  curveMonotoneX,\n  curveMonotoneY,\n  curveNatural,\n  curveStep,\n  curveStepAfter,\n  curveStepBefore\n} from 'd3-shape';\n\nconst lookup = {\n  'basis': {\n    curve: curveBasis\n  },\n  'basis-closed': {\n    curve: curveBasisClosed\n  },\n  'basis-open': {\n    curve: curveBasisOpen\n  },\n  'bundle': {\n    curve: curveBundle,\n    tension: 'beta',\n    value: 0.85\n  },\n  'cardinal': {\n    curve: curveCardinal,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-open': {\n    curve: curveCardinalOpen,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-closed': {\n    curve: curveCardinalClosed,\n    tension: 'tension',\n    value: 0\n  },\n  'catmull-rom': {\n    curve: curveCatmullRom,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-closed': {\n    curve: curveCatmullRomClosed,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-open': {\n    curve: curveCatmullRomOpen,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'linear': {\n    curve: curveLinear\n  },\n  'linear-closed': {\n    curve: curveLinearClosed\n  },\n  'monotone': {\n    horizontal: curveMonotoneY,\n    vertical:   curveMonotoneX\n  },\n  'natural': {\n    curve: curveNatural\n  },\n  'step': {\n    curve: curveStep\n  },\n  'step-after': {\n    curve: curveStepAfter\n  },\n  'step-before': {\n    curve: curveStepBefore\n  }\n};\n\nexport default function curves(type, orientation, tension) {\n  var entry = hasOwnProperty(lookup, type) && lookup[type],\n      curve = null;\n\n  if (entry) {\n    curve = entry.curve || entry[orientation || 'vertical'];\n    if (entry.tension && tension != null) {\n      curve = curve[entry.tension](tension);\n    }\n  }\n\n  return curve;\n}\n","// Path parsing and rendering code adapted from fabric.js -- Thanks!\nconst cmdlen = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n      regexp = [\n        /([MLHVCSQTAZmlhvcsqtaz])/g,\n        /###/,\n        /(\\.\\d+)(\\.\\d)/g,\n        /(\\d)([-+])/g,\n        /\\s|,|###/\n      ];\n\nexport default function(pathstr) {\n  const result = [];\n  let curr,\n      chunks,\n      parsed, param,\n      cmd, len, i, j, n, m;\n\n  // First, break path into command sequence\n  const path = pathstr\n    .slice()\n    .replace(regexp[0], '###$1')\n    .split(regexp[1])\n    .slice(1);\n\n  // Next, parse each command in turn\n  for (i = 0, n = path.length; i < n; ++i) {\n    curr = path[i];\n    chunks = curr\n      .slice(1)\n      .trim()\n      .replace(regexp[2], '$1###$2')\n      .replace(regexp[3], '$1###$2')\n      .split(regexp[4]);\n    cmd = curr.charAt(0);\n\n    parsed = [cmd];\n    for (j = 0, m = chunks.length; j < m; ++j) {\n      if ((param = +chunks[j]) === param) { // not NaN\n        parsed.push(param);\n      }\n    }\n\n    len = cmdlen[cmd.toLowerCase()];\n    if (parsed.length - 1 > len) {\n      const m = parsed.length;\n      j = 1;\n      result.push([cmd].concat(parsed.slice(j, j += len)));\n\n      // handle implicit lineTo (#2803)\n      cmd = cmd === 'M' ? 'L' : cmd === 'm' ? 'l' : cmd;\n\n      for (; j < m; j += len) {\n        result.push([cmd].concat(parsed.slice(j, j+len)));\n      }\n    }\n    else {\n      result.push(parsed);\n    }\n  }\n\n  return result;\n}\n","export const DegToRad = Math.PI / 180;\nexport const Epsilon = 1e-14;\nexport const HalfPi = Math.PI / 2;\nexport const Tau = Math.PI * 2;\nexport const HalfSqrt3 = Math.sqrt(3) / 2;\n","import {DegToRad, HalfPi, Tau} from '../util/constants';\n\nexport var segmentCache = {};\nexport var bezierCache = {};\n\nvar join = [].join;\n\n// Copied from Inkscape svgtopdf, thanks!\nexport function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  const key = join.call(arguments);\n  if (segmentCache[key]) {\n    return segmentCache[key];\n  }\n\n  const th = rotateX * DegToRad;\n  const sin_th = Math.sin(th);\n  const cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  let pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  const a00 = cos_th / rx;\n  const a01 = sin_th / rx;\n  const a10 = (-sin_th) / ry;\n  const a11 = (cos_th) / ry;\n  const x0 = a00 * ox + a01 * oy;\n  const y0 = a10 * ox + a11 * oy;\n  const x1 = a00 * x + a01 * y;\n  const y1 = a10 * x + a11 * y;\n\n  const d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  let sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  let sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  const xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  const yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  const th0 = Math.atan2(y0-yc, x0-xc);\n  const th1 = Math.atan2(y1-yc, x1-xc);\n\n  let th_arc = th1-th0;\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += Tau;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= Tau;\n  }\n\n  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));\n  const result = [];\n  for (let i=0; i<segs; ++i) {\n    const th2 = th0 + i * th_arc / segs;\n    const th3 = th0 + (i+1) * th_arc / segs;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (segmentCache[key] = result);\n}\n\nexport function bezier(params) {\n  const key = join.call(params);\n  if (bezierCache[key]) {\n    return bezierCache[key];\n  }\n\n  var cx = params[0],\n      cy = params[1],\n      th0 = params[2],\n      th1 = params[3],\n      rx = params[4],\n      ry = params[5],\n      sin_th = params[6],\n      cos_th = params[7];\n\n  const a00 = cos_th * rx;\n  const a01 = -sin_th * ry;\n  const a10 = sin_th * rx;\n  const a11 = cos_th * ry;\n\n  const cos_th0 = Math.cos(th0);\n  const sin_th0 = Math.sin(th0);\n  const cos_th1 = Math.cos(th1);\n  const sin_th1 = Math.sin(th1);\n\n  const th_half = 0.5 * (th1 - th0);\n  const sin_th_h2 = Math.sin(th_half * 0.5);\n  const t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  const x1 = cx + cos_th0 - t * sin_th0;\n  const y1 = cy + sin_th0 + t * cos_th0;\n  const x3 = cx + cos_th1;\n  const y3 = cy + sin_th1;\n  const x2 = x3 + t * sin_th1;\n  const y2 = y3 - t * cos_th1;\n\n  return (bezierCache[key] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n","import {bezier, segments} from './arc';\n\nconst temp = ['l', 0, 0, 0, 0, 0, 0, 0];\n\nfunction scale(current, sX, sY) {\n  const c = (temp[0] = current[0]);\n  if (c === 'a' || c === 'A') {\n    temp[1] = sX * current[1];\n    temp[2] = sY * current[2];\n    temp[3] = current[3];\n    temp[4] = current[4];\n    temp[5] = current[5];\n    temp[6] = sX * current[6];\n    temp[7] = sY * current[7];\n  } else if (c === 'h' || c === 'H') {\n    temp[1] = sX * current[1];\n  } else if (c === 'v' || c === 'V') {\n    temp[1] = sY * current[1];\n  } else {\n    for (var i=1, n=current.length; i<n; ++i) {\n      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];\n    }\n  }\n  return temp;\n}\n\nexport default function(context, path, l, t, sX, sY) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  if (l == null) l = 0;\n  if (t == null) t = 0;\n  if (sX == null) sX = 1;\n  if (sY == null) sY = sX;\n\n  if (context.beginPath) context.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n    if (sX !== 1 || sY !== 1) {\n      current = scale(current, sX, sY);\n    }\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        context.moveTo(x + l, y + t);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        context.moveTo(x + l, y + t);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        context.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        context.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n\n        // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        context.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        context.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        context.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        context.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'a':\n        drawArc(context, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ]);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(context, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ]);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        context.closePath();\n        break;\n    }\n    previous = current;\n  }\n}\n\nfunction drawArc(context, x, y, coords) {\n  const seg = segments(\n    coords[5], // end x\n    coords[6], // end y\n    coords[0], // radius x\n    coords[1], // radius y\n    coords[3], // large flag\n    coords[4], // sweep flag\n    coords[2], // rotation\n    x, y\n  );\n  for (let i=0; i<seg.length; ++i) {\n    const bez = bezier(seg[i]);\n    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);\n  }\n}\n","import pathParse from './parse';\nimport pathRender from './render';\nimport {HalfSqrt3, Tau} from '../util/constants';\nimport {hasOwnProperty} from 'vega-util';\n\nconst Tan30 = 0.5773502691896257;\n\nconst builtins = {\n  'circle': {\n    draw: function(context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(r, 0);\n      context.arc(0, 0, r, 0, Tau);\n    }\n  },\n  'cross': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          s = r / 2.5;\n      context.moveTo(-r, -s);\n      context.lineTo(-r, s);\n      context.lineTo(-s, s);\n      context.lineTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, s);\n      context.lineTo(r, s);\n      context.lineTo(r, -s);\n      context.lineTo(s, -s);\n      context.lineTo(s, -r);\n      context.lineTo(-s, -r);\n      context.lineTo(-s, -s);\n      context.closePath();\n    }\n  },\n  'diamond': {\n    draw: function(context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(0, -r);\n      context.lineTo(r, 0);\n      context.lineTo(0, r);\n      context.closePath();\n    }\n  },\n  'square': {\n    draw: function(context, size) {\n      var w = Math.sqrt(size),\n          x = -w / 2;\n      context.rect(x, x, w, w);\n    }\n  },\n  'arrow': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          s = r / 7,\n          t = r / 2.5,\n          v = r / 8;\n      context.moveTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, -v);\n      context.lineTo(t, -v);\n      context.lineTo(0, -r);\n      context.lineTo(-t, -v);\n      context.lineTo(-s, -v);\n      context.closePath();\n    }\n  },\n  'wedge': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r,\n          o = (h - r * Tan30),\n          b = r / 4;\n      context.moveTo(0, -h - o);\n      context.lineTo(-b, h - o);\n      context.lineTo(b, h - o);\n      context.closePath();\n    }\n  },\n  'triangle': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r,\n          o = (h - r * Tan30);\n      context.moveTo(0, -h - o);\n      context.lineTo(-r, h - o);\n      context.lineTo(r, h - o);\n      context.closePath();\n    }\n  },\n  'triangle-up': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(0, -h);\n      context.lineTo(-r, h);\n      context.lineTo(r, h);\n      context.closePath();\n    }\n  },\n  'triangle-down': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(0, h);\n      context.lineTo(-r, -h);\n      context.lineTo(r, -h);\n      context.closePath();\n    }\n  },\n  'triangle-right': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(h, 0);\n      context.lineTo(-h, -r);\n      context.lineTo(-h, r);\n      context.closePath();\n    }\n  },\n  'triangle-left': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(-h, 0);\n      context.lineTo(h, -r);\n      context.lineTo(h, r);\n      context.closePath();\n    }\n  },\n  'stroke': {\n    draw: function(context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(r, 0);\n    }\n  }\n};\n\nexport default function symbols(_) {\n  return hasOwnProperty(builtins, _) ? builtins[_] : customSymbol(_);\n}\n\nvar custom = {};\n\nfunction customSymbol(path) {\n  if (!hasOwnProperty(custom, path)) {\n    const parsed = pathParse(path);\n    custom[path] = {\n      draw: function(context, size) {\n        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);\n      }\n    };\n  }\n  return custom[path];\n}\n","import {path} from 'd3-path';\n\n// See http://spencermortensen.com/articles/bezier-circle/\nconst C = 0.448084975506; // C = 1 - c\n\nfunction rectangleX(d) {\n  return d.x;\n}\n\nfunction rectangleY(d) {\n  return d.y;\n}\n\nfunction rectangleWidth(d) {\n  return d.width;\n}\n\nfunction rectangleHeight(d) {\n  return d.height;\n}\n\nfunction number(_) {\n  return typeof _ === 'function' ? _ : () => +_;\n}\n\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n}\n\nexport default function() {\n  var x = rectangleX,\n      y = rectangleY,\n      width = rectangleWidth,\n      height = rectangleHeight,\n      crTL = number(0),\n      crTR = crTL,\n      crBL = crTL,\n      crBR = crTL,\n      context = null;\n\n  function rectangle(_, x0, y0) {\n    var buffer,\n        x1 = x0 != null ? x0 : +x.call(this, _),\n        y1 = y0 != null ? y0 : +y.call(this, _),\n        w  = +width.call(this, _),\n        h  = +height.call(this, _),\n        s  = Math.min(w, h) / 2,\n        tl = clamp(+crTL.call(this, _), 0, s),\n        tr = clamp(+crTR.call(this, _), 0, s),\n        bl = clamp(+crBL.call(this, _), 0, s),\n        br = clamp(+crBR.call(this, _), 0, s);\n\n    if (!context) context = buffer = path();\n\n    if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {\n      context.rect(x1, y1, w, h);\n    } else {\n      var x2 = x1 + w,\n          y2 = y1 + h;\n      context.moveTo(x1 + tl, y1);\n      context.lineTo(x2 - tr, y1);\n      context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);\n      context.lineTo(x2, y2 - br);\n      context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);\n      context.lineTo(x1 + bl, y2);\n      context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);\n      context.lineTo(x1, y1 + tl);\n      context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);\n      context.closePath();\n    }\n\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n\n  rectangle.x = function(_) {\n    if (arguments.length) {\n      x = number(_);\n      return rectangle;\n    } else {\n      return x;\n    }\n  };\n\n  rectangle.y = function(_) {\n    if (arguments.length) {\n      y = number(_);\n      return rectangle;\n    } else {\n      return y;\n    }\n  };\n\n  rectangle.width = function(_) {\n    if (arguments.length) {\n      width = number(_);\n      return rectangle;\n    } else {\n      return width;\n    }\n  };\n\n  rectangle.height = function(_) {\n    if (arguments.length) {\n      height = number(_);\n      return rectangle;\n    } else {\n      return height;\n    }\n  };\n\n  rectangle.cornerRadius = function(tl, tr, br, bl) {\n    if (arguments.length) {\n      crTL = number(tl);\n      crTR = tr != null ? number(tr) : crTL;\n      crBR = br != null ? number(br) : crTL;\n      crBL = bl != null ? number(bl) : crTR;\n      return rectangle;\n    } else {\n      return crTL;\n    }\n  };\n\n  rectangle.context = function(_) {\n    if (arguments.length) {\n      context = _ == null ? null : _;\n      return rectangle;\n    } else {\n      return context;\n    }\n  };\n\n  return rectangle;\n}\n","import {Tau} from '../util/constants';\nimport {path} from 'd3-path';\n\nexport default function() {\n  var x,\n      y,\n      size,\n      defined,\n      context = null,\n      ready, x1, y1, r1;\n\n  function point(x2, y2, w2) {\n    const r2 = w2 / 2;\n\n    if (ready) {\n      var ux = y1 - y2,\n          uy = x2 - x1;\n\n      if (ux || uy) {\n        // get normal vector\n        var ud = Math.sqrt(ux * ux + uy * uy),\n            rx = (ux /= ud) * r1,\n            ry = (uy /= ud) * r1,\n            t = Math.atan2(uy, ux);\n\n        // draw segment\n        context.moveTo(x1 - rx, y1 - ry);\n        context.lineTo(x2 - ux * r2, y2 - uy * r2);\n        context.arc(x2, y2, r2, t - Math.PI, t);\n        context.lineTo(x1 + rx, y1 + ry);\n        context.arc(x1, y1, r1, t, t + Math.PI);\n      } else {\n        context.arc(x2, y2, r2, 0, Tau);\n      }\n      context.closePath();\n    } else {\n      ready = 1;\n    }\n    x1 = x2;\n    y1 = y2;\n    r1 = r2;\n  }\n\n  function trail(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n\n    if (context == null) context = buffer = path();\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) ready = 0;\n      }\n      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));\n    }\n\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n\n  trail.x = function(_) {\n    if (arguments.length) {\n      x = _;\n      return trail;\n    } else {\n      return x;\n    }\n  };\n\n  trail.y = function(_) {\n    if (arguments.length) {\n      y = _;\n      return trail;\n    } else {\n      return y;\n    }\n  };\n\n  trail.size = function(_) {\n    if (arguments.length) {\n      size = _;\n      return trail;\n    } else {\n      return size;\n    }\n  };\n\n  trail.defined = function(_) {\n    if (arguments.length) {\n      defined = _;\n      return trail;\n    } else {\n      return defined;\n    }\n  };\n\n  trail.context = function(_) {\n    if (arguments.length) {\n      if (_ == null) {\n        context = null;\n      } else {\n        context = _;\n      }\n      return trail;\n    } else {\n      return context;\n    }\n  };\n\n  return trail;\n}\n","import curves from './curves';\nimport symbols from './symbols';\n\nimport {default as vg_rect} from './rectangle';\nimport {default as vg_trail} from './trail';\n\nimport {\n  arc as d3_arc,\n  area as d3_area,\n  line as d3_line,\n  symbol as d3_symbol\n} from 'd3-shape';\n\nfunction value(a, b) {\n  return a != null ? a : b;\n}\n\nconst x =  item => item.x || 0,\n      y =  item => item.y || 0,\n      w =  item => item.width || 0,\n      h =  item => item.height || 0,\n      xw = item => (item.x || 0) + (item.width || 0),\n      yh = item => (item.y || 0) + (item.height || 0),\n      sa = item => item.startAngle || 0,\n      ea = item => item.endAngle || 0,\n      pa = item => item.padAngle || 0,\n      ir = item => item.innerRadius || 0,\n      or = item => item.outerRadius || 0,\n      cr = item => item.cornerRadius || 0,\n      tl = item => value(item.cornerRadiusTopLeft, item.cornerRadius) || 0,\n      tr = item => value(item.cornerRadiusTopRight, item.cornerRadius) || 0,\n      br = item => value(item.cornerRadiusBottomRight, item.cornerRadius) || 0,\n      bl = item => value(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,\n      sz = item => value(item.size, 64),\n      ts = item => item.size || 1,\n      def = item => !(item.defined === false),\n      type = item => symbols(item.shape || 'circle');\n\nconst arcShape    = d3_arc().startAngle(sa).endAngle(ea).padAngle(pa)\n                      .innerRadius(ir).outerRadius(or).cornerRadius(cr),\n      areavShape  = d3_area().x(x).y1(y).y0(yh).defined(def),\n      areahShape  = d3_area().y(y).x1(x).x0(xw).defined(def),\n      lineShape   = d3_line().x(x).y(y).defined(def),\n      rectShape   = vg_rect().x(x).y(y).width(w).height(h)\n                      .cornerRadius(tl, tr, br, bl),\n      symbolShape = d3_symbol().type(type).size(sz),\n      trailShape  = vg_trail().x(x).y(y).defined(def).size(ts);\n\nexport function hasCornerRadius(item) {\n  return item.cornerRadius\n    || item.cornerRadiusTopLeft\n    || item.cornerRadiusTopRight\n    || item.cornerRadiusBottomRight\n    || item.cornerRadiusBottomLeft;\n}\n\nexport function arc(context, item) {\n  return arcShape.context(context)(item);\n}\n\nexport function area(context, items) {\n  const item = items[0],\n        interp = item.interpolate || 'linear';\n  return (item.orient === 'horizontal' ? areahShape : areavShape)\n    .curve(curves(interp, item.orient, item.tension))\n    .context(context)(items);\n}\n\nexport function line(context, items) {\n  const item = items[0],\n        interp = item.interpolate || 'linear';\n  return lineShape.curve(curves(interp, item.orient, item.tension))\n    .context(context)(items);\n}\n\nexport function rectangle(context, item, x, y) {\n  return rectShape.context(context)(item, x, y);\n}\n\nexport function shape(context, item) {\n  return (item.mark.shape || item.shape)\n    .context(context)(item);\n}\n\nexport function symbol(context, item) {\n  return symbolShape.context(context)(item);\n}\n\nexport function trail(context, items) {\n  return trailShape.context(context)(items);\n}\n","import {path} from \"d3-path\";\nimport circle from \"./symbol/circle.js\";\nimport cross from \"./symbol/cross.js\";\nimport diamond from \"./symbol/diamond.js\";\nimport star from \"./symbol/star.js\";\nimport square from \"./symbol/square.js\";\nimport triangle from \"./symbol/triangle.js\";\nimport wye from \"./symbol/wye.js\";\nimport constant from \"./constant.js\";\n\nexport var symbols = [\n  circle,\n  cross,\n  diamond,\n  square,\n  star,\n  triangle,\n  wye\n];\n\nexport default function(type, size) {\n  var context = null;\n  type = typeof type === \"function\" ? type : constant(type || circle);\n  size = typeof size === \"function\" ? size : constant(size === undefined ? 64 : +size);\n\n  function symbol() {\n    var buffer;\n    if (!context) context = buffer = path();\n    type.apply(this, arguments).draw(context, +size.apply(this, arguments));\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  symbol.type = function(_) {\n    return arguments.length ? (type = typeof _ === \"function\" ? _ : constant(_), symbol) : type;\n  };\n\n  symbol.size = function(_) {\n    return arguments.length ? (size = typeof _ === \"function\" ? _ : constant(+_), symbol) : size;\n  };\n\n  symbol.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, symbol) : context;\n  };\n\n  return symbol;\n}\n","import {hasCornerRadius, rectangle} from '../../path/shapes';\nimport {isFunction} from 'vega-util';\n\nvar clip_id = 1;\n\nexport function resetSVGClipId() {\n  clip_id = 1;\n}\n\nexport default function(renderer, item, size) {\n  var clip = item.clip,\n      defs = renderer._defs,\n      id = item.clip_id || (item.clip_id = 'clip' + clip_id++),\n      c = defs.clipping[id] || (defs.clipping[id] = {id: id});\n\n  if (isFunction(clip)) {\n    c.path = clip(null);\n  } else if (hasCornerRadius(size)) {\n    c.path = rectangle(null, size, 0, 0);\n  } else {\n    c.width = size.width || 0;\n    c.height = size.height || 0;\n  }\n\n  return 'url(#' + id + ')';\n}\n","export default function Bounds(b) {\n  this.clear();\n  if (b) this.union(b);\n}\n\nBounds.prototype = {\n  clone() {\n    return new Bounds(this);\n  },\n\n  clear() {\n    this.x1 = +Number.MAX_VALUE;\n    this.y1 = +Number.MAX_VALUE;\n    this.x2 = -Number.MAX_VALUE;\n    this.y2 = -Number.MAX_VALUE;\n    return this;\n  },\n\n  empty() {\n    return (\n      this.x1 === +Number.MAX_VALUE &&\n      this.y1 === +Number.MAX_VALUE &&\n      this.x2 === -Number.MAX_VALUE &&\n      this.y2 === -Number.MAX_VALUE\n    );\n  },\n\n  equals(b) {\n    return (\n      this.x1 === b.x1 &&\n      this.y1 === b.y1 &&\n      this.x2 === b.x2 &&\n      this.y2 === b.y2\n    );\n  },\n\n  set(x1, y1, x2, y2) {\n    if (x2 < x1) {\n      this.x2 = x1;\n      this.x1 = x2;\n    } else {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n    if (y2 < y1) {\n      this.y2 = y1;\n      this.y1 = y2;\n    } else {\n      this.y1 = y1;\n      this.y2 = y2;\n    }\n    return this;\n  },\n\n  add(x, y) {\n    if (x < this.x1) this.x1 = x;\n    if (y < this.y1) this.y1 = y;\n    if (x > this.x2) this.x2 = x;\n    if (y > this.y2) this.y2 = y;\n    return this;\n  },\n\n  expand(d) {\n    this.x1 -= d;\n    this.y1 -= d;\n    this.x2 += d;\n    this.y2 += d;\n    return this;\n  },\n\n  round() {\n    this.x1 = Math.floor(this.x1);\n    this.y1 = Math.floor(this.y1);\n    this.x2 = Math.ceil(this.x2);\n    this.y2 = Math.ceil(this.y2);\n    return this;\n  },\n\n  scale(s) {\n    this.x1 *= s;\n    this.y1 *= s;\n    this.x2 *= s;\n    this.y2 *= s;\n    return this;\n  },\n\n  translate(dx, dy) {\n    this.x1 += dx;\n    this.x2 += dx;\n    this.y1 += dy;\n    this.y2 += dy;\n    return this;\n  },\n\n  rotate(angle, x, y) {\n    const p = this.rotatedPoints(angle, x, y);\n    return this.clear()\n      .add(p[0], p[1])\n      .add(p[2], p[3])\n      .add(p[4], p[5])\n      .add(p[6], p[7]);\n  },\n\n  rotatedPoints(angle, x, y) {\n    var {x1, y1, x2, y2} = this,\n        cos = Math.cos(angle),\n        sin = Math.sin(angle),\n        cx = x - x * cos + y * sin,\n        cy = y - x * sin - y * cos;\n\n    return [\n      cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy,\n      cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy,\n      cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy,\n      cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy\n    ];\n  },\n\n  union(b) {\n    if (b.x1 < this.x1) this.x1 = b.x1;\n    if (b.y1 < this.y1) this.y1 = b.y1;\n    if (b.x2 > this.x2) this.x2 = b.x2;\n    if (b.y2 > this.y2) this.y2 = b.y2;\n    return this;\n  },\n\n  intersect(b) {\n    if (b.x1 > this.x1) this.x1 = b.x1;\n    if (b.y1 > this.y1) this.y1 = b.y1;\n    if (b.x2 < this.x2) this.x2 = b.x2;\n    if (b.y2 < this.y2) this.y2 = b.y2;\n    return this;\n  },\n\n  encloses(b) {\n    return b && (\n      this.x1 <= b.x1 &&\n      this.x2 >= b.x2 &&\n      this.y1 <= b.y1 &&\n      this.y2 >= b.y2\n    );\n  },\n\n  alignsWith(b) {\n    return b && (\n      this.x1 == b.x1 ||\n      this.x2 == b.x2 ||\n      this.y1 == b.y1 ||\n      this.y2 == b.y2\n    );\n  },\n\n  intersects(b) {\n    return b && !(\n      this.x2 < b.x1 ||\n      this.x1 > b.x2 ||\n      this.y2 < b.y1 ||\n      this.y1 > b.y2\n    );\n  },\n\n  contains(x, y) {\n    return !(\n      x < this.x1 ||\n      x > this.x2 ||\n      y < this.y1 ||\n      y > this.y2\n    );\n  },\n\n  width() {\n    return this.x2 - this.x1;\n  },\n\n  height() {\n    return this.y2 - this.y1;\n  }\n};\n","import Bounds from './Bounds';\n\nexport default function Item(mark) {\n  this.mark = mark;\n  this.bounds = (this.bounds || new Bounds());\n}\n","import Item from './Item';\nimport {inherits} from 'vega-util';\n\nexport default function GroupItem(mark) {\n  Item.call(this, mark);\n  this.items = (this.items || []);\n}\n\ninherits(GroupItem, Item);\n","import {image} from 'vega-canvas';\nimport {loader} from 'vega-loader';\nimport {hasOwnProperty} from 'vega-util';\n\nexport default function ResourceLoader(customLoader) {\n  this._pending = 0;\n  this._loader = customLoader || loader();\n}\n\nfunction increment(loader) {\n  loader._pending += 1;\n}\n\nfunction decrement(loader) {\n  loader._pending -= 1;\n}\n\nResourceLoader.prototype = {\n  pending() {\n    return this._pending;\n  },\n\n  sanitizeURL(uri) {\n    const loader = this;\n    increment(loader);\n\n    return loader._loader.sanitize(uri, {context:'href'})\n      .then(opt => {\n        decrement(loader);\n        return opt;\n      })\n      .catch(() => {\n        decrement(loader);\n        return null;\n      });\n  },\n\n  loadImage(uri) {\n    const loader = this,\n          Image = image();\n    increment(loader);\n\n    return loader._loader\n      .sanitize(uri, {context: 'image'})\n      .then(opt => {\n        const url = opt.href;\n        if (!url || !Image) throw {url: url};\n\n        const img = new Image();\n\n        // set crossOrigin only if cors is defined; empty string sets anonymous mode\n        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin\n        const cors = hasOwnProperty(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';\n        if (cors != null) img.crossOrigin = cors;\n\n        // attempt to load image resource\n        img.onload = () => decrement(loader);\n        img.onerror = () => decrement(loader);\n        img.src = url;\n\n        return img;\n      })\n      .catch(e => {\n        decrement(loader);\n        return {complete: false, width: 0, height: 0, src: e && e.url || ''};\n      });\n  },\n\n  ready() {\n    const loader = this;\n    return new Promise(accept => {\n      function poll(value) {\n        if (!loader.pending()) accept(value);\n        else setTimeout(() => { poll(true); }, 10);\n      }\n      poll(false);\n    });\n  }\n};\n","export default function(bounds, item, miter) {\n  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {\n    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;\n    bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));\n  }\n  return bounds;\n}\n\nfunction miterAdjustment(item, strokeWidth) {\n  // TODO: more sophisticated adjustment? Or miter support in boundContext?\n  return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;\n}\n","import {DegToRad, Epsilon, HalfPi, Tau} from '../util/constants';\n\nconst circleThreshold = Tau - 1e-8;\nlet bounds, lx, ly, rot, ma, mb, mc, md;\n\nconst add = (x, y) => bounds.add(x, y);\nconst addL = (x, y) => add(lx = x, ly = y);\nconst addX = x => add(x, bounds.y1);\nconst addY = y => add(bounds.x1, y);\n\nconst px = (x, y) => ma * x + mc * y;\nconst py = (x, y) => mb * x + md * y;\nconst addp = (x, y) => add(px(x, y), py(x, y));\nconst addpL = (x, y) => addL(px(x, y), py(x, y));\n\nexport default function(_, deg) {\n  bounds = _;\n  if (deg) {\n    rot = deg * DegToRad;\n    ma = md = Math.cos(rot);\n    mb = Math.sin(rot);\n    mc = -mb;\n  } else {\n    ma = md = 1;\n    rot = mb = mc = 0;\n  }\n  return context;\n}\n\nconst context = {\n  beginPath() {},\n  closePath() {},\n\n  moveTo: addpL,\n  lineTo: addpL,\n\n  rect(x, y, w, h) {\n    if (rot) {\n      addp(x + w, y);\n      addp(x + w, y + h);\n      addp(x, y + h);\n      addpL(x, y);\n    } else {\n      add(x + w, y + h);\n      addL(x, y);\n    }\n  },\n\n  quadraticCurveTo(x1, y1, x2, y2) {\n    const px1 = px(x1, y1),\n          py1 = py(x1, y1),\n          px2 = px(x2, y2),\n          py2 = py(x2, y2);\n    quadExtrema(lx, px1, px2, addX);\n    quadExtrema(ly, py1, py2, addY);\n    addL(px2, py2);\n  },\n\n  bezierCurveTo(x1, y1, x2, y2, x3, y3) {\n    const px1 = px(x1, y1),\n          py1 = py(x1, y1),\n          px2 = px(x2, y2),\n          py2 = py(x2, y2),\n          px3 = px(x3, y3),\n          py3 = py(x3, y3);\n    cubicExtrema(lx, px1, px2, px3, addX);\n    cubicExtrema(ly, py1, py2, py3, addY);\n    addL(px3, py3);\n  },\n\n  arc(cx, cy, r, sa, ea, ccw) {\n    sa += rot;\n    ea += rot;\n\n    // store last point on path\n    lx = r * Math.cos(ea) + cx;\n    ly = r * Math.sin(ea) + cy;\n\n    if (Math.abs(ea - sa) > circleThreshold) {\n      // treat as full circle\n      add(cx - r, cy - r);\n      add(cx + r, cy + r);\n    } else {\n      const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);\n      let s, i;\n\n      // sample end points\n      update(sa);\n      update(ea);\n\n      // sample interior points aligned with 90 degrees\n      if (ea !== sa) {\n        sa = sa % Tau; if (sa < 0) sa += Tau;\n        ea = ea % Tau; if (ea < 0) ea += Tau;\n\n        if (ea < sa) {\n          ccw = !ccw; // flip direction\n          s = sa; sa = ea; ea = s; // swap end-points\n        }\n\n        if (ccw) {\n          ea -= Tau;\n          s = sa - (sa % HalfPi);\n          for (i=0; i<4 && s>ea; ++i, s-=HalfPi) update(s);\n        } else {\n          s = sa - (sa % HalfPi) + HalfPi;\n          for (i=0; i<4 && s<ea; ++i, s=s+HalfPi) update(s);\n        }\n      }\n    }\n  }\n};\n\nfunction quadExtrema(x0, x1, x2, cb) {\n  const t = (x0 - x1) / (x0 + x2 - 2 * x1);\n  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);\n}\n\nfunction cubicExtrema(x0, x1, x2, x3, cb) {\n  const a = x3 - x0 + 3 * x1 - 3 * x2,\n        b = x0 + x2 - 2 * x1,\n        c = x0 - x1;\n\n  let t0 = 0, t1 = 0, r;\n\n  // solve for parameter t\n  if (Math.abs(a) > Epsilon) {\n    // quadratic equation\n    r = b * b + c * a;\n    if (r >= 0) {\n      r = Math.sqrt(r);\n      t0 = (-b + r) / a;\n      t1 = (-b - r) / a;\n    }\n  } else {\n    // linear equation\n    t0 = 0.5 * c / b;\n  }\n\n  // calculate position\n  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));\n  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));\n}\n\nfunction cubic(t, x0, x1, x2, x3) {\n  const s = 1 - t, s2 = s * s, t2 = t * t;\n  return (s2 * s * x0) + (3 * s2 * t * x1) + (3 * s * t2 * x2) + (t2 * t * x3);\n}\n","import {canvas} from 'vega-canvas';\n\nexport var context = (context = canvas(1,1))\n  ? context.getContext('2d')\n  : null;\n","import {context} from './canvas/context';\nimport Bounds from '../Bounds';\n\nconst b = new Bounds();\n\nexport function intersectPath(draw) {\n  return function(item, brush) {\n    // rely on (inaccurate) bounds intersection if no context\n    if (!context) return true;\n\n    // add path to offscreen graphics context\n    draw(context, item);\n\n    // get bounds intersection region\n    b.clear().union(item.bounds).intersect(brush).round();\n    const {x1, y1, x2, y2} = b;\n\n    // iterate over intersection region\n    // perform fine grained inclusion test\n    for (let y = y1; y <= y2; ++y) {\n      for (let x = x1; x <= x2; ++x) {\n        if (context.isPointInPath(x, y)) {\n          return true;\n        }\n      }\n    }\n\n    // false if no hits in intersection region\n    return false;\n  };\n}\n\nexport function intersectPoint(item, box) {\n  return box.contains(item.x || 0, item.y || 0);\n}\n\nexport function intersectRect(item, box) {\n  const x = item.x || 0,\n        y = item.y || 0,\n        w = item.width || 0,\n        h = item.height || 0;\n  return box.intersects(b.set(x, y, x + w, y + h));\n}\n\nexport function intersectRule(item, box) {\n  const x = item.x || 0,\n        y = item.y || 0,\n        x2 = item.x2 != null ? item.x2 : x,\n        y2 = item.y2 != null ? item.y2 : y;\n  return intersectBoxLine(box, x, y, x2, y2);\n}\n\nexport function intersectBoxLine(box, x, y, u, v) {\n  const {x1, y1, x2, y2} = box,\n        dx = u - x,\n        dy = v - y;\n\n  let t0 = 0, t1 = 1, p, q, r, e;\n\n  for (e=0; e<4; ++e) {\n    if (e === 0) { p = -dx; q = -(x1 - x); }\n    if (e === 1) { p =  dx; q =  (x2 - x); }\n    if (e === 2) { p = -dy; q = -(y1 - y); }\n    if (e === 3) { p =  dy; q =  (y2 - y); }\n\n    if (Math.abs(p) < 1e-10 && q < 0) return false;\n\n    r = q / p;\n\n    if (p < 0) {\n      if (r > t1) return false;\n      else if (r > t0) t0 = r;\n    } else if (p > 0) {\n      if (r < t0) return false;\n      else if (r < t1) t1 = r;\n    }\n  }\n\n  return true;\n}\n","export default function(context, item) {\n  context.globalCompositeOperation = item.blend || 'source-over';\n}\n","export default function(value, dflt) {\n  return value == null ? dflt : value;\n}\n","import value from '../value';\nimport {canvas} from 'vega-canvas';\n\nfunction addStops(gradient, stops) {\n  const n = stops.length;\n  for (let i=0; i<n; ++i) {\n    gradient.addColorStop(stops[i].offset, stops[i].color);\n  }\n  return gradient;\n}\n\nexport default function(context, spec, bounds) {\n  const w = bounds.width(),\n        h = bounds.height();\n  let gradient;\n\n\n  if (spec.gradient === 'radial') {\n    gradient = context.createRadialGradient(\n      bounds.x1 + value(spec.x1, 0.5) * w,\n      bounds.y1 + value(spec.y1, 0.5) * h,\n      Math.max(w, h) * value(spec.r1, 0),\n      bounds.x1 + value(spec.x2, 0.5) * w,\n      bounds.y1 + value(spec.y2, 0.5) * h,\n      Math.max(w, h) * value(spec.r2, 0.5)\n    );\n  } else { // linear gradient\n    const x1 = value(spec.x1, 0),\n          y1 = value(spec.y1, 0),\n          x2 = value(spec.x2, 1),\n          y2 = value(spec.y2, 0);\n\n    if (x1 === x2 || y1 === y2 || w === h) {\n      // axis aligned: use normal gradient\n      gradient = context.createLinearGradient(\n        bounds.x1 + x1 * w,\n        bounds.y1 + y1 * h,\n        bounds.x1 + x2 * w,\n        bounds.y1 + y2 * h\n      );\n    } else {\n      // not axis aligned: render gradient into a pattern (#2365)\n      // this allows us to use normalized bounding box coordinates\n      const image = canvas(Math.ceil(w), Math.ceil(h)),\n            ictx = image.getContext('2d');\n\n      ictx.scale(w, h);\n      ictx.fillStyle = addStops(\n        ictx.createLinearGradient(x1, y1, x2, y2),\n        spec.stops\n      );\n      ictx.fillRect(0, 0, w, h);\n\n      return context.createPattern(image, 'no-repeat');\n    }\n  }\n\n  return addStops(gradient, spec.stops);\n}\n","import {isGradient} from '../../Gradient';\nimport gradient from './gradient';\n\nexport default function(context, item, value) {\n  return isGradient(value)\n    ? gradient(context, value, item.bounds)\n    : value;\n}\n","import color from './color';\n\nexport default function(context, item, opacity) {\n  opacity *= (item.fillOpacity==null ? 1 : item.fillOpacity);\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.fillStyle = color(context, item, item.fill);\n    return true;\n  } else {\n    return false;\n  }\n}\n","import color from './color';\n\nvar Empty = [];\n\nexport default function(context, item, opacity) {\n  var lw = (lw = item.strokeWidth) != null ? lw : 1;\n\n  if (lw <= 0) return false;\n\n  opacity *= (item.strokeOpacity==null ? 1 : item.strokeOpacity);\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.strokeStyle = color(context, item, item.stroke);\n\n    context.lineWidth = lw;\n    context.lineCap = item.strokeCap || 'butt';\n    context.lineJoin = item.strokeJoin || 'miter';\n    context.miterLimit = item.strokeMiterLimit || 10;\n\n    if (context.setLineDash) {\n      context.setLineDash(item.strokeDash || Empty);\n      context.lineDashOffset = item.strokeDashOffset || 0;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n","function compare(a, b) {\n  return a.zindex - b.zindex || a.index - b.index;\n}\n\nexport function zorder(scene) {\n  if (!scene.zdirty) return scene.zitems;\n\n  var items = scene.items,\n      output = [], item, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    item.index = i;\n    if (item.zindex) output.push(item);\n  }\n\n  scene.zdirty = false;\n  return scene.zitems = output.sort(compare);\n}\n\nexport function visit(scene, visitor) {\n  var items = scene.items, i, n;\n  if (!items || !items.length) return;\n\n  const zitems = zorder(scene);\n\n  if (zitems && zitems.length) {\n    for (i=0, n=items.length; i<n; ++i) {\n      if (!items[i].zindex) visitor(items[i]);\n    }\n    items = zitems;\n  }\n\n  for (i=0, n=items.length; i<n; ++i) {\n    visitor(items[i]);\n  }\n}\n\nexport function pickVisit(scene, visitor) {\n  var items = scene.items, hit, i;\n  if (!items || !items.length) return null;\n\n  const zitems = zorder(scene);\n  if (zitems && zitems.length) items = zitems;\n\n  for (i=items.length; --i >= 0;) {\n    if (hit = visitor(items[i])) return hit;\n  }\n\n  if (items === zitems) {\n    for (items=scene.items, i=items.length; --i >= 0;) {\n      if (!items[i].zindex) {\n        if (hit = visitor(items[i])) return hit;\n      }\n    }\n  }\n\n  return null;\n}\n","import blend from './blend';\nimport fill from './fill';\nimport stroke from './stroke';\nimport {visit} from '../visit';\n\nexport function drawAll(path) {\n  return function(context, scene, bounds) {\n    visit(scene, item => {\n      if (!bounds || bounds.intersects(item.bounds)) {\n        drawPath(path, context, item, item);\n      }\n    });\n  };\n}\n\nexport function drawOne(path) {\n  return function(context, scene, bounds) {\n    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {\n      drawPath(path, context, scene.items[0], scene.items);\n    }\n  };\n}\n\nfunction drawPath(path, context, item, items) {\n  var opacity = item.opacity == null ? 1 : item.opacity;\n  if (opacity === 0) return;\n\n  if (path(context, items)) return;\n\n  blend(context, item);\n\n  if (item.fill && fill(context, item, opacity)) {\n    context.fill();\n  }\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    context.stroke();\n  }\n}\n","import {pickVisit} from '../visit';\nimport {truthy} from 'vega-util';\n\nexport function pick(test) {\n  test = test || truthy;\n\n  return function(context, scene, x, y, gx, gy) {\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n\n    return pickVisit(scene, item => {\n      const b = item.bounds;\n      // first hit test against bounding box\n      if ((b && !b.contains(gx, gy)) || !b) return;\n      // if in bounding box, perform more careful test\n      if (test(context, item, x, y, gx, gy)) return item;\n    });\n  };\n}\n\nexport function hitPath(path, filled) {\n  return function(context, o, x, y) {\n    var item = Array.isArray(o) ? o[0] : o,\n        fill = (filled == null) ? item.fill : filled,\n        stroke = item.stroke && context.isPointInStroke, lw, lc;\n\n    if (stroke) {\n      lw = item.strokeWidth;\n      lc = item.strokeCap;\n      context.lineWidth = lw != null ? lw : 1;\n      context.lineCap   = lc != null ? lc : 'butt';\n    }\n\n    return path(context, o) ? false :\n      (fill && context.isPointInPath(x, y)) ||\n      (stroke && context.isPointInStroke(x, y));\n  };\n}\n\nexport function pickPath(path) {\n  return pick(hitPath(path));\n}\n","export function translate(x, y) {\n  return 'translate(' + x + ',' + y + ')';\n}\n\nexport function rotate(a) {\n  return 'rotate(' + a + ')';\n}\n\nexport function scale(scaleX, scaleY){\n  return 'scale('+ scaleX + ',' + scaleY+')';\n}\n\nexport function translateItem(item) {\n  return translate(item.x || 0, item.y || 0);\n}\n\nexport function rotateItem(item) {\n  return translate(item.x || 0, item.y || 0)\n    + (item.angle ? ' ' + rotate(item.angle) : '');\n}\n\nexport function transformItem(item) {\n  return translate(item.x || 0, item.y || 0)\n    + (item.angle ? ' ' + rotate(item.angle) : '')\n    + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');\n}\n","import boundStroke from '../bound/boundStroke';\nimport context from '../bound/boundContext';\nimport {intersectPath} from '../util/intersect';\nimport {drawAll} from '../util/canvas/draw';\nimport {pickPath} from '../util/canvas/pick';\nimport {rotateItem} from '../util/svg/transform';\nimport {DegToRad} from '../util/constants';\n\nexport default function(type, shape, isect) {\n\n  function attr(emit, item) {\n    emit('transform', rotateItem(item));\n    emit('d', shape(null, item));\n  }\n\n  function bound(bounds, item) {\n    shape(context(bounds, item.angle), item);\n    return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);\n  }\n\n  function draw(context, item) {\n    var x = item.x || 0,\n        y = item.y || 0,\n        a = item.angle || 0;\n\n    context.translate(x, y);\n    if (a) context.rotate(a *= DegToRad);\n    context.beginPath();\n    shape(context, item);\n    if (a) context.rotate(-a);\n    context.translate(-x, -y);\n  }\n\n  return {\n    type:   type,\n    tag:    'path',\n    nested: false,\n    attr:   attr,\n    bound:  bound,\n    draw:   drawAll(draw),\n    pick:   pickPath(draw),\n    isect:  isect || intersectPath(draw)\n  };\n\n}\n","import {arc} from '../path/shapes';\nimport markItemPath from './markItemPath';\n\nexport default markItemPath('arc', arc);\n","import boundStroke from '../bound/boundStroke';\nimport context from '../bound/boundContext';\nimport {intersectPoint} from '../util/intersect';\nimport {drawOne} from '../util/canvas/draw';\nimport {hitPath} from '../util/canvas/pick';\n\nexport default function(type, shape, tip) {\n\n  function attr(emit, item) {\n    var items = item.mark.items;\n    if (items.length) emit('d', shape(null, items));\n  }\n\n  function bound(bounds, mark) {\n    var items = mark.items;\n    if (items.length === 0) {\n      return bounds;\n    } else {\n      shape(context(bounds), items);\n      return boundStroke(bounds, items[0]);\n    }\n  }\n\n  function draw(context, items) {\n    context.beginPath();\n    shape(context, items);\n  }\n\n  const hit = hitPath(draw);\n\n  function pick(context, scene, x, y, gx, gy) {\n    var items = scene.items,\n        b = scene.bounds;\n\n    if (!items || !items.length || b && !b.contains(gx, gy)) {\n      return null;\n    }\n\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return hit(context, items, x, y) ? items[0] : null;\n  }\n\n  return {\n    type:   type,\n    tag:    'path',\n    nested: true,\n    attr:   attr,\n    bound:  bound,\n    draw:   drawOne(draw),\n    pick:   pick,\n    isect:  intersectPoint,\n    tip:    tip\n  };\n\n}\n\n\n","import {area} from '../path/shapes';\nimport {pickArea} from '../util/pickPath';\nimport markMultiItemPath from './markMultiItemPath';\n\nexport default markMultiItemPath('area', area, pickArea);\n","export function pickArea(a, p) {\n  var v = a[0].orient === 'horizontal' ? p[1] : p[0],\n      z = a[0].orient === 'horizontal' ? 'y' : 'x',\n      i = a.length,\n      min = +Infinity, hit, d;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    d = Math.abs(a[i][z] - v);\n    if (d < min) {\n      min = d;\n      hit = a[i];\n    }\n  }\n\n  return hit;\n}\n\nexport function pickLine(a, p) {\n  var t = Math.pow(a[0].strokeWidth || 1, 2),\n      i = a.length, dx, dy, dd;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    if (dd < t) return a[i];\n  }\n\n  return null;\n}\n\nexport function pickTrail(a, p) {\n  var i = a.length, dx, dy, dd;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    dx = a[i].size || 1;\n    if (dd < dx*dx) return a[i];\n  }\n\n  return null;\n}\n","import {hasCornerRadius, rectangle} from '../../path/shapes';\nimport {isFunction} from 'vega-util';\n\nexport default function(context, scene) {\n  var clip = scene.clip;\n\n  context.save();\n\n  if (isFunction(clip)) {\n    context.beginPath();\n    clip(context);\n    context.clip();\n  } else {\n    clipGroup(context, scene.group);\n  }\n}\n\nexport function clipGroup(context, group) {\n  context.beginPath();\n  hasCornerRadius(group)\n    ? rectangle(context, group, 0, 0)\n    : context.rect(0, 0, group.width || 0, group.height || 0);\n  context.clip();\n}\n","import {hasCornerRadius, rectangle} from '../path/shapes';\nimport boundStroke from '../bound/boundStroke';\nimport {intersectRect} from '../util/intersect';\nimport value from '../util/value';\nimport {pickVisit, visit} from '../util/visit';\nimport blend from '../util/canvas/blend';\nimport {clipGroup} from '../util/canvas/clip';\nimport fill from '../util/canvas/fill';\nimport stroke from '../util/canvas/stroke';\nimport {hitPath} from '../util/canvas/pick';\nimport clip from '../util/svg/clip';\nimport {translateItem} from '../util/svg/transform';\n\nfunction offset(item) {\n  const sw = value(item.strokeWidth, 1);\n  return item.strokeOffset != null ? item.strokeOffset\n    : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1)\n    : 0;\n}\n\nfunction attr(emit, item) {\n  emit('transform', translateItem(item));\n}\n\nfunction emitRectangle(emit, item) {\n  const off = offset(item);\n  emit('d', rectangle(null, item, off, off));\n}\n\nfunction background(emit, item) {\n  emit('class', 'background');\n  emit('aria-hidden', true);\n  emitRectangle(emit, item);\n}\n\nfunction foreground(emit, item) {\n  emit('class', 'foreground');\n  emit('aria-hidden', true);\n  if (item.strokeForeground) {\n    emitRectangle(emit, item);\n  } else {\n    emit('d', '');\n  }\n}\n\nfunction content(emit, item, renderer) {\n  const url = item.clip ? clip(renderer, item, item) : null;\n  emit('clip-path', url);\n}\n\nfunction bound(bounds, group) {\n  if (!group.clip && group.items) {\n    const items = group.items, m = items.length;\n    for (let j=0; j<m; ++j) {\n      bounds.union(items[j].bounds);\n    }\n  }\n\n  if ((group.clip || group.width || group.height) && !group.noBound) {\n    bounds.add(0, 0).add(group.width || 0, group.height || 0);\n  }\n\n  boundStroke(bounds, group);\n\n  return bounds.translate(group.x || 0, group.y || 0);\n}\n\nfunction rectanglePath(context, group, x, y) {\n  const off = offset(group);\n  context.beginPath();\n  rectangle(context, group, (x || 0) + off, (y || 0) + off);\n}\n\nconst hitBackground = hitPath(rectanglePath);\nconst hitForeground = hitPath(rectanglePath, false);\nconst hitCorner = hitPath(rectanglePath, true);\n\nfunction draw(context, scene, bounds) {\n  visit(scene, group => {\n    const gx = group.x || 0,\n          gy = group.y || 0,\n          fore = group.strokeForeground,\n          opacity = group.opacity == null ? 1 : group.opacity;\n\n    // draw group background\n    if ((group.stroke || group.fill) && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n      if (group.fill && fill(context, group, opacity)) {\n        context.fill();\n      }\n      if (group.stroke && !fore && stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    }\n\n    // setup graphics context, set clip and bounds\n    context.save();\n    context.translate(gx, gy);\n    if (group.clip) clipGroup(context, group);\n    if (bounds) bounds.translate(-gx, -gy);\n\n    // draw group contents\n    visit(group, item => {\n      this.draw(context, item, bounds);\n    });\n\n    // restore graphics context\n    if (bounds) bounds.translate(gx, gy);\n    context.restore();\n\n    // draw group foreground\n    if (fore && group.stroke && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n      if (stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    }\n  });\n}\n\nfunction pick(context, scene, x, y, gx, gy) {\n  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {\n    return null;\n  }\n\n  const cx = x * context.pixelRatio,\n        cy = y * context.pixelRatio;\n\n  return pickVisit(scene, group => {\n    let hit, dx, dy;\n\n    // first hit test bounding box\n    const b = group.bounds;\n    if (b && !b.contains(gx, gy)) return;\n\n    // passed bounds check, test rectangular clip\n    dx = group.x || 0;\n    dy = group.y || 0;\n    const dw = dx + (group.width || 0),\n          dh = dy + (group.height || 0),\n          c = group.clip;\n    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return;\n\n    // adjust coordinate system\n    context.save();\n    context.translate(dx, dy);\n    dx = gx - dx;\n    dy = gy - dy;\n\n    // test background for rounded corner clip\n    if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {\n      context.restore();\n      return null;\n    }\n\n    const fore = group.strokeForeground,\n          ix = scene.interactive !== false;\n\n    // hit test against group foreground\n    if (ix && fore && group.stroke\n        && hitForeground(context, group, cx, cy)) {\n      context.restore();\n      return group;\n    }\n\n    // hit test against contained marks\n    hit = pickVisit(group, mark => pickMark(mark, dx, dy)\n      ? this.pick(mark, x, y, dx, dy)\n      : null\n    );\n\n    // hit test against group background\n    if (!hit && ix && (group.fill || (!fore && group.stroke))\n        && hitBackground(context, group, cx, cy)) {\n      hit = group;\n    }\n\n    // restore state and return\n    context.restore();\n    return hit || null;\n  });\n}\n\nfunction pickMark(mark, x, y) {\n  return (mark.interactive !== false || mark.marktype === 'group')\n    && mark.bounds && mark.bounds.contains(x, y);\n}\n\nexport default {\n  type:       'group',\n  tag:        'g',\n  nested:     false,\n  attr:       attr,\n  bound:      bound,\n  draw:       draw,\n  pick:       pick,\n  isect:      intersectRect,\n  content:    content,\n  background: background,\n  foreground: foreground\n};\n","export default {\n  'xmlns': 'http://www.w3.org/2000/svg',\n  'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n  'version': '1.1'\n};","import {visit} from '../util/visit';\nimport blend from '../util/canvas/blend';\nimport {pick} from '../util/canvas/pick';\nimport metadata from '../util/svg/metadata';\nimport {translate} from '../util/svg/transform';\nimport {truthy} from 'vega-util';\n\nfunction getImage(item, renderer) {\n  var image = item.image;\n  if (!image || item.url && item.url !== image.url) {\n    image = {complete: false, width: 0, height: 0};\n    renderer.loadImage(item.url).then(image => {\n      item.image = image;\n      item.image.url = item.url;\n    });\n  }\n  return image;\n}\n\nfunction imageWidth(item, image) {\n  return item.width != null ? item.width\n    : !image || !image.width ? 0\n    : item.aspect !== false && item.height ? item.height * image.width / image.height\n    : image.width;\n}\n\nfunction imageHeight(item, image) {\n  return item.height != null ? item.height\n    : !image || !image.height ? 0\n    : item.aspect !== false && item.width ? item.width * image.height / image.width\n    : image.height;\n}\n\nfunction imageXOffset(align, w) {\n  return align === 'center' ? w / 2 : align === 'right' ? w : 0;\n}\n\nfunction imageYOffset(baseline, h) {\n  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;\n}\n\nfunction attr(emit, item, renderer) {\n  const img = getImage(item, renderer),\n        w = imageWidth(item, img),\n        h = imageHeight(item, img),\n        x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h),\n        i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';\n\n  emit('href', i, metadata['xmlns:xlink'], 'xlink:href');\n  emit('transform', translate(x, y));\n  emit('width', w);\n  emit('height', h);\n  emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');\n}\n\nfunction bound(bounds, item) {\n  const img = item.image,\n        w = imageWidth(item, img),\n        h = imageHeight(item, img),\n        x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h);\n\n  return bounds.set(x, y, x + w, y + h);\n}\n\nfunction draw(context, scene, bounds) {\n  visit(scene, item => {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    const img = getImage(item, this);\n\n    let w = imageWidth(item, img);\n    let h = imageHeight(item, img);\n    if (w === 0 || h === 0) return; // early exit\n\n    let x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h),\n        opacity, ar0, ar1, t;\n\n    if (item.aspect !== false) {\n      ar0 = img.width / img.height;\n      ar1 = item.width / item.height;\n      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {\n        if (ar1 < ar0) {\n          t = w / ar0;\n          y += (h - t) / 2;\n          h = t;\n        } else {\n          t = h * ar0;\n          x += (w - t) / 2;\n          w = t;\n        }\n      }\n    }\n\n    if (img.complete || img.toDataURL) {\n      blend(context, item);\n      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;\n      context.imageSmoothingEnabled = item.smooth !== false;\n      context.drawImage(img, x, y, w, h);\n    }\n  });\n}\n\nexport default {\n  type:     'image',\n  tag:      'image',\n  nested:   false,\n  attr:     attr,\n  bound:    bound,\n  draw:     draw,\n  pick:     pick(),\n  isect:    truthy, // bounds check is sufficient\n  get:      getImage,\n  xOffset:  imageXOffset,\n  yOffset:  imageYOffset\n};\n","import {line} from '../path/shapes';\nimport {pickLine} from '../util/pickPath';\nimport markMultiItemPath from './markMultiItemPath';\n\nexport default markMultiItemPath('line', line, pickLine);\n","import boundStroke from '../bound/boundStroke';\nimport context from '../bound/boundContext';\nimport pathParse from '../path/parse';\nimport pathRender from '../path/render';\nimport {intersectPath} from '../util/intersect';\nimport {drawAll} from '../util/canvas/draw';\nimport {pickPath} from '../util/canvas/pick';\nimport {transformItem} from '../util/svg/transform';\nimport {DegToRad} from '../util/constants';\n\nfunction attr(emit, item) {\n  var sx = item.scaleX || 1,\n      sy = item.scaleY || 1;\n  if (sx !== 1 || sy !== 1) {\n    emit('vector-effect', 'non-scaling-stroke');\n  }\n  emit('transform', transformItem(item));\n  emit('d', item.path);\n}\n\nfunction path(context, item) {\n  var path = item.path;\n  if (path == null) return true;\n\n  var x = item.x || 0,\n      y = item.y || 0,\n      sx = item.scaleX || 1,\n      sy = item.scaleY || 1,\n      a = (item.angle || 0) * DegToRad,\n      cache = item.pathCache;\n\n  if (!cache || cache.path !== path) {\n    (item.pathCache = cache = pathParse(path)).path = path;\n  }\n\n  if (a && context.rotate && context.translate) {\n    context.translate(x, y);\n    context.rotate(a);\n    pathRender(context, cache, 0, 0, sx, sy);\n    context.rotate(-a);\n    context.translate(-x, -y);\n  } else {\n    pathRender(context, cache, x, y, sx, sy);\n  }\n}\n\nfunction bound(bounds, item) {\n  return path(context(bounds, item.angle), item)\n    ? bounds.set(0, 0, 0, 0)\n    : boundStroke(bounds, item, true);\n}\n\nexport default {\n  type:   'path',\n  tag:    'path',\n  nested: false,\n  attr:   attr,\n  bound:  bound,\n  draw:   drawAll(path),\n  pick:   pickPath(path),\n  isect:  intersectPath(path)\n};\n","import boundStroke from '../bound/boundStroke';\nimport {rectangle} from '../path/shapes';\nimport {intersectRect} from '../util/intersect';\nimport {drawAll} from '../util/canvas/draw';\nimport {pickPath} from '../util/canvas/pick';\n\nfunction attr(emit, item) {\n  emit('d', rectangle(null, item));\n}\n\nfunction bound(bounds, item) {\n  var x, y;\n  return boundStroke(bounds.set(\n    x = item.x || 0,\n    y = item.y || 0,\n    (x + item.width) || 0,\n    (y + item.height) || 0\n  ), item);\n}\n\nfunction draw(context, item) {\n  context.beginPath();\n  rectangle(context, item);\n}\n\nexport default {\n  type:   'rect',\n  tag:    'path',\n  nested: false,\n  attr:   attr,\n  bound:  bound,\n  draw:   drawAll(draw),\n  pick:   pickPath(draw),\n  isect:  intersectRect\n};\n","import boundStroke from '../bound/boundStroke';\nimport {intersectRule} from '../util/intersect';\nimport {visit} from '../util/visit';\nimport blend from '../util/canvas/blend';\nimport {pick} from '../util/canvas/pick';\nimport stroke from '../util/canvas/stroke';\nimport {translateItem} from '../util/svg/transform';\n\nfunction attr(emit, item) {\n  emit('transform', translateItem(item));\n  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);\n  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);\n}\n\nfunction bound(bounds, item) {\n  var x1, y1;\n  return boundStroke(bounds.set(\n    x1 = item.x || 0,\n    y1 = item.y || 0,\n    item.x2 != null ? item.x2 : x1,\n    item.y2 != null ? item.y2 : y1\n  ), item);\n}\n\nfunction path(context, item, opacity) {\n  var x1, y1, x2, y2;\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    x1 = item.x || 0;\n    y1 = item.y || 0;\n    x2 = item.x2 != null ? item.x2 : x1;\n    y2 = item.y2 != null ? item.y2 : y1;\n    context.beginPath();\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n    return true;\n  }\n  return false;\n}\n\nfunction draw(context, scene, bounds) {\n  visit(scene, item => {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n    var opacity = item.opacity == null ? 1 : item.opacity;\n    if (opacity && path(context, item, opacity)) {\n      blend(context, item);\n      context.stroke();\n    }\n  });\n}\n\nfunction hit(context, item, x, y) {\n  if (!context.isPointInStroke) return false;\n  return path(context, item, 1) && context.isPointInStroke(x, y);\n}\n\nexport default {\n  type:   'rule',\n  tag:    'line',\n  nested: false,\n  attr:   attr,\n  bound:  bound,\n  draw:   draw,\n  pick:   pick(hit),\n  isect:  intersectRule\n};\n","import {shape} from '../path/shapes';\nimport markItemPath from './markItemPath';\n\nexport default markItemPath('shape', shape);\n","import {symbol} from '../path/shapes';\nimport {intersectPoint} from '../util/intersect';\nimport markItemPath from './markItemPath';\n\nexport default markItemPath('symbol', symbol, intersectPoint);\n","import {context} from './canvas/context';\nimport {isArray, lruCache} from 'vega-util';\n\n// memoize text width measurement\nconst widthCache = lruCache();\n\nexport var textMetrics = {\n  height: fontSize,\n  measureWidth: measureWidth,\n  estimateWidth: estimateWidth,\n  width: estimateWidth,\n  canvas: useCanvas\n};\n\nuseCanvas(true);\n\nfunction useCanvas(use) {\n  textMetrics.width = (use && context) ? measureWidth : estimateWidth;\n}\n\n// make simple estimate if no canvas is available\nfunction estimateWidth(item, text) {\n  return _estimateWidth(textValue(item, text), fontSize(item));\n}\n\nfunction _estimateWidth(text, currentFontHeight) {\n  return ~~(0.8 * text.length * currentFontHeight);\n}\n\n// measure text width if canvas is available\nfunction measureWidth(item, text) {\n  return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0\n    : _measureWidth(text, font(item));\n}\n\nfunction _measureWidth(text, currentFont) {\n  const key = `(${currentFont}) ${text}`;\n  let width = widthCache.get(key);\n  if (width === undefined) {\n    context.font = currentFont;\n    width = context.measureText(text).width;\n    widthCache.set(key, width);\n  }\n  return width;\n}\n\nexport function fontSize(item) {\n  return item.fontSize != null ? (+item.fontSize || 0) : 11;\n}\n\nexport function lineHeight(item) {\n  return item.lineHeight != null ? item.lineHeight : (fontSize(item) + 2);\n}\n\nfunction lineArray(_) {\n  return isArray(_) ? _.length > 1 ? _ : _[0] : _;\n}\n\nexport function textLines(item) {\n  return lineArray(\n    item.lineBreak && item.text && !isArray(item.text)\n      ? item.text.split(item.lineBreak)\n      : item.text\n  );\n}\n\nexport function multiLineOffset(item) {\n  const tl = textLines(item);\n  return (isArray(tl) ? (tl.length - 1) : 0) * lineHeight(item);\n}\n\nexport function textValue(item, line) {\n  const text = line == null ? '' : (line + '').trim();\n  return item.limit > 0 && text.length ? truncate(item, text) : text;\n}\n\nfunction widthGetter(item) {\n  if (textMetrics.width === measureWidth) {\n    // we are using canvas\n    const currentFont = font(item);\n    return text => _measureWidth(text, currentFont);\n  } else {\n    // we are relying on estimates\n    const currentFontHeight = fontSize(item);\n    return text => _estimateWidth(text, currentFontHeight);\n  }\n}\n\nfunction truncate(item, text) {\n  var limit = +item.limit,\n      width = widthGetter(item);\n\n  if (width(text) < limit) return text;\n\n  var ellipsis = item.ellipsis || '\\u2026',\n      rtl = item.dir === 'rtl',\n      lo = 0,\n      hi = text.length, mid;\n\n  limit -= width(ellipsis);\n\n  if (rtl) {\n    while (lo < hi) {\n      mid = (lo + hi >>> 1);\n      if (width(text.slice(mid)) > limit) lo = mid + 1;\n      else hi = mid;\n    }\n    return ellipsis + text.slice(lo);\n  } else {\n    while (lo < hi) {\n      mid = 1 + (lo + hi >>> 1);\n      if (width(text.slice(0, mid)) < limit) lo = mid;\n      else hi = mid - 1;\n    }\n    return text.slice(0, lo) + ellipsis;\n  }\n}\n\nexport function fontFamily(item, quote) {\n  var font = item.font;\n  return (quote && font\n    ? String(font).replace(/\"/g, '\\'')\n    : font) || 'sans-serif';\n}\n\nexport function font(item, quote) {\n  return '' +\n    (item.fontStyle ? item.fontStyle + ' ' : '') +\n    (item.fontVariant ? item.fontVariant + ' ' : '') +\n    (item.fontWeight ? item.fontWeight + ' ' : '') +\n    fontSize(item) + 'px ' +\n    fontFamily(item, quote);\n}\n\nexport function offset(item) {\n  // perform our own font baseline calculation\n  // why? not all browsers support SVG 1.1 'alignment-baseline' :(\n  // this also ensures consistent layout across renderers\n  var baseline = item.baseline,\n      h = fontSize(item);\n\n  return Math.round(\n    baseline === 'top'         ?  0.79 * h :\n    baseline === 'middle'      ?  0.30 * h :\n    baseline === 'bottom'      ? -0.21 * h :\n    baseline === 'line-top'    ?  0.29 * h + 0.5 * lineHeight(item) :\n    baseline === 'line-bottom' ?  0.29 * h - 0.5 * lineHeight(item) : 0\n  );\n}\n","import Bounds from '../Bounds';\nimport {DegToRad, HalfPi} from '../util/constants';\nimport {font, lineHeight, offset, textLines, textMetrics, textValue} from '../util/text';\nimport {intersectBoxLine} from '../util/intersect';\nimport {visit} from '../util/visit';\nimport blend from '../util/canvas/blend';\nimport fill from '../util/canvas/fill';\nimport {pick} from '../util/canvas/pick';\nimport stroke from '../util/canvas/stroke';\nimport {rotate, translate} from '../util/svg/transform';\nimport {isArray} from 'vega-util';\n\nconst textAlign = {\n  'left':   'start',\n  'center': 'middle',\n  'right':  'end'\n};\n\nconst tempBounds = new Bounds();\n\nfunction anchorPoint(item) {\n  var x = item.x || 0,\n      y = item.y || 0,\n      r = item.radius || 0, t;\n\n  if (r) {\n    t = (item.theta || 0) - HalfPi;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  tempBounds.x1 = x;\n  tempBounds.y1 = y;\n  return tempBounds;\n}\n\nfunction attr(emit, item) {\n  var dx = item.dx || 0,\n      dy = (item.dy || 0) + offset(item),\n      p = anchorPoint(item),\n      x = p.x1,\n      y = p.y1,\n      a = item.angle || 0, t;\n\n  emit('text-anchor', textAlign[item.align] || 'start');\n\n  if (a) {\n    t = translate(x, y) + ' ' + rotate(a);\n    if (dx || dy) t += ' ' + translate(dx, dy);\n  } else {\n    t = translate(x + dx, y + dy);\n  }\n  emit('transform', t);\n}\n\nfunction bound(bounds, item, mode) {\n  var h = textMetrics.height(item),\n      a = item.align,\n      p = anchorPoint(item),\n      x = p.x1,\n      y = p.y1,\n      dx = item.dx || 0,\n      dy = (item.dy || 0) + offset(item) - Math.round(0.8*h), // use 4/5 offset\n      tl = textLines(item),\n      w;\n\n  // get dimensions\n  if (isArray(tl)) {\n    // multi-line text\n    h += lineHeight(item) * (tl.length - 1);\n    w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);\n  } else {\n    // single-line text\n    w = textMetrics.width(item, tl);\n  }\n\n  // horizontal alignment\n  if (a === 'center') {\n    dx -= (w / 2);\n  } else if (a === 'right') {\n    dx -= w;\n  } else {\n    // left by default, do nothing\n  }\n\n  bounds.set(dx+=x, dy+=y, dx+w, dy+h);\n\n  if (item.angle && !mode) {\n    bounds.rotate(item.angle * DegToRad, x, y);\n  } else if (mode === 2) {\n    return bounds.rotatedPoints(item.angle * DegToRad, x, y);\n  }\n  return bounds;\n}\n\nfunction draw(context, scene, bounds) {\n  visit(scene, item => {\n    var opacity = item.opacity == null ? 1 : item.opacity,\n        p, x, y, i, lh, tl, str;\n\n    if (bounds && !bounds.intersects(item.bounds) || // bounds check\n        opacity === 0 || item.fontSize <= 0 ||\n        item.text == null || item.text.length === 0) return;\n\n    context.font = font(item);\n    context.textAlign = item.align || 'left';\n\n    p = anchorPoint(item);\n    x = p.x1,\n    y = p.y1;\n\n    if (item.angle) {\n      context.save();\n      context.translate(x, y);\n      context.rotate(item.angle * DegToRad);\n      x = y = 0; // reset x, y\n    }\n    x += (item.dx || 0);\n    y += (item.dy || 0) + offset(item);\n\n    tl = textLines(item);\n    blend(context, item);\n    if (isArray(tl)) {\n      lh = lineHeight(item);\n      for (i=0; i<tl.length; ++i) {\n        str = textValue(item, tl[i]);\n        if (item.fill && fill(context, item, opacity)) {\n          context.fillText(str, x, y);\n        }\n        if (item.stroke && stroke(context, item, opacity)) {\n          context.strokeText(str, x, y);\n        }\n        y += lh;\n      }\n    } else {\n      str = textValue(item, tl);\n      if (item.fill && fill(context, item, opacity)) {\n        context.fillText(str, x, y);\n      }\n      if (item.stroke && stroke(context, item, opacity)) {\n        context.strokeText(str, x, y);\n      }\n    }\n\n    if (item.angle) context.restore();\n  });\n}\n\nfunction hit(context, item, x, y, gx, gy) {\n  if (item.fontSize <= 0) return false;\n  if (!item.angle) return true; // bounds sufficient if no rotation\n\n  // project point into space of unrotated bounds\n  var p = anchorPoint(item),\n      ax = p.x1,\n      ay = p.y1,\n      b = bound(tempBounds, item, 1),\n      a = -item.angle * DegToRad,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),\n      py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);\n\n  return b.contains(px, py);\n}\n\nfunction intersectText(item, box) {\n  const p = bound(tempBounds, item, 2);\n  return intersectBoxLine(box, p[0], p[1], p[2], p[3])\n      || intersectBoxLine(box, p[0], p[1], p[4], p[5])\n      || intersectBoxLine(box, p[4], p[5], p[6], p[7])\n      || intersectBoxLine(box, p[2], p[3], p[6], p[7]);\n}\n\nexport default {\n  type:   'text',\n  tag:    'text',\n  nested: false,\n  attr:   attr,\n  bound:  bound,\n  draw:   draw,\n  pick:   pick(hit),\n  isect:  intersectText\n};\n","import arc from './arc';\nimport area from './area';\nimport group from './group';\nimport image from './image';\nimport line from './line';\nimport path from './path';\nimport rect from './rect';\nimport rule from './rule';\nimport shape from './shape';\nimport symbol from './symbol';\nimport text from './text';\nimport trail from './trail';\n\nexport default {\n  arc:     arc,\n  area:    area,\n  group:   group,\n  image:   image,\n  line:    line,\n  path:    path,\n  rect:    rect,\n  rule:    rule,\n  shape:   shape,\n  symbol:  symbol,\n  text:    text,\n  trail:   trail\n};\n","import {trail} from '../path/shapes';\nimport {pickTrail} from '../util/pickPath';\nimport markMultiItemPath from './markMultiItemPath';\n\nexport default markMultiItemPath('trail', trail, pickTrail);\n","import Bounds from '../Bounds';\nimport marks from '../marks/index';\n\nexport default function(item, func, opt) {\n  var type = marks[item.mark.marktype],\n      bound = func || type.bound;\n  if (type.nested) item = item.mark;\n\n  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);\n}\n","import Bounds from '../Bounds';\nimport boundItem from './boundItem';\nimport marks from '../marks/index';\n\nvar DUMMY = {mark: null};\n\nexport default function(mark, bounds, opt) {\n  var type  = marks[mark.marktype],\n      bound = type.bound,\n      items = mark.items,\n      hasItems = items && items.length,\n      i, n, item, b;\n\n  if (type.nested) {\n    if (hasItems) {\n      item = items[0];\n    } else {\n      // no items, fake it\n      DUMMY.mark = mark;\n      item = DUMMY;\n    }\n    b = boundItem(item, bound, opt);\n    bounds = bounds && bounds.union(b) || b;\n    return bounds;\n  }\n\n  bounds = bounds\n    || mark.bounds && mark.bounds.clear()\n    || new Bounds();\n\n  if (hasItems) {\n    for (i=0, n=items.length; i<n; ++i) {\n      bounds.union(boundItem(items[i], bound, opt));\n    }\n  }\n\n  return mark.bounds = bounds;\n}\n","import boundMark from '../bound/boundMark';\n\nconst keys = [\n  'marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex',\n  'x', 'y', 'width', 'height', 'align', 'baseline',             // layout\n  'fill', 'fillOpacity', 'opacity', 'blend',                    // fill\n  'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',        // stroke\n  'strokeDash', 'strokeDashOffset',                             // stroke dash\n  'strokeForeground', 'strokeOffset',                           // group\n  'startAngle', 'endAngle', 'innerRadius', 'outerRadius',       // arc\n  'cornerRadius', 'padAngle',                                   // arc, rect\n  'cornerRadiusTopLeft', 'cornerRadiusTopRight',                // rect, group\n  'cornerRadiusBottomLeft', 'cornerRadiusBottomRight',\n  'interpolate', 'tension', 'orient', 'defined',                // area, line\n  'url', 'aspect', 'smooth',                                    // image\n  'path', 'scaleX', 'scaleY',                                   // path\n  'x2', 'y2',                                                   // rule\n  'size', 'shape',                                              // symbol\n  'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy',        // text\n  'ellipsis', 'limit', 'lineBreak', 'lineHeight',\n  'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant', // font\n  'description', 'aria', 'ariaRole', 'ariaRoleDescription'      // aria\n];\n\nexport function sceneToJSON(scene, indent) {\n  return JSON.stringify(scene, keys, indent);\n}\n\nexport function sceneFromJSON(json) {\n  const scene = (typeof json === 'string' ? JSON.parse(json) : json);\n  return initialize(scene);\n}\n\nfunction initialize(scene) {\n  var type = scene.marktype,\n      items = scene.items,\n      parent, i, n;\n\n  if (items) {\n    for (i=0, n=items.length; i<n; ++i) {\n      parent = type ? 'mark' : 'group';\n      items[i][parent] = scene;\n      if (items[i].zindex) items[i][parent].zdirty = true;\n      if ('group' === (type || parent)) initialize(items[i]);\n    }\n  }\n\n  if (type) boundMark(scene);\n  return scene;\n}\n","import Bounds from './Bounds';\nimport GroupItem from './GroupItem';\nimport {sceneFromJSON, sceneToJSON} from './util/serialize';\n\nexport default function Scenegraph(scene) {\n  if (arguments.length) {\n    this.root = sceneFromJSON(scene);\n  } else {\n    this.root = createMark({\n      marktype: 'group',\n      name: 'root',\n      role: 'frame'\n    });\n    this.root.items = [new GroupItem(this.root)];\n  }\n}\n\nScenegraph.prototype = {\n  toJSON(indent) {\n    return sceneToJSON(this.root, indent || 0);\n  },\n\n  mark(markdef, group, index) {\n    group = group || this.root.items[0];\n    const mark = createMark(markdef, group);\n    group.items[index] = mark;\n    if (mark.zindex) mark.group.zdirty = true;\n    return mark;\n  }\n};\n\nfunction createMark(def, group) {\n  const mark = {\n    bounds:      new Bounds(),\n    clip:        !!def.clip,\n    group:       group,\n    interactive: def.interactive === false ? false : true,\n    items:       [],\n    marktype:    def.marktype,\n    name:        def.name || undefined,\n    role:        def.role || undefined,\n    zindex:      def.zindex || 0\n  };\n\n  // add accessibility properties if defined\n  if (def.aria != null) {\n    mark.aria = def.aria;\n  }\n  if (def.description) {\n    mark.description = def.description;\n  }\n\n  return mark;\n}\n","// create a new DOM element\nexport function domCreate(doc, tag, ns) {\n  if (!doc && typeof document !== 'undefined' && document.createElement) {\n    doc = document;\n  }\n  return doc\n    ? (ns ? doc.createElementNS(ns, tag) : doc.createElement(tag))\n    : null;\n}\n\n// find first child element with matching tag\nexport function domFind(el, tag) {\n  tag = tag.toLowerCase();\n  var nodes = el.childNodes, i = 0, n = nodes.length;\n  for (; i<n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {\n    return nodes[i];\n  }\n}\n\n// retrieve child element at given index\n// create & insert if doesn't exist or if tags do not match\nexport function domChild(el, index, tag, ns) {\n  var a = el.childNodes[index], b;\n  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {\n    b = a || null;\n    a = domCreate(el.ownerDocument, tag, ns);\n    el.insertBefore(a, b);\n  }\n  return a;\n}\n\n// remove all child elements at or above the given index\nexport function domClear(el, index) {\n  var nodes = el.childNodes,\n      curr = nodes.length;\n  while (curr > index) el.removeChild(nodes[--curr]);\n  return el;\n}\n\n// generate css class name for mark\nexport function cssClass(mark) {\n  return 'mark-' + mark.marktype\n    + (mark.role ? ' role-' + mark.role : '')\n    + (mark.name ? ' ' + mark.name : '');\n}\n","export default function(event, el) {\n  const rect = el.getBoundingClientRect();\n  return [\n    event.clientX - rect.left - (el.clientLeft || 0),\n    event.clientY - rect.top - (el.clientTop || 0)\n  ];\n}\n","import {domCreate} from './util/dom';\nimport resolveItem from './util/resolveItem';\nimport {loader} from 'vega-loader';\n\n/**\n * Create a new Handler instance.\n * @param {object} [customLoader] - Optional loader instance for\n *   href URL sanitization. If not specified, a standard loader\n *   instance will be generated.\n * @param {function} [customTooltip] - Optional tooltip handler\n *   function for custom tooltip display.\n * @constructor\n */\nexport default function Handler(customLoader, customTooltip) {\n  this._active = null;\n  this._handlers = {};\n  this._loader = customLoader || loader();\n  this._tooltip = customTooltip || defaultTooltip;\n}\n\n// The default tooltip display handler.\n// Sets the HTML title attribute on the visualization container.\nfunction defaultTooltip(handler, event, item, value) {\n  handler.element().setAttribute('title', value || '');\n}\n\nHandler.prototype = {\n  /**\n   * Initialize a new Handler instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {object} [obj] - Optional context object that should serve as\n   *   the \"this\" context for event callbacks.\n   * @return {Handler} - This handler instance.\n   */\n  initialize(el, origin, obj) {\n    this._el = el;\n    this._obj = obj || null;\n    return this.origin(origin);\n  },\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element() {\n    return this._el;\n  },\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas() {\n    return this._el && this._el.firstChild;\n  },\n\n  /**\n   * Get / set the origin coordinates of the visualization.\n   */\n  origin(origin) {\n    if (arguments.length) {\n      this._origin = origin || [0, 0];\n      return this;\n    } else {\n      return this._origin.slice();\n    }\n  },\n\n  /**\n   * Get / set the scenegraph root.\n   */\n  scene(scene) {\n    if (!arguments.length) return this._scene;\n    this._scene = scene;\n    return this;\n  },\n\n  /**\n   * Add an event handler. Subclasses should override this method.\n   */\n  on(/*type, handler*/) {},\n\n  /**\n   * Remove an event handler. Subclasses should override this method.\n   */\n  off(/*type, handler*/) {},\n\n  /**\n   * Utility method for finding the array index of an event handler.\n   * @param {Array} h - An array of registered event handlers.\n   * @param {string} type - The event type.\n   * @param {function} handler - The event handler instance to find.\n   * @return {number} - The handler's array index or -1 if not registered.\n   */\n  _handlerIndex(h, type, handler) {\n    for (let i = h ? h.length : 0; --i>=0;) {\n      if (h[i].type === type && (!handler || h[i].handler === handler)) {\n        return i;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * Returns an array with registered event handlers.\n   * @param {string} [type] - The event type to query. Any annotations\n   *   are ignored; for example, for the argument \"click.foo\", \".foo\" will\n   *   be ignored and the method returns all \"click\" handlers. If type is\n   *   null or unspecified, this method returns handlers for all types.\n   * @return {Array} - A new array containing all registered event handlers.\n   */\n  handlers(type) {\n    const h = this._handlers, a = [];\n    if (type) {\n      a.push(...h[this.eventName(type)]);\n    } else {\n      for (const k in h) { a.push(...h[k]); }\n    }\n    return a;\n  },\n\n  /**\n   * Parses an event name string to return the specific event type.\n   * For example, given \"click.foo\" returns \"click\"\n   * @param {string} name - The input event type string.\n   * @return {string} - A string with the event type only.\n   */\n  eventName(name) {\n    const i = name.indexOf('.');\n    return i < 0 ? name : name.slice(0, i);\n  },\n\n  /**\n   * Handle hyperlink navigation in response to an item.href value.\n   * @param {Event} event - The event triggering hyperlink navigation.\n   * @param {Item} item - The scenegraph item.\n   * @param {string} href - The URL to navigate to.\n   */\n  handleHref(event, item, href) {\n    this._loader\n      .sanitize(href, {context:'href'})\n      .then(opt => {\n        const e = new MouseEvent(event.type, event),\n              a = domCreate(null, 'a');\n        for (const name in opt) a.setAttribute(name, opt[name]);\n        a.dispatchEvent(e);\n      })\n      .catch(() => { /* do nothing */ });\n  },\n\n  /**\n   * Handle tooltip display in response to an item.tooltip value.\n   * @param {Event} event - The event triggering tooltip display.\n   * @param {Item} item - The scenegraph item.\n   * @param {boolean} show - A boolean flag indicating whether\n   *   to show or hide a tooltip for the given item.\n   */\n  handleTooltip(event, item, show) {\n    if (item && item.tooltip != null) {\n      item = resolveItem(item, event, this.canvas(), this._origin);\n      const value = (show && item && item.tooltip) || null;\n      this._tooltip.call(this._obj, this, event, item, value);\n    }\n  },\n\n  /**\n   * Returns the size of a scenegraph item and its position relative\n   * to the viewport.\n   * @param {Item} item - The scenegraph item.\n   * @return {object} - A bounding box object (compatible with the\n   *   DOMRect type) consisting of x, y, width, heigh, top, left,\n   *   right, and bottom properties.\n   */\n  getItemBoundingClientRect(item) {\n    const el = this.canvas();\n    if (!el) return;\n\n    const rect = el.getBoundingClientRect(),\n          origin = this._origin,\n          bounds = item.bounds,\n          width = bounds.width(),\n          height = bounds.height();\n\n    let x = bounds.x1 + origin[0] + rect.left,\n        y = bounds.y1 + origin[1] + rect.top;\n\n    // translate coordinate for each parent group\n    while (item.mark && (item = item.mark.group)) {\n      x += item.x || 0;\n      y += item.y || 0;\n    }\n\n    // return DOMRect-compatible bounding box\n    return {\n      x, y, width, height,\n      left: x, top: y, right: x + width, bottom: y + height\n    };\n  }\n};\n","import ResourceLoader from './ResourceLoader';\n\n/**\n * Create a new Renderer instance.\n * @param {object} [loader] - Optional loader instance for\n *   image and href URL sanitization. If not specified, a\n *   standard loader instance will be generated.\n * @constructor\n */\nexport default function Renderer(loader) {\n  this._el = null;\n  this._bgcolor = null;\n  this._loader = new ResourceLoader(loader);\n}\n\nRenderer.prototype = {\n  /**\n   * Initialize a new Renderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    this._el = el;\n    return this.resize(width, height, origin, scaleFactor);\n  },\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element() {\n    return this._el;\n  },\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas() {\n    return this._el && this._el.firstChild;\n  },\n\n  /**\n   * Get / set the background color.\n   */\n  background(bgcolor) {\n    if (arguments.length === 0) return this._bgcolor;\n    this._bgcolor = bgcolor;\n    return this;\n  },\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    this._width = width;\n    this._height = height;\n    this._origin = origin || [0, 0];\n    this._scale = scaleFactor || 1;\n    return this;\n  },\n\n  /**\n   * Report a dirty item whose bounds should be redrawn.\n   * This base class method does nothing. Subclasses that perform\n   * incremental should implement this method.\n   * @param {Item} item - The dirty item whose bounds should be redrawn.\n   */\n  dirty(/*item*/) {},\n\n  /**\n   * Render an input scenegraph, potentially with a set of dirty items.\n   * This method will perform an immediate rendering with available resources.\n   * The renderer may also need to perform image loading to perform a complete\n   * render. This process can lead to asynchronous re-rendering of the scene\n   * after this method returns. To receive notification when rendering is\n   * complete, use the renderAsync method instead.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @return {Renderer} - This renderer instance.\n   */\n  render(scene) {\n    const r = this;\n\n    // bind arguments into a render call, and cache it\n    // this function may be subsequently called for async redraw\n    r._call = function() { r._render(scene); };\n\n    // invoke the renderer\n    r._call();\n\n    // clear the cached call for garbage collection\n    // async redraws will stash their own copy\n    r._call = null;\n\n    return r;\n  },\n\n  /**\n   * Internal rendering method. Renderer subclasses should override this\n   * method to actually perform rendering.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render(/*scene*/) {\n    // subclasses to override\n  },\n\n  /**\n   * Asynchronous rendering method. Similar to render, but returns a Promise\n   * that resolves when all rendering is completed. Sometimes a renderer must\n   * perform image loading to get a complete rendering. The returned\n   * Promise will not resolve until this process completes.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @return {Promise} - A Promise that resolves when rendering is complete.\n   */\n  renderAsync(scene) {\n    const r = this.render(scene);\n    return this._ready\n      ? this._ready.then(() => r)\n      : Promise.resolve(r);\n  },\n\n  /**\n   * Internal method for asynchronous resource loading.\n   * Proxies method calls to the ImageLoader, and tracks loading\n   * progress to invoke a re-render once complete.\n   * @param {string} method - The method name to invoke on the ImageLoader.\n   * @param {string} uri - The URI for the requested resource.\n   * @return {Promise} - A Promise that resolves to the requested resource.\n   */\n  _load(method, uri) {\n    var r = this,\n        p = r._loader[method](uri);\n\n    if (!r._ready) {\n      // re-render the scene when loading completes\n      const call = r._call;\n      r._ready = r._loader.ready()\n        .then(redraw => {\n          if (redraw) call();\n          r._ready = null;\n        });\n    }\n\n    return p;\n  },\n\n  /**\n   * Sanitize a URL to include as a hyperlink in the rendered scene.\n   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string to sanitize.\n   * @return {Promise} - A Promise that resolves to the sanitized URL.\n   */\n  sanitizeURL(uri) {\n    return this._load('sanitizeURL', uri);\n  },\n\n  /**\n   * Requests an image to include in the rendered scene.\n   * This method proxies a call to ImageLoader.loadImage, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string of the image.\n   * @return {Promise} - A Promise that resolves to the loaded Image.\n   */\n  loadImage(uri) {\n    return this._load('loadImage', uri);\n  }\n};\n","import marks from '../marks/index';\nimport point from './point';\n\nexport default function(item, event, el, origin) {\n  var mark = item && item.mark,\n      mdef, p;\n\n  if (mark && (mdef = marks[mark.marktype]).tip) {\n    p = point(event, el);\n    p[0] -= origin[0];\n    p[1] -= origin[1];\n    while (item = item.mark.group) {\n      p[0] -= item.x || 0;\n      p[1] -= item.y || 0;\n    }\n    item = mdef.tip(mark.items, p);\n  }\n\n  return item;\n}\n","export const KeyDownEvent = 'keydown';\nexport const KeyPressEvent = 'keypress';\nexport const KeyUpEvent = 'keyup';\nexport const DragEnterEvent = 'dragenter';\nexport const DragLeaveEvent = 'dragleave';\nexport const DragOverEvent = 'dragover';\nexport const MouseDownEvent = 'mousedown';\nexport const MouseUpEvent = 'mouseup';\nexport const MouseMoveEvent = 'mousemove';\nexport const MouseOutEvent = 'mouseout';\nexport const MouseOverEvent = 'mouseover';\nexport const ClickEvent = 'click';\nexport const DoubleClickEvent = 'dblclick';\nexport const WheelEvent = 'wheel';\nexport const MouseWheelEvent = 'mousewheel';\nexport const TouchStartEvent = 'touchstart';\nexport const TouchMoveEvent = 'touchmove';\nexport const TouchEndEvent = 'touchend';\n\nexport const Events = [\n  KeyDownEvent,\n  KeyPressEvent,\n  KeyUpEvent,\n  DragEnterEvent,\n  DragLeaveEvent,\n  DragOverEvent,\n  MouseDownEvent,\n  MouseUpEvent,\n  MouseMoveEvent,\n  MouseOutEvent,\n  MouseOverEvent,\n  ClickEvent,\n  DoubleClickEvent,\n  WheelEvent,\n  MouseWheelEvent,\n  TouchStartEvent,\n  TouchMoveEvent,\n  TouchEndEvent\n];\n\nexport const TooltipShowEvent = MouseMoveEvent;\n\nexport const TooltipHideEvent = MouseOutEvent;\n\nexport const HrefEvent = ClickEvent;\n","import Handler from './Handler';\nimport Marks from './marks/index';\nimport {\n  ClickEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, Events,\n  HrefEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent,\n  MouseWheelEvent, TooltipHideEvent, TooltipShowEvent,\n  TouchEndEvent, TouchMoveEvent, TouchStartEvent\n} from './util/events';\nimport point from './util/point';\nimport {domFind} from './util/dom';\nimport {inherits} from 'vega-util';\n\nexport default function CanvasHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  this._down = null;\n  this._touch = null;\n  this._first = true;\n  this._events = {};\n}\n\nconst eventBundle = type => (\n  type === TouchStartEvent ||\n  type === TouchMoveEvent ||\n  type === TouchEndEvent\n)\n? [TouchStartEvent, TouchMoveEvent, TouchEndEvent]\n: [type];\n\n// lazily add listeners to the canvas as needed\nfunction eventListenerCheck(handler, type) {\n  eventBundle(type).forEach(_ => addEventListener(handler, _));\n}\n\nfunction addEventListener(handler, type) {\n  const canvas = handler.canvas();\n  if (canvas && !handler._events[type]) {\n    handler._events[type] = 1;\n    canvas.addEventListener(type, handler[type]\n      ? evt => handler[type](evt)\n      : evt => handler.fire(type, evt)\n    );\n  }\n}\n\nfunction move(moveEvent, overEvent, outEvent) {\n  return function(evt) {\n    const a = this._active,\n          p = this.pickEvent(evt);\n\n    if (p === a) {\n      // active item and picked item are the same\n      this.fire(moveEvent, evt); // fire move\n    } else {\n      // active item and picked item are different\n      if (!a || !a.exit) {\n        // fire out for prior active item\n        // suppress if active item was removed from scene\n        this.fire(outEvent, evt);\n      }\n      this._active = p;          // set new active item\n      this.fire(overEvent, evt); // fire over for new active item\n      this.fire(moveEvent, evt); // fire move for new active item\n    }\n  };\n}\n\nfunction inactive(type) {\n  return function(evt) {\n    this.fire(type, evt);\n    this._active = null;\n  };\n}\n\ninherits(CanvasHandler, Handler, {\n  initialize(el, origin, obj) {\n    this._canvas = el && domFind(el, 'canvas');\n\n    // add minimal events required for proper state management\n    [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent]\n      .forEach(type => eventListenerCheck(this, type));\n\n    return Handler.prototype.initialize.call(this, el, origin, obj);\n  },\n\n  // return the backing canvas instance\n  canvas() {\n    return this._canvas;\n  },\n\n  // retrieve the current canvas context\n  context() {\n    return this._canvas.getContext('2d');\n  },\n\n  // supported events\n  events: Events,\n\n  // to keep old versions of firefox happy\n  DOMMouseScroll(evt) {\n    this.fire(MouseWheelEvent, evt);\n  },\n\n  mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),\n  dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),\n\n  mouseout: inactive(MouseOutEvent),\n  dragleave: inactive(DragLeaveEvent),\n\n  mousedown(evt) {\n    this._down = this._active;\n    this.fire(MouseDownEvent, evt);\n  },\n\n  click(evt) {\n    if (this._down === this._active) {\n      this.fire(ClickEvent, evt);\n      this._down = null;\n    }\n  },\n\n  touchstart(evt) {\n    this._touch = this.pickEvent(evt.changedTouches[0]);\n\n    if (this._first) {\n      this._active = this._touch;\n      this._first = false;\n    }\n\n    this.fire(TouchStartEvent, evt, true);\n  },\n\n  touchmove(evt) {\n    this.fire(TouchMoveEvent, evt, true);\n  },\n\n  touchend(evt) {\n    this.fire(TouchEndEvent, evt, true);\n    this._touch = null;\n  },\n\n  // fire an event\n  fire(type, evt, touch) {\n    const a = touch ? this._touch : this._active,\n          h = this._handlers[type];\n\n    // set event type relative to scenegraph items\n    evt.vegaType = type;\n\n    // handle hyperlinks and tooltips first\n    if (type === HrefEvent && a && a.href) {\n      this.handleHref(evt, a, a.href);\n    } else if (type === TooltipShowEvent || type === TooltipHideEvent) {\n      this.handleTooltip(evt, a, type !== TooltipHideEvent);\n    }\n\n    // invoke all registered handlers\n    if (h) {\n      for (let i=0, len=h.length; i<len; ++i) {\n        h[i].handler.call(this._obj, evt, a);\n      }\n    }\n  },\n\n  // add an event handler\n  on(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers,\n          i = this._handlerIndex(h[name], type, handler);\n\n    if (i < 0) {\n      eventListenerCheck(this, type);\n      (h[name] || (h[name] = [])).push({\n        type:    type,\n        handler: handler\n      });\n    }\n\n    return this;\n  },\n\n  // remove an event handler\n  off(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers[name],\n          i = this._handlerIndex(h, type, handler);\n\n    if (i >= 0) {\n      h.splice(i, 1);\n    }\n\n    return this;\n  },\n\n  pickEvent(evt) {\n    const p = point(evt, this._canvas),\n          o = this._origin;\n    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);\n  },\n\n  // find the scenegraph item at the current mouse position\n  // x, y -- the absolute x, y mouse coordinates on the canvas element\n  // gx, gy -- the relative coordinates within the current group\n  pick(scene, x, y, gx, gy) {\n    const g = this.context(),\n          mark = Marks[scene.marktype];\n    return mark.pick.call(this, g, scene, x, y, gx, gy);\n  }\n});\n","function devicePixelRatio() {\n  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;\n}\n\nvar pixelRatio = devicePixelRatio();\n\nexport default function(canvas, width, height, origin, scaleFactor, opt) {\n  const inDOM = typeof HTMLElement !== 'undefined'\n              && canvas instanceof HTMLElement\n              && canvas.parentNode != null,\n        context = canvas.getContext('2d'),\n        ratio = inDOM ? pixelRatio : scaleFactor;\n\n  canvas.width = width * ratio;\n  canvas.height = height * ratio;\n\n  for (const key in opt) {\n    context[key] = opt[key];\n  }\n\n  if (inDOM && ratio !== 1) {\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n\n  context.pixelRatio = ratio;\n  context.setTransform(\n    ratio, 0, 0, ratio,\n    ratio * origin[0],\n    ratio * origin[1]\n  );\n\n  return canvas;\n}\n","import Renderer from './Renderer';\nimport Bounds from './Bounds';\nimport marks from './marks/index';\n\nimport {domClear} from './util/dom';\nimport clip from './util/canvas/clip';\nimport resize from './util/canvas/resize';\nimport {canvas} from 'vega-canvas';\nimport {error, inherits} from 'vega-util';\n\nexport default function CanvasRenderer(loader) {\n  Renderer.call(this, loader);\n  this._options = {};\n  this._redraw = false;\n  this._dirty = new Bounds();\n  this._tempb = new Bounds();\n}\n\nconst base = Renderer.prototype;\n\nconst viewBounds = (origin, width, height) => new Bounds()\n  .set(0, 0, width, height)\n  .translate(-origin[0], -origin[1]);\n\nfunction clipToBounds(g, b, origin) {\n  // expand bounds by 1 pixel, then round to pixel boundaries\n  b.expand(1).round();\n\n  // align to base pixel grid in case of non-integer scaling (#2425)\n  if (g.pixelRatio % 1) {\n    b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);\n  }\n\n  // to avoid artifacts translate if origin has fractional pixels\n  b.translate(-(origin[0] % 1), -(origin[1] % 1));\n\n  // set clip path\n  g.beginPath();\n  g.rect(b.x1, b.y1, b.width(), b.height());\n  g.clip();\n\n  return b;\n}\n\ninherits(CanvasRenderer, Renderer, {\n  initialize(el, width, height, origin, scaleFactor, options) {\n    this._options = options || {};\n\n    this._canvas = this._options.externalContext\n      ? null\n      : canvas(1, 1, this._options.type); // instantiate a small canvas\n\n    if (el && this._canvas) {\n      domClear(el, 0).appendChild(this._canvas);\n      this._canvas.setAttribute('class', 'marks');\n    }\n\n    // this method will invoke resize to size the canvas appropriately\n    return base.initialize.call(this, el, width, height, origin, scaleFactor);\n  },\n\n  resize(width, height, origin, scaleFactor) {\n    base.resize.call(this, width, height, origin, scaleFactor);\n\n    if (this._canvas) {\n      // configure canvas size and transform\n      resize(this._canvas, this._width, this._height,\n        this._origin, this._scale, this._options.context);\n    } else {\n      // external context needs to be scaled and positioned to origin\n      const ctx = this._options.externalContext;\n      if (!ctx) error('CanvasRenderer is missing a valid canvas or context');\n      ctx.scale(this._scale, this._scale);\n      ctx.translate(this._origin[0], this._origin[1]);\n    }\n\n    this._redraw = true;\n    return this;\n  },\n\n  canvas() {\n    return this._canvas;\n  },\n\n  context() {\n    return this._options.externalContext\n      || (this._canvas ? this._canvas.getContext('2d') : null);\n  },\n\n  dirty(item) {\n    const b = this._tempb.clear().union(item.bounds);\n    let g = item.mark.group;\n\n    while (g) {\n      b.translate(g.x || 0, g.y || 0);\n      g = g.mark.group;\n    }\n\n    this._dirty.union(b);\n  },\n\n  _render(scene) {\n    const g = this.context(),\n          o = this._origin,\n          w = this._width,\n          h = this._height,\n          db = this._dirty,\n          vb = viewBounds(o, w, h);\n\n    // setup\n    g.save();\n    const b = this._redraw || db.empty()\n      ? (this._redraw = false, vb.expand(1))\n      : clipToBounds(g, vb.intersect(db), o);\n\n    this.clear(-o[0], -o[1], w, h);\n\n    // render\n    this.draw(g, scene, b);\n\n    // takedown\n    g.restore();\n    db.clear();\n\n    return this;\n  },\n\n  draw(ctx, scene, bounds) {\n    const mark = marks[scene.marktype];\n    if (scene.clip) clip(ctx, scene);\n    mark.draw.call(this, ctx, scene, bounds);\n    if (scene.clip) ctx.restore();\n  },\n\n  clear(x, y, w, h) {\n    const opt = this._options,\n          g = this.context();\n\n    if (opt.type !== 'pdf' && !opt.externalContext) {\n      // calling clear rect voids vector output in pdf mode\n      // and could remove external context content (#2615)\n      g.clearRect(x, y, w, h);\n    }\n\n    if (this._bgcolor != null) {\n      g.fillStyle = this._bgcolor;\n      g.fillRect(x, y, w, h);\n    }\n  }\n});\n","import Handler from './Handler';\nimport {domFind} from './util/dom';\nimport {HrefEvent, TooltipHideEvent, TooltipShowEvent} from './util/events';\nimport {inherits} from 'vega-util';\n\nexport default function SVGHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  const h = this;\n  h._hrefHandler = listener(h, (evt, item) => {\n    if (item && item.href) h.handleHref(evt, item, item.href);\n  });\n  h._tooltipHandler = listener(h, (evt, item) => {\n    h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);\n  });\n}\n\n// wrap an event listener for the SVG DOM\nconst listener = (context, handler) => evt => {\n  let item = evt.target.__data__;\n  item = Array.isArray(item) ? item[0] : item;\n  evt.vegaType = evt.type;\n  handler.call(context._obj, evt, item);\n};\n\ninherits(SVGHandler, Handler, {\n  initialize(el, origin, obj) {\n    let svg = this._svg;\n    if (svg) {\n      svg.removeEventListener(HrefEvent, this._hrefHandler);\n      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n    this._svg = svg = el && domFind(el, 'svg');\n    if (svg) {\n      svg.addEventListener(HrefEvent, this._hrefHandler);\n      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n    return Handler.prototype.initialize.call(this, el, origin, obj);\n  },\n\n  canvas() {\n    return this._svg;\n  },\n\n  // add an event handler\n  on(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers,\n          i = this._handlerIndex(h[name], type, handler);\n\n    if (i < 0) {\n      const x = {\n        type,\n        handler,\n        listener: listener(this, handler)\n      };\n\n      (h[name] || (h[name] = [])).push(x);\n      if (this._svg) {\n        this._svg.addEventListener(name, x.listener);\n      }\n    }\n\n    return this;\n  },\n\n  // remove an event handler\n  off(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers[name],\n          i = this._handlerIndex(h, type, handler);\n\n    if (i >= 0) {\n      if (this._svg) {\n        this._svg.removeEventListener(name, h[i].listener);\n      }\n      h.splice(i, 1);\n    }\n\n    return this;\n  }\n});","import {domainCaption, isDiscrete} from 'vega-scale';\nimport {array, peek, toSet} from 'vega-util';\n\nconst ARIA_HIDDEN = 'aria-hidden';\nconst ARIA_LABEL = 'aria-label';\nconst ARIA_ROLE = 'role';\nconst ARIA_ROLEDESCRIPTION = 'aria-roledescription';\nconst GRAPHICS_OBJECT = 'graphics-object';\nconst GRAPHICS_SYMBOL = 'graphics-symbol';\n\nconst bundle = (role, roledesc, label) => ({\n  [ARIA_ROLE]: role,\n  [ARIA_ROLEDESCRIPTION]: roledesc,\n  [ARIA_LABEL]: label || undefined\n});\n\n// these roles are covered by related roles\n// we can ignore them, no need to generate attributes\nconst AriaIgnore = toSet([\n  'axis-domain',\n  'axis-grid',\n  'axis-label',\n  'axis-tick',\n  'axis-title',\n  'legend-band',\n  'legend-entry',\n  'legend-gradient',\n  'legend-label',\n  'legend-title',\n  'legend-symbol',\n  'title'\n]);\n\n// aria attribute generators for guide roles\nconst AriaGuides = {\n  'axis': {desc: 'axis', caption: axisCaption},\n  'legend': {desc: 'legend', caption: legendCaption},\n  'title-text': {\n    desc: 'title',\n    caption: item => `Title text '${titleCaption(item)}'`\n  },\n  'title-subtitle': {\n    desc: 'subtitle',\n    caption: item => `Subtitle text '${titleCaption(item)}'`\n  }\n};\n\n// aria properties generated for mark item encoding channels\nexport const AriaEncode = {\n  ariaRole: ARIA_ROLE,\n  ariaRoleDescription: ARIA_ROLEDESCRIPTION,\n  description: ARIA_LABEL\n};\n\nexport function ariaItemAttributes(emit, item) {\n  const hide = item.aria === false;\n  emit(ARIA_HIDDEN, hide || undefined);\n\n  if (hide || item.description == null) {\n    for (const prop in AriaEncode) {\n      emit(AriaEncode[prop], undefined);\n    }\n  } else {\n    const type = item.mark.marktype;\n    emit(\n      ARIA_LABEL,\n      item.description\n    );\n    emit(\n      ARIA_ROLE,\n      item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL)\n    );\n    emit(\n      ARIA_ROLEDESCRIPTION,\n      item.ariaRoleDescription || `${type} mark`\n    );\n  }\n}\n\nexport function ariaMarkAttributes(mark) {\n  return mark.aria === false ? { [ARIA_HIDDEN]: true }\n    : AriaIgnore[mark.role] ? null\n    : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role])\n    : ariaMark(mark);\n}\n\nfunction ariaMark(mark) {\n  const type = mark.marktype;\n  const recurse = (\n    type === 'group' ||\n    type === 'text' ||\n    mark.items.some(_ => _.description != null && _.aria !== false)\n  );\n  return bundle(\n    recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL,\n    `${type} mark container`,\n    mark.description\n  );\n}\n\nfunction ariaGuide(mark, opt) {\n  try {\n    const item = mark.items[0],\n          caption = opt.caption || (() => '');\n    return bundle(\n      opt.role || GRAPHICS_SYMBOL,\n      opt.desc,\n      item.description || caption(item)\n    );\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction titleCaption(item) {\n  return array(item.text).join(' ');\n}\n\nfunction axisCaption(item) {\n  const datum = item.datum,\n        orient = item.orient,\n        title = datum.title ? extractTitle(item) : null,\n        ctx = item.context,\n        scale = ctx.scales[datum.scale].value,\n        locale = ctx.dataflow.locale(),\n        type = scale.type,\n        xy = (orient === 'left' || orient === 'right') ? 'Y' : 'X';\n\n  return `${xy}-axis`\n    + (title ? ` titled '${title}'` : '')\n    + ` for a ${isDiscrete(type) ? 'discrete' : type} scale`\n    + ` with ${domainCaption(locale, scale, item)}`;\n}\n\nfunction legendCaption(item) {\n  const datum = item.datum,\n        title = datum.title ? extractTitle(item) : null,\n        type = `${datum.type || ''} legend`.trim(),\n        scales = datum.scales,\n        props = Object.keys(scales),\n        ctx = item.context,\n        scale = ctx.scales[scales[props[0]]].value,\n        locale = ctx.dataflow.locale();\n\n  return capitalize(type)\n    + (title ? ` titled '${title}'` : '')\n    + ` for ${channelCaption(props)}`\n    + ` with ${domainCaption(locale, scale, item)}`;\n}\n\nfunction extractTitle(item) {\n  try {\n    return array(peek(item.items).items[0].text).join(' ');\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction channelCaption(props) {\n  props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));\n  return props.length < 2 ? props[0]\n    : props.slice(0, -1).join(', ') + ' and ' + peek(props);\n}\n\nfunction capitalize(s) {\n  return s.length ? s[0].toUpperCase() + s.slice(1) : s;\n}\n","const innerText = val => (val + '')\n  .replace(/&/g, '&amp;')\n  .replace(/</g, '&lt;')\n  .replace(/>/g, '&gt;');\n\nconst attrText = val => innerText(val)\n  .replace(/\"/g, '&quot;')\n  .replace(/\\t/g, '&#x9;')\n  .replace(/\\n/g, '&#xA;')\n  .replace(/\\r/g, '&#xD;');\n\nexport function markup() {\n  let buf = '',\n      outer = '',\n      inner = '';\n\n  const stack = [],\n        clear = () => outer = inner = '',\n        push = tag => {\n          if (outer) { buf += `${outer}>${inner}`; clear(); }\n          stack.push(tag);\n        },\n        attr = (name, value) => {\n          if (value != null) outer += ` ${name}=\"${attrText(value)}\"`;\n          return m;\n        },\n\n        m = {\n          open(tag, ...attrs) {\n            push(tag);\n            outer = '<' + tag;\n            for (const set of attrs) {\n              for (const key in set) attr(key, set[key]);\n            }\n            return m;\n          },\n          close() {\n            const tag = stack.pop();\n            if (outer) {\n              buf += outer + (inner\n                ? `>${inner}</${tag}>`\n                : '/>');\n            } else {\n              buf += `</${tag}>`;\n            }\n            clear();\n            return m;\n          },\n          attr,\n          text: t => (inner += innerText(t), m),\n          toString: () => buf\n        };\n\n  return m;\n}\n\nexport const serializeXML = node =>\n  _serialize(markup(), node) + '';\n\nfunction _serialize(m, node) {\n  m.open(node.tagName);\n\n  if (node.hasAttributes()) {\n    const attrs = node.attributes,\n          n = attrs.length;\n    for (let i=0; i<n; ++i) {\n      m.attr(attrs[i].name, attrs[i].value);\n    }\n  }\n\n  if (node.hasChildNodes()) {\n    const children = node.childNodes,\n          n = children.length;\n\n    for (let i=0; i<n; i++) {\n      const child = children[i];\n      child.nodeType === 3 // text node\n        ? m.text(child.nodeValue)\n        : _serialize(m, child);\n    }\n  }\n\n  return m.close();\n}\n","export const styles = {\n  fill:             'fill',\n  fillOpacity:      'fill-opacity',\n  stroke:           'stroke',\n  strokeOpacity:    'stroke-opacity',\n  strokeWidth:      'stroke-width',\n  strokeCap:        'stroke-linecap',\n  strokeJoin:       'stroke-linejoin',\n  strokeDash:       'stroke-dasharray',\n  strokeDashOffset: 'stroke-dashoffset',\n  strokeMiterLimit: 'stroke-miterlimit',\n  opacity:          'opacity',\n  blend:            'mix-blend-mode'\n};\n\n// ensure miter limit default is consistent with canvas (#2498)\nexport const rootAttributes = {\n  'fill': 'none',\n  'stroke-miterlimit': 10\n};\n","import Renderer from './Renderer';\nimport {gradientRef, isGradient, patternPrefix} from './Gradient';\nimport marks from './marks/index';\nimport {ariaItemAttributes, ariaMarkAttributes} from './util/aria';\nimport {cssClass, domChild, domClear, domCreate} from './util/dom';\nimport {serializeXML} from './util/markup';\nimport {fontFamily, fontSize, lineHeight, textLines, textValue} from './util/text';\nimport {visit} from './util/visit';\nimport clip from './util/svg/clip';\nimport metadata from './util/svg/metadata';\nimport {rootAttributes, styles} from './util/svg/styles';\nimport {inherits, isArray} from 'vega-util';\n\nconst RootIndex = 0,\n      xmlns = 'http://www.w3.org/2000/xmlns/',\n      svgns = metadata.xmlns;\n\nexport default function SVGRenderer(loader) {\n  Renderer.call(this, loader);\n  this._dirtyID = 0;\n  this._dirty = [];\n  this._svg = null;\n  this._root = null;\n  this._defs = null;\n}\n\nconst base = Renderer.prototype;\n\ninherits(SVGRenderer, Renderer, {\n  /**\n   * Initialize a new SVGRenderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    // create the svg definitions cache\n    this._defs = {};\n    this._clearDefs();\n\n    if (el) {\n      this._svg = domChild(el, 0, 'svg', svgns);\n      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);\n      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);\n      this._svg.setAttribute('version', metadata['version']);\n      this._svg.setAttribute('class', 'marks');\n      domClear(el, 1);\n\n      // set the svg root group\n      this._root = domChild(this._svg, RootIndex, 'g', svgns);\n      setAttributes(this._root, rootAttributes);\n\n      // ensure no additional child elements\n      domClear(this._svg, RootIndex + 1);\n    }\n\n    // set background color if defined\n    this.background(this._bgcolor);\n\n    return base.initialize.call(this, el, width, height, origin, scaleFactor);\n  },\n\n  /**\n   * Get / set the background color.\n   */\n  background(bgcolor) {\n    if (arguments.length && this._svg) {\n      this._svg.style.setProperty('background-color', bgcolor);\n    }\n    return base.background.apply(this, arguments);\n  },\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    base.resize.call(this, width, height, origin, scaleFactor);\n\n    if (this._svg) {\n      setAttributes(this._svg, {\n        width: this._width * this._scale,\n        height: this._height * this._scale,\n        viewBox: `0 0 ${this._width} ${this._height}`\n      });\n      this._root.setAttribute('transform', `translate(${this._origin})`);\n    }\n\n    this._dirty = [];\n\n    return this;\n  },\n\n  /**\n   * Returns the SVG element of the visualization.\n   * @return {DOMElement} - The SVG element.\n   */\n  canvas() {\n    return this._svg;\n  },\n\n  /**\n   * Returns an SVG text string for the rendered content,\n   * or null if this renderer is currently headless.\n   */\n  svg() {\n    const svg = this._svg,\n          bg = this._bgcolor;\n\n    if (!svg) return null;\n\n    let node;\n    if (bg) {\n      svg.removeAttribute('style');\n      node = domChild(svg, RootIndex, 'rect', svgns);\n      setAttributes(node, {width: this._width, height: this._height, fill: bg});\n    }\n\n    const text = serializeXML(svg);\n\n    if (bg) {\n      svg.removeChild(node);\n      this._svg.style.setProperty('background-color', bg);\n    }\n\n    return text;\n  },\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render(scene) {\n    // perform spot updates and re-render markup\n    if (this._dirtyCheck()) {\n      if (this._dirtyAll) this._clearDefs();\n      this.mark(this._root, scene);\n      domClear(this._root, 1);\n    }\n\n    this.defs();\n\n    this._dirty = [];\n    ++this._dirtyID;\n\n    return this;\n  },\n\n  // -- Manage rendering of items marked as dirty --\n\n  /**\n   * Flag a mark item as dirty.\n   * @param {Item} item - The mark item.\n   */\n  dirty(item) {\n    if (item.dirty !== this._dirtyID) {\n      item.dirty = this._dirtyID;\n      this._dirty.push(item);\n    }\n  },\n\n  /**\n   * Check if a mark item is considered dirty.\n   * @param {Item} item - The mark item.\n   */\n  isDirty(item) {\n    return this._dirtyAll\n      || !item._svg\n      || item.dirty === this._dirtyID;\n  },\n\n  /**\n   * Internal method to check dirty status and, if possible,\n   * make targetted updates without a full rendering pass.\n   */\n  _dirtyCheck() {\n    this._dirtyAll = true;\n    const items = this._dirty;\n    if (!items.length || !this._dirtyID) return true;\n\n    const id = ++this._dirtyID;\n    let item, mark, type, mdef, i, n, o;\n\n    for (i=0, n=items.length; i<n; ++i) {\n      item = items[i];\n      mark = item.mark;\n\n      if (mark.marktype !== type) {\n        // memoize mark instance lookup\n        type = mark.marktype;\n        mdef = marks[type];\n      }\n\n      if (mark.zdirty && mark.dirty !== id) {\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n        mark.items.forEach(i => { i.dirty = id; });\n      }\n      if (mark.zdirty) continue; // handle in standard drawing pass\n\n      if (item.exit) { // EXIT\n        if (mdef.nested && mark.items.length) {\n          // if nested mark with remaining points, update instead\n          o = mark.items[0];\n          if (o._svg) this._update(mdef, o._svg, o);\n        } else if (item._svg) {\n          // otherwise remove from DOM\n          o = item._svg.parentNode;\n          if (o) o.removeChild(item._svg);\n        }\n        item._svg = null;\n        continue;\n      }\n\n      item = (mdef.nested ? mark.items[0] : item);\n      if (item._update === id) continue; // already visited\n\n      if (!item._svg || !item._svg.ownerSVGElement) {\n        // ENTER\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n      } else {\n        // IN-PLACE UPDATE\n        this._update(mdef, item._svg, item);\n      }\n      item._update = id;\n    }\n    return !this._dirtyAll;\n  },\n\n  // -- Construct & maintain scenegraph to SVG mapping ---\n\n  /**\n   * Render a set of mark items.\n   * @param {SVGElement} el - The parent element in the SVG tree.\n   * @param {object} scene - The mark parent to render.\n   * @param {SVGElement} prev - The previous sibling in the SVG tree.\n   */\n  mark(el, scene, prev) {\n    if (!this.isDirty(scene)) return scene._svg;\n\n    const svg = this._svg,\n          mdef = marks[scene.marktype],\n          events = scene.interactive === false ? 'none' : null,\n          isGroup = mdef.tag === 'g';\n\n    let sibling = null,\n        i = 0;\n\n    const parent = bind(scene, el, prev, 'g', svg);\n    parent.setAttribute('class', cssClass(scene));\n\n    // apply aria attributes to parent container element\n    const aria = ariaMarkAttributes(scene);\n    for (const key in aria) setAttribute(parent, key, aria[key]);\n\n    if (!isGroup) {\n      setAttribute(parent, 'pointer-events', events);\n    }\n    setAttribute(parent, 'clip-path',\n      scene.clip ? clip(this, scene, scene.group) : null);\n\n    const process = item => {\n      const dirty = this.isDirty(item),\n            node = bind(item, parent, sibling, mdef.tag, svg);\n\n      if (dirty) {\n        this._update(mdef, node, item);\n        if (isGroup) recurse(this, node, item);\n      }\n\n      sibling = node;\n      ++i;\n    };\n\n    if (mdef.nested) {\n      if (scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    }\n\n    domClear(parent, i);\n    return parent;\n  },\n\n  /**\n   * Update the attributes of an SVG element for a mark item.\n   * @param {object} mdef - The mark definition object\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  _update(mdef, el, item) {\n    // set dom element and values cache\n    // provides access to emit method\n    element = el;\n    values = el.__values__;\n\n    // apply aria-specific properties\n    ariaItemAttributes(emit, item);\n\n    // apply svg attributes\n    mdef.attr(emit, item, this);\n\n    // some marks need special treatment\n    const extra = mark_extras[mdef.type];\n    if (extra) extra.call(this, mdef, el, item);\n\n    // apply svg style attributes\n    // note: element state may have been modified by 'extra' method\n    if (element) this.style(element, item);\n  },\n\n  /**\n   * Update the presentation attributes of an SVG element for a mark item.\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  style(el, item) {\n    if (item == null) return;\n\n    for (const prop in styles) {\n      let value = prop === 'font' ? fontFamily(item) : item[prop];\n      if (value === values[prop]) continue;\n\n      const name = styles[prop];\n      if (value == null) {\n        el.removeAttribute(name);\n      } else {\n        if (isGradient(value)) {\n          value = gradientRef(value, this._defs.gradient, href());\n        }\n        el.setAttribute(name, value + '');\n      }\n\n      values[prop] = value;\n    }\n  },\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   */\n  defs() {\n    const svg = this._svg,\n          defs = this._defs;\n\n    let el = defs.el,\n        index = 0;\n\n    for (const id in defs.gradient) {\n      if (!el) defs.el = (el = domChild(svg, RootIndex + 1, 'defs', svgns));\n      index = updateGradient(el, defs.gradient[id], index);\n    }\n\n    for (const id in defs.clipping) {\n      if (!el) defs.el = (el = domChild(svg, RootIndex + 1, 'defs', svgns));\n      index = updateClipping(el, defs.clipping[id], index);\n    }\n\n    // clean-up\n    if (el) {\n      index === 0\n        ? (svg.removeChild(el), defs.el = null)\n        : domClear(el, index);\n    }\n  },\n\n  /**\n   * Clear defs caches.\n   */\n  _clearDefs() {\n    const def = this._defs;\n    def.gradient = {};\n    def.clipping = {};\n  }\n});\n\n// mark ancestor chain with a dirty id\nfunction dirtyParents(item, id) {\n  for (; item && item.dirty !== id; item=item.mark.group) {\n    item.dirty = id;\n    if (item.mark && item.mark.dirty !== id) {\n      item.mark.dirty = id;\n    } else return;\n  }\n}\n\n// update gradient definitions\nfunction updateGradient(el, grad, index) {\n  let i, n, stop;\n\n  if (grad.gradient === 'radial') {\n    // SVG radial gradients automatically transform to normalized bbox\n    // coordinates, in a way that is cumbersome to replicate in canvas.\n    // We wrap the radial gradient in a pattern element, allowing us to\n    // maintain a circular gradient that matches what canvas provides.\n    let pt = domChild(el, index++, 'pattern', svgns);\n    setAttributes(pt, {\n      id: patternPrefix + grad.id,\n      viewBox: '0,0,1,1',\n      width: '100%',\n      height: '100%',\n      preserveAspectRatio: 'xMidYMid slice'\n    });\n\n    pt = domChild(pt, 0, 'rect', svgns);\n    setAttributes(pt, {\n      width: 1,\n      height: 1,\n      fill: `url(${href()}#${grad.id})`\n    });\n\n    el = domChild(el, index++, 'radialGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      fx: grad.x1,\n      fy: grad.y1,\n      fr: grad.r1,\n      cx: grad.x2,\n      cy: grad.y2,\n      r: grad.r2\n    });\n  } else {\n    el = domChild(el, index++, 'linearGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      x1: grad.x1,\n      x2: grad.x2,\n      y1: grad.y1,\n      y2: grad.y2\n    });\n  }\n\n  for (i=0, n=grad.stops.length; i<n; ++i) {\n    stop = domChild(el, i, 'stop', svgns);\n    stop.setAttribute('offset', grad.stops[i].offset);\n    stop.setAttribute('stop-color', grad.stops[i].color);\n  }\n  domClear(el, i);\n\n  return index;\n}\n\n// update clipping path definitions\nfunction updateClipping(el, clip, index) {\n  let mask;\n\n  el = domChild(el, index, 'clipPath', svgns);\n  el.setAttribute('id', clip.id);\n\n  if (clip.path) {\n    mask = domChild(el, 0, 'path', svgns);\n    mask.setAttribute('d', clip.path);\n  } else {\n    mask = domChild(el, 0, 'rect', svgns);\n    setAttributes(mask, {x: 0, y: 0, width: clip.width, height: clip.height});\n  }\n  domClear(el, 1);\n\n  return index + 1;\n}\n\n// Recursively process group contents.\nfunction recurse(renderer, el, group) {\n  el = el.lastChild.previousSibling;\n  let prev, idx = 0;\n\n  visit(group, item => {\n    prev = renderer.mark(el, item, prev);\n    ++idx;\n  });\n\n  // remove any extraneous DOM elements\n  domClear(el, 1 + idx);\n}\n\n// Bind a scenegraph item to an SVG DOM element.\n// Create new SVG elements as needed.\nfunction bind(item, el, sibling, tag, svg) {\n  let node = item._svg, doc;\n\n  // create a new dom node if needed\n  if (!node) {\n    doc = el.ownerDocument;\n    node = domCreate(doc, tag, svgns);\n    item._svg = node;\n\n    if (item.mark) {\n      node.__data__ = item;\n      node.__values__ = {fill: 'default'};\n\n      // if group, create background, content, and foreground elements\n      if (tag === 'g') {\n        const bg = domCreate(doc, 'path', svgns);\n        node.appendChild(bg);\n        bg.__data__ = item;\n\n        const cg = domCreate(doc, 'g', svgns);\n        node.appendChild(cg);\n        cg.__data__ = item;\n\n        const fg = domCreate(doc, 'path', svgns);\n        node.appendChild(fg);\n        fg.__data__ = item;\n        fg.__values__ = {fill: 'default'};\n      }\n    }\n  }\n\n  // (re-)insert if (a) not contained in SVG or (b) sibling order has changed\n  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {\n    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);\n  }\n\n  return node;\n}\n\n// check if two nodes are ordered siblings\nfunction siblingCheck(node, sibling) {\n  return node.parentNode\n    && node.parentNode.childNodes.length > 1\n    && node.previousSibling != sibling; // treat null/undefined the same\n}\n\n// -- Set attributes & styles on SVG elements ---\n\nlet element = null, // temp var for current SVG element\n    values = null;  // temp var for current values hash\n\n// Extra configuration for certain mark types\nconst mark_extras = {\n  group(mdef, el, item) {\n    const fg = element = el.childNodes[2];\n    values = fg.__values__;\n    mdef.foreground(emit, item, this);\n\n    values = el.__values__; // use parent's values hash\n    element = el.childNodes[1];\n    mdef.content(emit, item, this);\n\n    const bg = element = el.childNodes[0];\n    mdef.background(emit, item, this);\n\n    const value = item.mark.interactive === false ? 'none' : null;\n    if (value !== values.events) {\n      setAttribute(fg, 'pointer-events', value);\n      setAttribute(bg, 'pointer-events', value);\n      values.events = value;\n    }\n\n    if (item.strokeForeground && item.stroke) {\n      const fill = item.fill;\n      setAttribute(fg, 'display', null);\n\n      // set style of background\n      this.style(bg, item);\n      setAttribute(bg, 'stroke', null);\n\n      // set style of foreground\n      if (fill) item.fill = null;\n      values = fg.__values__;\n      this.style(fg, item);\n      if (fill) item.fill = fill;\n\n      // leave element null to prevent downstream styling\n      element = null;\n    } else {\n      // ensure foreground is ignored\n      setAttribute(fg, 'display', 'none');\n    }\n  },\n  image(mdef, el, item) {\n    if (item.smooth === false) {\n      setStyle(el, 'image-rendering', 'optimizeSpeed');\n      setStyle(el, 'image-rendering', 'pixelated');\n    } else {\n      setStyle(el, 'image-rendering', null);\n    }\n  },\n  text(mdef, el, item) {\n    const tl = textLines(item);\n    let key, value, doc, lh;\n\n    if (isArray(tl)) {\n      // multi-line text\n      value = tl.map(_ => textValue(item, _));\n      key = value.join('\\n'); // content cache key\n\n      if (key !== values.text) {\n        domClear(el, 0);\n        doc = el.ownerDocument;\n        lh = lineHeight(item);\n        value.forEach((t, i) => {\n          const ts = domCreate(doc, 'tspan', svgns);\n          ts.__data__ = item; // data binding\n          ts.textContent = t;\n          if (i) {\n            ts.setAttribute('x', 0);\n            ts.setAttribute('dy', lh);\n          }\n          el.appendChild(ts);\n        });\n        values.text = key;\n      }\n    } else {\n      // single-line text\n      value = textValue(item, tl);\n      if (value !== values.text) {\n        el.textContent = value;\n        values.text = value;\n      }\n    }\n\n    setAttribute(el, 'font-family', fontFamily(item));\n    setAttribute(el, 'font-size', fontSize(item) + 'px');\n    setAttribute(el, 'font-style', item.fontStyle);\n    setAttribute(el, 'font-variant', item.fontVariant);\n    setAttribute(el, 'font-weight', item.fontWeight);\n  }\n};\n\nfunction emit(name, value, ns) {\n  // early exit if value is unchanged\n  if (value === values[name]) return;\n\n  // use appropriate method given namespace (ns)\n  if (ns) {\n    setAttributeNS(element, name, value, ns);\n  } else {\n    setAttribute(element, name, value);\n  }\n\n  // note current value for future comparison\n  values[name] = value;\n}\n\nfunction setStyle(el, name, value) {\n  if (value !== values[name]) {\n    if (value == null) {\n      el.style.removeProperty(name);\n    } else {\n      el.style.setProperty(name, value + '');\n    }\n    values[name] = value;\n  }\n}\n\nfunction setAttributes(el, attrs) {\n  for (const key in attrs) {\n    setAttribute(el, key, attrs[key]);\n  }\n}\n\nfunction setAttribute(el, name, value) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttribute(name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttribute(name);\n  }\n}\n\nfunction setAttributeNS(el, name, value, ns) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttributeNS(ns, name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttributeNS(ns, name);\n  }\n}\n\nfunction href() {\n  let loc;\n  return typeof window === 'undefined' ? ''\n    : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length)\n    : loc.href;\n}\n","import Renderer from './Renderer';\nimport {gradientRef, isGradient, patternPrefix} from './Gradient';\nimport Marks from './marks/index';\nimport {ariaItemAttributes, ariaMarkAttributes} from './util/aria';\nimport {cssClass} from './util/dom';\nimport {markup} from './util/markup';\nimport {fontFamily, fontSize, lineHeight, textLines, textValue} from './util/text';\nimport {visit} from './util/visit';\nimport clip from './util/svg/clip';\nimport metadata from './util/svg/metadata';\nimport {rootAttributes, styles} from './util/svg/styles';\nimport {extend, inherits, isArray} from 'vega-util';\n\nexport default function SVGStringRenderer(loader) {\n  Renderer.call(this, loader);\n  this._text = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n}\n\ninherits(SVGStringRenderer, Renderer, {\n  /**\n   * Returns the rendered SVG text string,\n   * or null if rendering has not yet occurred.\n   */\n  svg() {\n    return this._text;\n  },\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render(scene) {\n    const m = markup();\n\n    // svg tag\n    m.open('svg', extend({}, metadata, {\n      class:   'marks',\n      width:   this._width * this._scale,\n      height:  this._height * this._scale,\n      viewBox: `0 0 ${this._width} ${this._height}`\n    }));\n\n    // background, if defined\n    const bg = this._bgcolor;\n    if (bg && bg !== 'transparent' && bg !== 'none') {\n      m.open('rect', {\n        width:  this._width,\n        height: this._height,\n        fill:   bg\n      }).close();\n    }\n\n    // root content group\n    m.open('g', rootAttributes, {\n      transform: 'translate(' + this._origin + ')'\n    });\n    this.mark(m, scene);\n    m.close(); // </g>\n\n    // defs\n    this.defs(m);\n\n    // get SVG text string\n    this._text = m.close() + '';\n\n    return this;\n  },\n\n  /**\n   * Render a set of mark items.\n   * @param {object} m - The markup context.\n   * @param {object} scene - The mark parent to render.\n   */\n  mark(m, scene) {\n    const mdef = Marks[scene.marktype],\n          tag  = mdef.tag,\n          attrList = [ariaItemAttributes, mdef.attr];\n\n    // render opening group tag\n    m.open('g',\n      {\n        'class': cssClass(scene),\n        'clip-path': scene.clip ? clip(this, scene, scene.group) : null\n      },\n      ariaMarkAttributes(scene),\n      {\n        'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null\n      }\n    );\n\n    // render contained elements\n    const process = item => {\n      const href = this.href(item);\n      if (href) m.open('a', href);\n\n      m.open(\n        tag,\n        this.attr(scene, item, attrList, tag !== 'g' ? tag : null)\n      );\n\n      if (tag === 'text') {\n        const tl = textLines(item);\n        if (isArray(tl)) {\n          // multi-line text\n          const attrs = {x: 0, dy: lineHeight(item)};\n          for (let i=0; i<tl.length; ++i) {\n            m.open('tspan', i ? attrs: null)\n              .text(textValue(item, tl[i]))\n              .close();\n          }\n        } else {\n          // single-line text\n          m.text(textValue(item, tl));\n        }\n      } else if (tag === 'g') {\n        const fore = item.strokeForeground,\n              fill = item.fill,\n              stroke = item.stroke;\n\n        if (fore && stroke) {\n          item.stroke = null;\n        }\n\n        m.open(\n          'path',\n          this.attr(scene, item, mdef.background, 'bgrect')\n        ).close();\n\n        // recurse for group content\n        m.open('g', this.attr(scene, item, mdef.content));\n        visit(item, scene => this.mark(m, scene));\n        m.close();\n\n        if (fore && stroke) {\n          if (fill) item.fill = null;\n          item.stroke = stroke;\n\n          m.open(\n            'path',\n            this.attr(scene, item, mdef.foreground, 'bgrect')\n          ).close();\n\n          if (fill) item.fill = fill;\n        } else {\n          m.open(\n            'path',\n            this.attr(scene, item, mdef.foreground, 'bgfore')\n          ).close();\n        }\n      }\n\n      m.close(); // </tag>\n      if (href) m.close(); // </a>\n    };\n\n    if (mdef.nested) {\n      if (scene.items && scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    }\n\n    // render closing group tag\n    return m.close(); // </g>\n  },\n\n  /**\n   * Get href attributes for a hyperlinked mark item.\n   * @param {Item} item - The mark item.\n   */\n  href(item) {\n    const href = item.href;\n    let attr;\n\n    if (href) {\n      if (attr = this._hrefs && this._hrefs[href]) {\n        return attr;\n      } else {\n        this.sanitizeURL(href).then(attr => {\n          // rewrite to use xlink namespace\n          attr['xlink:href'] = attr.href;\n          attr.href = null;\n          (this._hrefs || (this._hrefs = {}))[href] = attr;\n        });\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Get an object of SVG attributes for a mark item.\n   * @param {object} scene - The mark parent.\n   * @param {Item} item - The mark item.\n   * @param {array|function} attrs - One or more attribute emitters.\n   * @param {string} tag - The tag being rendered.\n   */\n  attr(scene, item, attrs, tag) {\n    const object = {},\n          emit = (name, value, ns, prefixed) => {\n            object[prefixed || name] = value;\n          };\n\n    // apply mark specific attributes\n    if (Array.isArray(attrs)) {\n      attrs.forEach(fn => fn(emit, item, this));\n    } else {\n      attrs(emit, item, this);\n    }\n\n    // apply style attributes\n    if (tag) {\n      style(object, item, scene, tag, this._defs);\n    }\n\n    return object;\n  },\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   * @param {object} m - The markup context.\n   */\n  defs(m) {\n    const gradient = this._defs.gradient,\n          clipping = this._defs.clipping,\n          count = Object.keys(gradient).length + Object.keys(clipping).length;\n\n    if (count === 0) return; // nothing to do\n\n    m.open('defs');\n\n    for (const id in gradient) {\n      const def = gradient[id],\n            stops = def.stops;\n\n      if (def.gradient === 'radial') {\n        // SVG radial gradients automatically transform to normalized bbox\n        // coordinates, in a way that is cumbersome to replicate in canvas.\n        // We wrap the radial gradient in a pattern element, allowing us to\n        // maintain a circular gradient that matches what canvas provides.\n\n        m.open('pattern', {\n          id: patternPrefix + id,\n          viewBox: '0,0,1,1',\n          width: '100%',\n          height: '100%',\n          preserveAspectRatio: 'xMidYMid slice'\n        });\n\n        m.open('rect', {\n          width:  '1',\n          height: '1',\n          fill:   'url(#' + id + ')'\n        }).close();\n\n        m.close(); // </pattern>\n\n        m.open('radialGradient', {\n          id: id,\n          fx: def.x1,\n          fy: def.y1,\n          fr: def.r1,\n          cx: def.x2,\n          cy: def.y2,\n          r: def.r2\n        });\n      } else {\n        m.open('linearGradient', {\n          id: id,\n          x1: def.x1,\n          x2: def.x2,\n          y1: def.y1,\n          y2: def.y2\n        });\n      }\n\n      for (let i = 0; i < stops.length; ++i) {\n        m.open('stop', {\n          offset: stops[i].offset,\n          'stop-color': stops[i].color\n        }).close();\n      }\n\n      m.close();\n    }\n\n    for (const id in clipping) {\n      const def = clipping[id];\n\n      m.open('clipPath', {id: id});\n      if (def.path) {\n        m.open('path', {\n          d: def.path\n        }).close();\n      } else {\n        m.open('rect', {\n          x: 0,\n          y: 0,\n          width: def.width,\n          height: def.height\n        }).close();\n      }\n      m.close();\n    }\n\n    m.close();\n  }\n});\n\n// Helper function for attr for style presentation attributes\nfunction style(s, item, scene, tag, defs) {\n  if (item == null) return s;\n\n  if (tag === 'bgrect' && scene.interactive === false) {\n    s['pointer-events'] = 'none';\n  }\n\n  if (tag === 'bgfore') {\n    if (scene.interactive === false) {\n      s['pointer-events'] = 'none';\n    }\n    s.display = 'none';\n    if (item.fill !== null) return s;\n  }\n\n  if (tag === 'image' && item.smooth === false) {\n    s.style = 'image-rendering: optimizeSpeed; image-rendering: pixelated;';\n  }\n\n  if (tag === 'text') {\n    s['font-family'] = fontFamily(item);\n    s['font-size'] = fontSize(item) + 'px';\n    s['font-style'] = item.fontStyle;\n    s['font-variant'] = item.fontVariant;\n    s['font-weight'] = item.fontWeight;\n  }\n\n  for (const prop in styles) {\n    let value = item[prop];\n    const name = styles[prop];\n\n    if (value === 'transparent' && (name === 'fill' || name === 'stroke')) {\n      // transparent is not a legal SVG value\n      // we can skip it to rely on default 'none' instead\n    } else if (value != null) {\n      if (isGradient(value)) {\n        value = gradientRef(value, defs.gradient, '');\n      }\n      s[name] = value;\n    }\n  }\n\n  return s;\n}\n","import CanvasHandler from './CanvasHandler';\nimport CanvasRenderer from './CanvasRenderer';\nimport SVGHandler from './SVGHandler';\nimport SVGRenderer from './SVGRenderer';\nimport SVGStringRenderer from './SVGStringRenderer';\n\nconst Canvas = 'canvas';\nconst PNG = 'png';\nconst SVG = 'svg';\nconst None = 'none';\n\nexport const RenderType = {\n  Canvas: Canvas,\n  PNG:    PNG,\n  SVG:    SVG,\n  None:   None\n};\n\nconst modules = {};\n\nmodules[Canvas] = modules[PNG] = {\n  renderer: CanvasRenderer,\n  headless: CanvasRenderer,\n  handler:  CanvasHandler\n};\n\nmodules[SVG] = {\n  renderer: SVGRenderer,\n  headless: SVGStringRenderer,\n  handler:  SVGHandler\n};\n\nmodules[None] = {};\n\nexport function renderModule(name, _) {\n  name = String(name || '').toLowerCase();\n  if (arguments.length > 1) {\n    modules[name] = _;\n    return this;\n  } else {\n    return modules[name];\n  }\n}\n","import Marks from './marks/index';\nimport {error} from 'vega-util';\nimport Bounds from './Bounds';\n\nexport function intersect(scene, bounds, filter) {\n  const hits = [], // intersection results\n        box = new Bounds().union(bounds), // defensive copy\n        type = scene.marktype;\n\n  return type ? intersectMark(scene, box, filter, hits)\n    : type === 'group' ? intersectGroup(scene, box, filter, hits)\n    : error('Intersect scene must be mark node or group item.');\n}\n\nfunction intersectMark(mark, box, filter, hits) {\n  if (visitMark(mark, box, filter)) {\n    const items = mark.items,\n          type = mark.marktype,\n          n = items.length;\n\n    let i = 0;\n\n    if (type === 'group') {\n      for (; i<n; ++i) {\n        intersectGroup(items[i], box, filter, hits);\n      }\n    } else {\n      for (const test = Marks[type].isect; i<n; ++i) {\n        const item = items[i];\n        if (intersectItem(item, box, test)) hits.push(item);\n      }\n    }\n  }\n  return hits;\n}\n\nfunction visitMark(mark, box, filter) {\n  // process if bounds intersect and if\n  // (1) mark is a group mark (so we must recurse), or\n  // (2) mark is interactive and passes filter\n  return mark.bounds && box.intersects(mark.bounds) && (\n    mark.marktype === 'group' ||\n    mark.interactive !== false && (!filter || filter(mark))\n  );\n}\n\nfunction intersectGroup(group, box, filter, hits) {\n  // test intersect against group\n  // skip groups by default unless filter says otherwise\n  if ((filter && filter(group.mark)) &&\n      intersectItem(group, box, Marks.group.isect)) {\n    hits.push(group);\n  }\n\n  // recursively test children marks\n  // translate box to group coordinate space\n  const marks = group.items,\n        n = marks && marks.length;\n\n  if (n) {\n    const x = group.x || 0,\n          y = group.y || 0;\n    box.translate(-x, -y);\n    for (let i=0; i<n; ++i) {\n      intersectMark(marks[i], box, filter, hits);\n    }\n    box.translate(x, y);\n  }\n\n  return hits;\n}\n\nfunction intersectItem(item, box, test) {\n  // test bounds enclosure, bounds intersection, then detailed test\n  const bounds = item.bounds;\n  return box.encloses(bounds) || (box.intersects(bounds) && test(item, box));\n}\n\n","import Bounds from '../Bounds';\nimport boundContext from './boundContext';\nimport {isFunction} from 'vega-util';\n\nconst clipBounds = new Bounds();\n\nexport default function(mark) {\n  const clip = mark.clip;\n\n  if (isFunction(clip)) {\n    clip(boundContext(clipBounds.clear()));\n  } else if (clip) {\n    clipBounds.set(0, 0, mark.group.width, mark.group.height);\n  } else return;\n\n  mark.bounds.intersect(clipBounds);\n}\n","import pathParse from '../path/parse';\nimport {isNumber, isObject} from 'vega-util';\n\nconst TOLERANCE = 1e-9;\n\nexport function sceneEqual(a, b, key) {\n  return (a === b) ? true\n    : (key === 'path') ? pathEqual(a, b)\n    : (a instanceof Date && b instanceof Date) ? +a === +b\n    : (isNumber(a) && isNumber(b)) ? Math.abs(a - b) <= TOLERANCE\n    : (!a || !b || !isObject(a) && !isObject(b)) ? a == b\n    : objectEqual(a, b);\n}\n\nexport function pathEqual(a, b) {\n  return sceneEqual(pathParse(a), pathParse(b));\n}\n\nfunction objectEqual(a, b) {\n  var ka = Object.keys(a),\n      kb = Object.keys(b),\n      key, i;\n\n  if (ka.length !== kb.length) return false;\n\n  ka.sort();\n  kb.sort();\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) return false;\n  }\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!sceneEqual(a[key], b[key], key)) return false;\n  }\n\n  return typeof a === typeof b;\n}\n","import {resetSVGGradientId} from './src/Gradient';\nimport {resetSVGClipId} from './src/util/svg/clip';\n\nexport {default as Bounds} from './src/Bounds';\nexport {default as Gradient} from './src/Gradient';\nexport {default as GroupItem} from './src/GroupItem';\nexport {default as ResourceLoader} from './src/ResourceLoader';\nexport {default as Item} from './src/Item';\nexport {default as Scenegraph} from './src/Scenegraph';\n\nexport {default as Handler} from './src/Handler';\nexport {default as Renderer} from './src/Renderer';\nexport {default as CanvasHandler} from './src/CanvasHandler';\nexport {default as CanvasRenderer} from './src/CanvasRenderer';\nexport {default as SVGHandler} from './src/SVGHandler';\nexport {default as SVGRenderer} from './src/SVGRenderer';\nexport {default as SVGStringRenderer} from './src/SVGStringRenderer';\nexport {RenderType, renderModule} from './src/modules';\nexport {intersect} from './src/intersect';\n\nexport {default as Marks} from './src/marks/index';\n\nexport {default as boundClip} from './src/bound/boundClip';\nexport {default as boundContext} from './src/bound/boundContext';\nexport {default as boundStroke} from './src/bound/boundStroke';\nexport {default as boundItem} from './src/bound/boundItem';\nexport {default as boundMark} from './src/bound/boundMark';\n\nexport {default as pathCurves} from './src/path/curves';\nexport {default as pathSymbols} from './src/path/symbols';\nexport {default as pathRectangle} from './src/path/rectangle';\nexport {default as pathTrail} from './src/path/trail';\nexport {default as pathParse} from './src/path/parse';\nexport {default as pathRender} from './src/path/render';\n\nexport {default as point} from './src/util/point';\nexport {domCreate, domFind, domChild, domClear} from './src/util/dom';\nexport {markup, serializeXML} from './src/util/markup';\nexport {\n  font,\n  fontFamily,\n  fontSize,\n  lineHeight,\n  multiLineOffset,\n  textMetrics\n} from './src/util/text';\n\nexport {sceneEqual, pathEqual} from './src/util/equal';\nexport {sceneToJSON, sceneFromJSON} from './src/util/serialize';\nexport {\n  intersectPath,\n  intersectPoint,\n  intersectRule,\n  intersectBoxLine\n} from './src/util/intersect';\nexport {\n  zorder as sceneZOrder,\n  visit as sceneVisit,\n  pickVisit as scenePickVisit\n} from './src/util/visit';\n\n// deprecated, remove in next major version\nexport {resetSVGClipId} from './src/util/svg/clip';\n\nexport function resetSVGDefIds() {\n  resetSVGClipId();\n  resetSVGGradientId();\n}\n"],"names":["gradient_id","patternPrefix","isGradient","value","gradient","gradientRef","g","defs","base","type","id","prefix","x1","get","y1","r1","x2","y2","r2","val","def","pi","Math","PI","tau","epsilon","tauEpsilon","Path","_x0","this","_y0","_x1","_y1","_","path","x","prototype","constructor","moveTo","y","closePath","lineTo","quadraticCurveTo","bezierCurveTo","arcTo","r","x0","y0","x21","y21","x01","y01","l01_2","Error","abs","x20","y20","l21_2","l20_2","l21","sqrt","l01","l","tan","acos","t01","t21","arc","a0","a1","ccw","dx","cos","dy","sin","cw","da","rect","w","h","toString","atan2","max","min","halfPi","asin","arcInnerRadius","d","innerRadius","arcOuterRadius","outerRadius","arcStartAngle","startAngle","arcEndAngle","endAngle","arcPadAngle","padAngle","intersect","x3","y3","x10","y10","x32","y32","t","cornerTangents","rc","lo","ox","oy","x11","y11","x00","y00","d2","D","cx0","cy0","cx1","cy1","dx0","dy0","dx1","dy1","cx","cy","Array","from","Linear","context","_context","p","defined","constant","curve","curveLinear","output","line","data","i","buffer","n","array","length","defined0","lineStart","lineEnd","point","undefined","pointX","pointY","arguments","area","j","k","x0z","y0z","areaStart","areaEnd","arealine","lineX0","lineY0","lineY1","lineX1","_line","NaN","_point","draw","size","that","Basis","BasisClosed","BasisOpen","Bundle","beta","_basis","_beta","noop","_x2","_x3","_x4","_y2","_y3","_y4","_x","_y","push","custom","bundle","_k","Cardinal","tension","cardinal","CardinalClosed","_x5","_y5","CardinalOpen","_l01_a","a","_l01_2a","_l12_a","_l12_2a","_l23_a","b","_l23_2a","m","CatmullRom","alpha","_alpha","x23","y23","pow","catmullRom","CatmullRomClosed","CatmullRomOpen","LinearClosed","sign","slope3","h0","h1","s0","s1","slope2","t0","t1","MonotoneX","MonotoneY","ReflectContext","Natural","controlPoints","Step","_t","_t0","Object","create","call","px","py","i0","i1","lookup","curveBundle","curveCardinal","curveCardinalOpen","curveCardinalClosed","curveCatmullRom","curveCatmullRomClosed","curveCatmullRomOpen","horizontal","vertical","curves","orientation","entry","hasOwnProperty","cmdlen","v","c","s","q","regexp","pathstr","result","curr","chunks","parsed","param","cmd","len","slice","replace","split","trim","charAt","toLowerCase","concat","DegToRad","HalfPi","Tau","HalfSqrt3","segmentCache","bezierCache","join","bezier","params","key","th0","th1","rx","ry","sin_th","cos_th","a00","a01","a10","a11","cos_th0","sin_th0","cos_th1","sin_th1","th_half","sin_th_h2","temp","scale","current","sX","sY","tempX","tempY","tempControlX","tempControlY","previous","controlX","controlY","beginPath","match","drawArc","coords","seg","large","sweep","rotateX","th","pl","sfactor_sq","sfactor","xc","yc","th_arc","segs","ceil","th2","th3","segments","bez","Tan30","builtins","o","symbols","pathParse","pathRender","customSymbol","C","rectangleX","rectangleY","rectangleWidth","width","rectangleHeight","height","number","clamp","crTL","crTR","crBL","crBR","rectangle","tl","tr","bl","br","cornerRadius","ready","w2","ux","uy","ud","trail","item","arcShape","padRadius","r0","apply","da0","da1","ap","rp","rc0","rc1","p0","p1","oc","ax","ay","bx","by","kc","lc","centroid","d3_arc","areavShape","d3_area","areahShape","lineShape","d3_line","rectShape","vg_rect","cornerRadiusTopLeft","cornerRadiusTopRight","cornerRadiusBottomRight","cornerRadiusBottomLeft","symbolShape","symbol","circle","d3_symbol","shape","trailShape","vg_trail","hasCornerRadius","clip_id","resetSVGClipId","renderer","clip","_defs","clipping","isFunction","Bounds","clear","union","Item","mark","bounds","GroupItem","items","ResourceLoader","customLoader","_pending","_loader","loader","increment","decrement","miter","stroke","opacity","strokeOpacity","sw","strokeWidth","expand","strokeJoin","miterAdjustment","clone","Number","MAX_VALUE","empty","equals","set","add","round","floor","translate","rotate","angle","rotatedPoints","encloses","alignsWith","intersects","contains","pending","sanitizeURL","uri","sanitize","then","opt","catch","loadImage","Image","image","url","href","img","cors","crossOrigin","onload","onerror","src","e","complete","Promise","accept","poll","setTimeout","circleThreshold","lx","ly","rot","ma","mb","mc","md","addL","addX","addY","addp","addpL","deg","px1","py1","px2","py2","quadExtrema","px3","py3","cubicExtrema","sa","ea","update","cb","cubic","s2","t2","canvas","getContext","intersectPath","brush","isPointInPath","intersectPoint","box","intersectRect","intersectRule","intersectBoxLine","u","globalCompositeOperation","blend","dflt","addStops","stops","addColorStop","offset","color","spec","createRadialGradient","ictx","fillStyle","createLinearGradient","fillRect","createPattern","fillOpacity","globalAlpha","fill","Empty","lw","strokeStyle","lineWidth","lineCap","strokeCap","lineJoin","miterLimit","strokeMiterLimit","setLineDash","strokeDash","lineDashOffset","strokeDashOffset","compare","zindex","index","zorder","scene","zdirty","zitems","sort","visit","visitor","pickVisit","hit","drawAll","drawPath","drawOne","pick","test","truthy","gx","gy","pixelRatio","hitPath","filled","isArray","isPointInStroke","pickPath","translateItem","isect","tag","nested","attr","emit","rotateItem","bound","boundStroke","markItemPath","tip","markMultiItemPath","interp","interpolate","orient","z","Infinity","clipGroup","group","strokeOffset","emitRectangle","off","rectanglePath","hitBackground","hitForeground","hitCorner","noBound","fore","strokeForeground","save","restore","dw","dh","ix","interactive","marktype","pickMark","content","background","foreground","getImage","imageWidth","aspect","imageHeight","imageXOffset","align","imageYOffset","baseline","toDataURL","metadata","ar0","ar1","imageSmoothingEnabled","smooth","drawImage","xOffset","yOffset","sx","scaleX","sy","scaleY","cache","pathCache","transformItem","widthCache","lruCache","textMetrics","fontSize","measureWidth","estimateWidth","useCanvas","use","text","_estimateWidth","textValue","currentFontHeight","_measureWidth","font","currentFont","measureText","lineHeight","textLines","lineBreak","limit","widthGetter","mid","ellipsis","rtl","dir","hi","truncate","fontFamily","quote","String","fontStyle","fontVariant","fontWeight","textAlign","tempBounds","anchorPoint","radius","theta","mode","reduce","rule","lh","str","fillText","strokeText","func","marks","DUMMY","hasItems","boundItem","keys","sceneToJSON","indent","JSON","stringify","sceneFromJSON","json","initialize","parse","parent","boundMark","Scenegraph","root","createMark","name","role","aria","description","domCreate","doc","ns","document","createElement","createElementNS","domFind","el","nodes","childNodes","tagName","domChild","ownerDocument","insertBefore","domClear","removeChild","cssClass","event","getBoundingClientRect","clientX","left","clientLeft","clientY","top","clientTop","Handler","customTooltip","_active","_handlers","_tooltip","defaultTooltip","handler","element","setAttribute","Renderer","_el","_bgcolor","toJSON","markdef","origin","obj","_obj","firstChild","_origin","_scene","on","_handlerIndex","handlers","eventName","indexOf","handleHref","MouseEvent","dispatchEvent","handleTooltip","show","tooltip","mdef","resolveItem","getItemBoundingClientRect","right","bottom","scaleFactor","resize","bgcolor","_width","_height","_scale","dirty","render","_call","_render","renderAsync","_ready","resolve","_load","method","redraw","DragEnterEvent","DragLeaveEvent","DragOverEvent","MouseDownEvent","MouseMoveEvent","MouseOutEvent","MouseOverEvent","ClickEvent","MouseWheelEvent","TouchStartEvent","TouchMoveEvent","TouchEndEvent","Events","TooltipShowEvent","TooltipHideEvent","HrefEvent","CanvasHandler","_down","_touch","_first","_events","eventListenerCheck","eventBundle","forEach","addEventListener","evt","fire","move","moveEvent","overEvent","outEvent","pickEvent","exit","inactive","_canvas","events","DOMMouseScroll","mousemove","dragover","mouseout","dragleave","mousedown","click","touchstart","changedTouches","touchmove","touchend","touch","vegaType","splice","Marks","window","devicePixelRatio","CanvasRenderer","_options","_redraw","_dirty","_tempb","SVGHandler","_hrefHandler","listener","_tooltipHandler","options","externalContext","appendChild","inDOM","HTMLElement","parentNode","ratio","style","setTransform","ctx","error","db","vb","clipToBounds","clearRect","target","__data__","svg","_svg","removeEventListener","ARIA_HIDDEN","ARIA_LABEL","ARIA_ROLE","ARIA_ROLEDESCRIPTION","GRAPHICS_OBJECT","GRAPHICS_SYMBOL","roledesc","label","AriaIgnore","toSet","AriaGuides","desc","caption","datum","title","extractTitle","scales","locale","dataflow","isDiscrete","domainCaption","props","toUpperCase","map","peek","channelCaption","titleCaption","AriaEncode","ariaRole","ariaRoleDescription","ariaItemAttributes","hide","prop","ariaMarkAttributes","err","ariaGuide","recurse","some","ariaMark","innerText","markup","buf","outer","inner","stack","open","attrs","close","pop","serializeXML","node","_serialize","hasAttributes","attributes","hasChildNodes","children","child","nodeType","nodeValue","styles","rootAttributes","xmlns","svgns","SVGRenderer","_dirtyID","_root","dirtyParents","updateGradient","grad","stop","pt","setAttributes","viewBox","preserveAspectRatio","fx","fy","fr","updateClipping","mask","bind","sibling","__values__","bg","cg","fg","ownerSVGElement","previousSibling","siblingCheck","nextSibling","_clearDefs","setAttributeNS","RootIndex","setProperty","removeAttribute","_dirtyCheck","_dirtyAll","isDirty","_update","prev","isGroup","process","lastChild","idx","values","extra","mark_extras","setStyle","ts","textContent","removeAttributeNS","removeProperty","loc","location","hash","SVGStringRenderer","_text","extend","class","transform","attrList","_hrefs","object","prefixed","fn","display","Canvas","None","RenderType","PNG","SVG","modules","intersectMark","filter","hits","visitMark","intersectGroup","intersectItem","headless","clipBounds","sceneEqual","pathEqual","Date","isNumber","isObject","ka","kb","objectEqual","boundContext"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/vega-scenegraph/build/vega-scenegraph.module.js b/node_modules/vega-scenegraph/build/vega-scenegraph.module.js
deleted file mode 100644
index adff1b6..0000000
--- a/node_modules/vega-scenegraph/build/vega-scenegraph.module.js
+++ /dev/null
@@ -1,5176 +0,0 @@
-import { hasOwnProperty, isFunction, inherits, truthy, lruCache, isArray, error, toSet, array, peek, extend, isNumber, isObject } from 'vega-util';
-import { curveBasis, curveBasisClosed, curveBasisOpen, curveBundle, curveCardinal, curveCardinalOpen, curveCardinalClosed, curveCatmullRom, curveCatmullRomClosed, curveCatmullRomOpen, curveLinear, curveLinearClosed, curveMonotoneY, curveMonotoneX, curveNatural, curveStep, curveStepAfter, curveStepBefore, arc as arc$2, area as area$2, line as line$2, symbol as symbol$2 } from 'd3-shape';
-import { path as path$3 } from 'd3-path';
-import { image as image$1, canvas } from 'vega-canvas';
-import { loader } from 'vega-loader';
-import { isDiscrete, domainCaption } from 'vega-scale';
-
-let gradient_id = 0;
-function resetSVGGradientId() {
-  gradient_id = 0;
-}
-const patternPrefix = 'p_';
-function isGradient(value) {
-  return value && value.gradient;
-}
-function gradientRef(g, defs, base) {
-  const type = g.gradient;
-  let id = g.id,
-      prefix = type === 'radial' ? patternPrefix : ''; // check id, assign default values as needed
-
-  if (!id) {
-    id = g.id = 'gradient_' + gradient_id++;
-
-    if (type === 'radial') {
-      g.x1 = get(g.x1, 0.5);
-      g.y1 = get(g.y1, 0.5);
-      g.r1 = get(g.r1, 0);
-      g.x2 = get(g.x2, 0.5);
-      g.y2 = get(g.y2, 0.5);
-      g.r2 = get(g.r2, 0.5);
-      prefix = patternPrefix;
-    } else {
-      g.x1 = get(g.x1, 0);
-      g.y1 = get(g.y1, 0);
-      g.x2 = get(g.x2, 1);
-      g.y2 = get(g.y2, 0);
-    }
-  } // register definition
-
-
-  defs[id] = g; // return url reference
-
-  return 'url(' + (base || '') + '#' + prefix + id + ')';
-}
-
-function get(val, def) {
-  return val != null ? val : def;
-}
-
-function Gradient (p0, p1) {
-  var stops = [],
-      gradient;
-  return gradient = {
-    gradient: 'linear',
-    x1: p0 ? p0[0] : 0,
-    y1: p0 ? p0[1] : 0,
-    x2: p1 ? p1[0] : 1,
-    y2: p1 ? p1[1] : 0,
-    stops: stops,
-    stop: function (offset, color) {
-      stops.push({
-        offset: offset,
-        color: color
-      });
-      return gradient;
-    }
-  };
-}
-
-const lookup = {
-  'basis': {
-    curve: curveBasis
-  },
-  'basis-closed': {
-    curve: curveBasisClosed
-  },
-  'basis-open': {
-    curve: curveBasisOpen
-  },
-  'bundle': {
-    curve: curveBundle,
-    tension: 'beta',
-    value: 0.85
-  },
-  'cardinal': {
-    curve: curveCardinal,
-    tension: 'tension',
-    value: 0
-  },
-  'cardinal-open': {
-    curve: curveCardinalOpen,
-    tension: 'tension',
-    value: 0
-  },
-  'cardinal-closed': {
-    curve: curveCardinalClosed,
-    tension: 'tension',
-    value: 0
-  },
-  'catmull-rom': {
-    curve: curveCatmullRom,
-    tension: 'alpha',
-    value: 0.5
-  },
-  'catmull-rom-closed': {
-    curve: curveCatmullRomClosed,
-    tension: 'alpha',
-    value: 0.5
-  },
-  'catmull-rom-open': {
-    curve: curveCatmullRomOpen,
-    tension: 'alpha',
-    value: 0.5
-  },
-  'linear': {
-    curve: curveLinear
-  },
-  'linear-closed': {
-    curve: curveLinearClosed
-  },
-  'monotone': {
-    horizontal: curveMonotoneY,
-    vertical: curveMonotoneX
-  },
-  'natural': {
-    curve: curveNatural
-  },
-  'step': {
-    curve: curveStep
-  },
-  'step-after': {
-    curve: curveStepAfter
-  },
-  'step-before': {
-    curve: curveStepBefore
-  }
-};
-function curves(type, orientation, tension) {
-  var entry = hasOwnProperty(lookup, type) && lookup[type],
-      curve = null;
-
-  if (entry) {
-    curve = entry.curve || entry[orientation || 'vertical'];
-
-    if (entry.tension && tension != null) {
-      curve = curve[entry.tension](tension);
-    }
-  }
-
-  return curve;
-}
-
-// Path parsing and rendering code adapted from fabric.js -- Thanks!
-const cmdlen = {
-  m: 2,
-  l: 2,
-  h: 1,
-  v: 1,
-  c: 6,
-  s: 4,
-  q: 4,
-  t: 2,
-  a: 7
-},
-      regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\.\d+)(\.\d)/g, /(\d)([-+])/g, /\s|,|###/];
-function pathParse (pathstr) {
-  const result = [];
-  let curr, chunks, parsed, param, cmd, len, i, j, n, m; // First, break path into command sequence
-
-  const path = pathstr.slice().replace(regexp[0], '###$1').split(regexp[1]).slice(1); // Next, parse each command in turn
-
-  for (i = 0, n = path.length; i < n; ++i) {
-    curr = path[i];
-    chunks = curr.slice(1).trim().replace(regexp[2], '$1###$2').replace(regexp[3], '$1###$2').split(regexp[4]);
-    cmd = curr.charAt(0);
-    parsed = [cmd];
-
-    for (j = 0, m = chunks.length; j < m; ++j) {
-      if ((param = +chunks[j]) === param) {
-        // not NaN
-        parsed.push(param);
-      }
-    }
-
-    len = cmdlen[cmd.toLowerCase()];
-
-    if (parsed.length - 1 > len) {
-      const m = parsed.length;
-      j = 1;
-      result.push([cmd].concat(parsed.slice(j, j += len))); // handle implicit lineTo (#2803)
-
-      cmd = cmd === 'M' ? 'L' : cmd === 'm' ? 'l' : cmd;
-
-      for (; j < m; j += len) {
-        result.push([cmd].concat(parsed.slice(j, j + len)));
-      }
-    } else {
-      result.push(parsed);
-    }
-  }
-
-  return result;
-}
-
-const DegToRad = Math.PI / 180;
-const Epsilon = 1e-14;
-const HalfPi = Math.PI / 2;
-const Tau = Math.PI * 2;
-const HalfSqrt3 = Math.sqrt(3) / 2;
-
-var segmentCache = {};
-var bezierCache = {};
-var join = [].join; // Copied from Inkscape svgtopdf, thanks!
-
-function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
-  const key = join.call(arguments);
-
-  if (segmentCache[key]) {
-    return segmentCache[key];
-  }
-
-  const th = rotateX * DegToRad;
-  const sin_th = Math.sin(th);
-  const cos_th = Math.cos(th);
-  rx = Math.abs(rx);
-  ry = Math.abs(ry);
-  const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
-  const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
-  let pl = px * px / (rx * rx) + py * py / (ry * ry);
-
-  if (pl > 1) {
-    pl = Math.sqrt(pl);
-    rx *= pl;
-    ry *= pl;
-  }
-
-  const a00 = cos_th / rx;
-  const a01 = sin_th / rx;
-  const a10 = -sin_th / ry;
-  const a11 = cos_th / ry;
-  const x0 = a00 * ox + a01 * oy;
-  const y0 = a10 * ox + a11 * oy;
-  const x1 = a00 * x + a01 * y;
-  const y1 = a10 * x + a11 * y;
-  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
-  let sfactor_sq = 1 / d - 0.25;
-  if (sfactor_sq < 0) sfactor_sq = 0;
-  let sfactor = Math.sqrt(sfactor_sq);
-  if (sweep == large) sfactor = -sfactor;
-  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
-  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
-  const th0 = Math.atan2(y0 - yc, x0 - xc);
-  const th1 = Math.atan2(y1 - yc, x1 - xc);
-  let th_arc = th1 - th0;
-
-  if (th_arc < 0 && sweep === 1) {
-    th_arc += Tau;
-  } else if (th_arc > 0 && sweep === 0) {
-    th_arc -= Tau;
-  }
-
-  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));
-  const result = [];
-
-  for (let i = 0; i < segs; ++i) {
-    const th2 = th0 + i * th_arc / segs;
-    const th3 = th0 + (i + 1) * th_arc / segs;
-    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
-  }
-
-  return segmentCache[key] = result;
-}
-function bezier(params) {
-  const key = join.call(params);
-
-  if (bezierCache[key]) {
-    return bezierCache[key];
-  }
-
-  var cx = params[0],
-      cy = params[1],
-      th0 = params[2],
-      th1 = params[3],
-      rx = params[4],
-      ry = params[5],
-      sin_th = params[6],
-      cos_th = params[7];
-  const a00 = cos_th * rx;
-  const a01 = -sin_th * ry;
-  const a10 = sin_th * rx;
-  const a11 = cos_th * ry;
-  const cos_th0 = Math.cos(th0);
-  const sin_th0 = Math.sin(th0);
-  const cos_th1 = Math.cos(th1);
-  const sin_th1 = Math.sin(th1);
-  const th_half = 0.5 * (th1 - th0);
-  const sin_th_h2 = Math.sin(th_half * 0.5);
-  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
-  const x1 = cx + cos_th0 - t * sin_th0;
-  const y1 = cy + sin_th0 + t * cos_th0;
-  const x3 = cx + cos_th1;
-  const y3 = cy + sin_th1;
-  const x2 = x3 + t * sin_th1;
-  const y2 = y3 - t * cos_th1;
-  return bezierCache[key] = [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
-}
-
-const temp = ['l', 0, 0, 0, 0, 0, 0, 0];
-
-function scale$1(current, sX, sY) {
-  const c = temp[0] = current[0];
-
-  if (c === 'a' || c === 'A') {
-    temp[1] = sX * current[1];
-    temp[2] = sY * current[2];
-    temp[3] = current[3];
-    temp[4] = current[4];
-    temp[5] = current[5];
-    temp[6] = sX * current[6];
-    temp[7] = sY * current[7];
-  } else if (c === 'h' || c === 'H') {
-    temp[1] = sX * current[1];
-  } else if (c === 'v' || c === 'V') {
-    temp[1] = sY * current[1];
-  } else {
-    for (var i = 1, n = current.length; i < n; ++i) {
-      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
-    }
-  }
-
-  return temp;
-}
-
-function pathRender (context, path, l, t, sX, sY) {
-  var current,
-      // current instruction
-  previous = null,
-      x = 0,
-      // current x
-  y = 0,
-      // current y
-  controlX = 0,
-      // current control point x
-  controlY = 0,
-      // current control point y
-  tempX,
-      tempY,
-      tempControlX,
-      tempControlY;
-  if (l == null) l = 0;
-  if (t == null) t = 0;
-  if (sX == null) sX = 1;
-  if (sY == null) sY = sX;
-  if (context.beginPath) context.beginPath();
-
-  for (var i = 0, len = path.length; i < len; ++i) {
-    current = path[i];
-
-    if (sX !== 1 || sY !== 1) {
-      current = scale$1(current, sX, sY);
-    }
-
-    switch (current[0]) {
-      // first letter
-      case 'l':
-        // lineto, relative
-        x += current[1];
-        y += current[2];
-        context.lineTo(x + l, y + t);
-        break;
-
-      case 'L':
-        // lineto, absolute
-        x = current[1];
-        y = current[2];
-        context.lineTo(x + l, y + t);
-        break;
-
-      case 'h':
-        // horizontal lineto, relative
-        x += current[1];
-        context.lineTo(x + l, y + t);
-        break;
-
-      case 'H':
-        // horizontal lineto, absolute
-        x = current[1];
-        context.lineTo(x + l, y + t);
-        break;
-
-      case 'v':
-        // vertical lineto, relative
-        y += current[1];
-        context.lineTo(x + l, y + t);
-        break;
-
-      case 'V':
-        // verical lineto, absolute
-        y = current[1];
-        context.lineTo(x + l, y + t);
-        break;
-
-      case 'm':
-        // moveTo, relative
-        x += current[1];
-        y += current[2];
-        context.moveTo(x + l, y + t);
-        break;
-
-      case 'M':
-        // moveTo, absolute
-        x = current[1];
-        y = current[2];
-        context.moveTo(x + l, y + t);
-        break;
-
-      case 'c':
-        // bezierCurveTo, relative
-        tempX = x + current[5];
-        tempY = y + current[6];
-        controlX = x + current[3];
-        controlY = y + current[4];
-        context.bezierCurveTo(x + current[1] + l, // x1
-        y + current[2] + t, // y1
-        controlX + l, // x2
-        controlY + t, // y2
-        tempX + l, tempY + t);
-        x = tempX;
-        y = tempY;
-        break;
-
-      case 'C':
-        // bezierCurveTo, absolute
-        x = current[5];
-        y = current[6];
-        controlX = current[3];
-        controlY = current[4];
-        context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
-        break;
-
-      case 's':
-        // shorthand cubic bezierCurveTo, relative
-        // transform to absolute x,y
-        tempX = x + current[3];
-        tempY = y + current[4]; // calculate reflection of previous control points
-
-        controlX = 2 * x - controlX;
-        controlY = 2 * y - controlY;
-        context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t); // set control point to 2nd one of this command
-        // the first control point is assumed to be the reflection of
-        // the second control point on the previous command relative
-        // to the current point.
-
-        controlX = x + current[1];
-        controlY = y + current[2];
-        x = tempX;
-        y = tempY;
-        break;
-
-      case 'S':
-        // shorthand cubic bezierCurveTo, absolute
-        tempX = current[3];
-        tempY = current[4]; // calculate reflection of previous control points
-
-        controlX = 2 * x - controlX;
-        controlY = 2 * y - controlY;
-        context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);
-        x = tempX;
-        y = tempY; // set control point to 2nd one of this command
-        // the first control point is assumed to be the reflection of
-        // the second control point on the previous command relative
-        // to the current point.
-
-        controlX = current[1];
-        controlY = current[2];
-        break;
-
-      case 'q':
-        // quadraticCurveTo, relative
-        // transform to absolute x,y
-        tempX = x + current[3];
-        tempY = y + current[4];
-        controlX = x + current[1];
-        controlY = y + current[2];
-        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
-        x = tempX;
-        y = tempY;
-        break;
-
-      case 'Q':
-        // quadraticCurveTo, absolute
-        tempX = current[3];
-        tempY = current[4];
-        context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);
-        x = tempX;
-        y = tempY;
-        controlX = current[1];
-        controlY = current[2];
-        break;
-
-      case 't':
-        // shorthand quadraticCurveTo, relative
-        // transform to absolute x,y
-        tempX = x + current[1];
-        tempY = y + current[2];
-
-        if (previous[0].match(/[QqTt]/) === null) {
-          // If there is no previous command or if the previous command was not a Q, q, T or t,
-          // assume the control point is coincident with the current point
-          controlX = x;
-          controlY = y;
-        } else if (previous[0] === 't') {
-          // calculate reflection of previous control points for t
-          controlX = 2 * x - tempControlX;
-          controlY = 2 * y - tempControlY;
-        } else if (previous[0] === 'q') {
-          // calculate reflection of previous control points for q
-          controlX = 2 * x - controlX;
-          controlY = 2 * y - controlY;
-        }
-
-        tempControlX = controlX;
-        tempControlY = controlY;
-        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
-        x = tempX;
-        y = tempY;
-        controlX = x + current[1];
-        controlY = y + current[2];
-        break;
-
-      case 'T':
-        tempX = current[1];
-        tempY = current[2]; // calculate reflection of previous control points
-
-        controlX = 2 * x - controlX;
-        controlY = 2 * y - controlY;
-        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
-        x = tempX;
-        y = tempY;
-        break;
-
-      case 'a':
-        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);
-        x += current[6];
-        y += current[7];
-        break;
-
-      case 'A':
-        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);
-        x = current[6];
-        y = current[7];
-        break;
-
-      case 'z':
-      case 'Z':
-        context.closePath();
-        break;
-    }
-
-    previous = current;
-  }
-}
-
-function drawArc(context, x, y, coords) {
-  const seg = segments(coords[5], // end x
-  coords[6], // end y
-  coords[0], // radius x
-  coords[1], // radius y
-  coords[3], // large flag
-  coords[4], // sweep flag
-  coords[2], // rotation
-  x, y);
-
-  for (let i = 0; i < seg.length; ++i) {
-    const bez = bezier(seg[i]);
-    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
-  }
-}
-
-const Tan30 = 0.5773502691896257;
-const builtins = {
-  'circle': {
-    draw: function (context, size) {
-      const r = Math.sqrt(size) / 2;
-      context.moveTo(r, 0);
-      context.arc(0, 0, r, 0, Tau);
-    }
-  },
-  'cross': {
-    draw: function (context, size) {
-      var r = Math.sqrt(size) / 2,
-          s = r / 2.5;
-      context.moveTo(-r, -s);
-      context.lineTo(-r, s);
-      context.lineTo(-s, s);
-      context.lineTo(-s, r);
-      context.lineTo(s, r);
-      context.lineTo(s, s);
-      context.lineTo(r, s);
-      context.lineTo(r, -s);
-      context.lineTo(s, -s);
-      context.lineTo(s, -r);
-      context.lineTo(-s, -r);
-      context.lineTo(-s, -s);
-      context.closePath();
-    }
-  },
-  'diamond': {
-    draw: function (context, size) {
-      const r = Math.sqrt(size) / 2;
-      context.moveTo(-r, 0);
-      context.lineTo(0, -r);
-      context.lineTo(r, 0);
-      context.lineTo(0, r);
-      context.closePath();
-    }
-  },
-  'square': {
-    draw: function (context, size) {
-      var w = Math.sqrt(size),
-          x = -w / 2;
-      context.rect(x, x, w, w);
-    }
-  },
-  'arrow': {
-    draw: function (context, size) {
-      var r = Math.sqrt(size) / 2,
-          s = r / 7,
-          t = r / 2.5,
-          v = r / 8;
-      context.moveTo(-s, r);
-      context.lineTo(s, r);
-      context.lineTo(s, -v);
-      context.lineTo(t, -v);
-      context.lineTo(0, -r);
-      context.lineTo(-t, -v);
-      context.lineTo(-s, -v);
-      context.closePath();
-    }
-  },
-  'wedge': {
-    draw: function (context, size) {
-      var r = Math.sqrt(size) / 2,
-          h = HalfSqrt3 * r,
-          o = h - r * Tan30,
-          b = r / 4;
-      context.moveTo(0, -h - o);
-      context.lineTo(-b, h - o);
-      context.lineTo(b, h - o);
-      context.closePath();
-    }
-  },
-  'triangle': {
-    draw: function (context, size) {
-      var r = Math.sqrt(size) / 2,
-          h = HalfSqrt3 * r,
-          o = h - r * Tan30;
-      context.moveTo(0, -h - o);
-      context.lineTo(-r, h - o);
-      context.lineTo(r, h - o);
-      context.closePath();
-    }
-  },
-  'triangle-up': {
-    draw: function (context, size) {
-      var r = Math.sqrt(size) / 2,
-          h = HalfSqrt3 * r;
-      context.moveTo(0, -h);
-      context.lineTo(-r, h);
-      context.lineTo(r, h);
-      context.closePath();
-    }
-  },
-  'triangle-down': {
-    draw: function (context, size) {
-      var r = Math.sqrt(size) / 2,
-          h = HalfSqrt3 * r;
-      context.moveTo(0, h);
-      context.lineTo(-r, -h);
-      context.lineTo(r, -h);
-      context.closePath();
-    }
-  },
-  'triangle-right': {
-    draw: function (context, size) {
-      var r = Math.sqrt(size) / 2,
-          h = HalfSqrt3 * r;
-      context.moveTo(h, 0);
-      context.lineTo(-h, -r);
-      context.lineTo(-h, r);
-      context.closePath();
-    }
-  },
-  'triangle-left': {
-    draw: function (context, size) {
-      var r = Math.sqrt(size) / 2,
-          h = HalfSqrt3 * r;
-      context.moveTo(-h, 0);
-      context.lineTo(h, -r);
-      context.lineTo(h, r);
-      context.closePath();
-    }
-  },
-  'stroke': {
-    draw: function (context, size) {
-      const r = Math.sqrt(size) / 2;
-      context.moveTo(-r, 0);
-      context.lineTo(r, 0);
-    }
-  }
-};
-function symbols(_) {
-  return hasOwnProperty(builtins, _) ? builtins[_] : customSymbol(_);
-}
-var custom = {};
-
-function customSymbol(path) {
-  if (!hasOwnProperty(custom, path)) {
-    const parsed = pathParse(path);
-    custom[path] = {
-      draw: function (context, size) {
-        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);
-      }
-    };
-  }
-
-  return custom[path];
-}
-
-const C = 0.448084975506; // C = 1 - c
-
-function rectangleX(d) {
-  return d.x;
-}
-
-function rectangleY(d) {
-  return d.y;
-}
-
-function rectangleWidth(d) {
-  return d.width;
-}
-
-function rectangleHeight(d) {
-  return d.height;
-}
-
-function number(_) {
-  return typeof _ === 'function' ? _ : () => +_;
-}
-
-function clamp(value, min, max) {
-  return Math.max(min, Math.min(value, max));
-}
-
-function vg_rect () {
-  var x = rectangleX,
-      y = rectangleY,
-      width = rectangleWidth,
-      height = rectangleHeight,
-      crTL = number(0),
-      crTR = crTL,
-      crBL = crTL,
-      crBR = crTL,
-      context = null;
-
-  function rectangle(_, x0, y0) {
-    var buffer,
-        x1 = x0 != null ? x0 : +x.call(this, _),
-        y1 = y0 != null ? y0 : +y.call(this, _),
-        w = +width.call(this, _),
-        h = +height.call(this, _),
-        s = Math.min(w, h) / 2,
-        tl = clamp(+crTL.call(this, _), 0, s),
-        tr = clamp(+crTR.call(this, _), 0, s),
-        bl = clamp(+crBL.call(this, _), 0, s),
-        br = clamp(+crBR.call(this, _), 0, s);
-    if (!context) context = buffer = path$3();
-
-    if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {
-      context.rect(x1, y1, w, h);
-    } else {
-      var x2 = x1 + w,
-          y2 = y1 + h;
-      context.moveTo(x1 + tl, y1);
-      context.lineTo(x2 - tr, y1);
-      context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);
-      context.lineTo(x2, y2 - br);
-      context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);
-      context.lineTo(x1 + bl, y2);
-      context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);
-      context.lineTo(x1, y1 + tl);
-      context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);
-      context.closePath();
-    }
-
-    if (buffer) {
-      context = null;
-      return buffer + '' || null;
-    }
-  }
-
-  rectangle.x = function (_) {
-    if (arguments.length) {
-      x = number(_);
-      return rectangle;
-    } else {
-      return x;
-    }
-  };
-
-  rectangle.y = function (_) {
-    if (arguments.length) {
-      y = number(_);
-      return rectangle;
-    } else {
-      return y;
-    }
-  };
-
-  rectangle.width = function (_) {
-    if (arguments.length) {
-      width = number(_);
-      return rectangle;
-    } else {
-      return width;
-    }
-  };
-
-  rectangle.height = function (_) {
-    if (arguments.length) {
-      height = number(_);
-      return rectangle;
-    } else {
-      return height;
-    }
-  };
-
-  rectangle.cornerRadius = function (tl, tr, br, bl) {
-    if (arguments.length) {
-      crTL = number(tl);
-      crTR = tr != null ? number(tr) : crTL;
-      crBR = br != null ? number(br) : crTL;
-      crBL = bl != null ? number(bl) : crTR;
-      return rectangle;
-    } else {
-      return crTL;
-    }
-  };
-
-  rectangle.context = function (_) {
-    if (arguments.length) {
-      context = _ == null ? null : _;
-      return rectangle;
-    } else {
-      return context;
-    }
-  };
-
-  return rectangle;
-}
-
-function vg_trail () {
-  var x,
-      y,
-      size,
-      defined,
-      context = null,
-      ready,
-      x1,
-      y1,
-      r1;
-
-  function point(x2, y2, w2) {
-    const r2 = w2 / 2;
-
-    if (ready) {
-      var ux = y1 - y2,
-          uy = x2 - x1;
-
-      if (ux || uy) {
-        // get normal vector
-        var ud = Math.sqrt(ux * ux + uy * uy),
-            rx = (ux /= ud) * r1,
-            ry = (uy /= ud) * r1,
-            t = Math.atan2(uy, ux); // draw segment
-
-        context.moveTo(x1 - rx, y1 - ry);
-        context.lineTo(x2 - ux * r2, y2 - uy * r2);
-        context.arc(x2, y2, r2, t - Math.PI, t);
-        context.lineTo(x1 + rx, y1 + ry);
-        context.arc(x1, y1, r1, t, t + Math.PI);
-      } else {
-        context.arc(x2, y2, r2, 0, Tau);
-      }
-
-      context.closePath();
-    } else {
-      ready = 1;
-    }
-
-    x1 = x2;
-    y1 = y2;
-    r1 = r2;
-  }
-
-  function trail(data) {
-    var i,
-        n = data.length,
-        d,
-        defined0 = false,
-        buffer;
-    if (context == null) context = buffer = path$3();
-
-    for (i = 0; i <= n; ++i) {
-      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
-        if (defined0 = !defined0) ready = 0;
-      }
-
-      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));
-    }
-
-    if (buffer) {
-      context = null;
-      return buffer + '' || null;
-    }
-  }
-
-  trail.x = function (_) {
-    if (arguments.length) {
-      x = _;
-      return trail;
-    } else {
-      return x;
-    }
-  };
-
-  trail.y = function (_) {
-    if (arguments.length) {
-      y = _;
-      return trail;
-    } else {
-      return y;
-    }
-  };
-
-  trail.size = function (_) {
-    if (arguments.length) {
-      size = _;
-      return trail;
-    } else {
-      return size;
-    }
-  };
-
-  trail.defined = function (_) {
-    if (arguments.length) {
-      defined = _;
-      return trail;
-    } else {
-      return defined;
-    }
-  };
-
-  trail.context = function (_) {
-    if (arguments.length) {
-      if (_ == null) {
-        context = null;
-      } else {
-        context = _;
-      }
-
-      return trail;
-    } else {
-      return context;
-    }
-  };
-
-  return trail;
-}
-
-function value$1(a, b) {
-  return a != null ? a : b;
-}
-
-const x = item => item.x || 0,
-      y = item => item.y || 0,
-      w = item => item.width || 0,
-      h = item => item.height || 0,
-      xw = item => (item.x || 0) + (item.width || 0),
-      yh = item => (item.y || 0) + (item.height || 0),
-      sa = item => item.startAngle || 0,
-      ea = item => item.endAngle || 0,
-      pa = item => item.padAngle || 0,
-      ir = item => item.innerRadius || 0,
-      or = item => item.outerRadius || 0,
-      cr = item => item.cornerRadius || 0,
-      tl = item => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0,
-      tr = item => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0,
-      br = item => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0,
-      bl = item => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,
-      sz = item => value$1(item.size, 64),
-      ts = item => item.size || 1,
-      def = item => !(item.defined === false),
-      type = item => symbols(item.shape || 'circle');
-
-const arcShape = arc$2().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),
-      areavShape = area$2().x(x).y1(y).y0(yh).defined(def),
-      areahShape = area$2().y(y).x1(x).x0(xw).defined(def),
-      lineShape = line$2().x(x).y(y).defined(def),
-      rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl),
-      symbolShape = symbol$2().type(type).size(sz),
-      trailShape = vg_trail().x(x).y(y).defined(def).size(ts);
-function hasCornerRadius(item) {
-  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
-}
-function arc$1(context, item) {
-  return arcShape.context(context)(item);
-}
-function area$1(context, items) {
-  const item = items[0],
-        interp = item.interpolate || 'linear';
-  return (item.orient === 'horizontal' ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context)(items);
-}
-function line$1(context, items) {
-  const item = items[0],
-        interp = item.interpolate || 'linear';
-  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context)(items);
-}
-function rectangle(context, item, x, y) {
-  return rectShape.context(context)(item, x, y);
-}
-function shape$1(context, item) {
-  return (item.mark.shape || item.shape).context(context)(item);
-}
-function symbol$1(context, item) {
-  return symbolShape.context(context)(item);
-}
-function trail$1(context, items) {
-  return trailShape.context(context)(items);
-}
-
-var clip_id = 1;
-function resetSVGClipId() {
-  clip_id = 1;
-}
-function clip$1 (renderer, item, size) {
-  var clip = item.clip,
-      defs = renderer._defs,
-      id = item.clip_id || (item.clip_id = 'clip' + clip_id++),
-      c = defs.clipping[id] || (defs.clipping[id] = {
-    id: id
-  });
-
-  if (isFunction(clip)) {
-    c.path = clip(null);
-  } else if (hasCornerRadius(size)) {
-    c.path = rectangle(null, size, 0, 0);
-  } else {
-    c.width = size.width || 0;
-    c.height = size.height || 0;
-  }
-
-  return 'url(#' + id + ')';
-}
-
-function Bounds(b) {
-  this.clear();
-  if (b) this.union(b);
-}
-Bounds.prototype = {
-  clone() {
-    return new Bounds(this);
-  },
-
-  clear() {
-    this.x1 = +Number.MAX_VALUE;
-    this.y1 = +Number.MAX_VALUE;
-    this.x2 = -Number.MAX_VALUE;
-    this.y2 = -Number.MAX_VALUE;
-    return this;
-  },
-
-  empty() {
-    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
-  },
-
-  equals(b) {
-    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
-  },
-
-  set(x1, y1, x2, y2) {
-    if (x2 < x1) {
-      this.x2 = x1;
-      this.x1 = x2;
-    } else {
-      this.x1 = x1;
-      this.x2 = x2;
-    }
-
-    if (y2 < y1) {
-      this.y2 = y1;
-      this.y1 = y2;
-    } else {
-      this.y1 = y1;
-      this.y2 = y2;
-    }
-
-    return this;
-  },
-
-  add(x, y) {
-    if (x < this.x1) this.x1 = x;
-    if (y < this.y1) this.y1 = y;
-    if (x > this.x2) this.x2 = x;
-    if (y > this.y2) this.y2 = y;
-    return this;
-  },
-
-  expand(d) {
-    this.x1 -= d;
-    this.y1 -= d;
-    this.x2 += d;
-    this.y2 += d;
-    return this;
-  },
-
-  round() {
-    this.x1 = Math.floor(this.x1);
-    this.y1 = Math.floor(this.y1);
-    this.x2 = Math.ceil(this.x2);
-    this.y2 = Math.ceil(this.y2);
-    return this;
-  },
-
-  scale(s) {
-    this.x1 *= s;
-    this.y1 *= s;
-    this.x2 *= s;
-    this.y2 *= s;
-    return this;
-  },
-
-  translate(dx, dy) {
-    this.x1 += dx;
-    this.x2 += dx;
-    this.y1 += dy;
-    this.y2 += dy;
-    return this;
-  },
-
-  rotate(angle, x, y) {
-    const p = this.rotatedPoints(angle, x, y);
-    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
-  },
-
-  rotatedPoints(angle, x, y) {
-    var {
-      x1,
-      y1,
-      x2,
-      y2
-    } = this,
-        cos = Math.cos(angle),
-        sin = Math.sin(angle),
-        cx = x - x * cos + y * sin,
-        cy = y - x * sin - y * cos;
-    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];
-  },
-
-  union(b) {
-    if (b.x1 < this.x1) this.x1 = b.x1;
-    if (b.y1 < this.y1) this.y1 = b.y1;
-    if (b.x2 > this.x2) this.x2 = b.x2;
-    if (b.y2 > this.y2) this.y2 = b.y2;
-    return this;
-  },
-
-  intersect(b) {
-    if (b.x1 > this.x1) this.x1 = b.x1;
-    if (b.y1 > this.y1) this.y1 = b.y1;
-    if (b.x2 < this.x2) this.x2 = b.x2;
-    if (b.y2 < this.y2) this.y2 = b.y2;
-    return this;
-  },
-
-  encloses(b) {
-    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
-  },
-
-  alignsWith(b) {
-    return b && (this.x1 == b.x1 || this.x2 == b.x2 || this.y1 == b.y1 || this.y2 == b.y2);
-  },
-
-  intersects(b) {
-    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
-  },
-
-  contains(x, y) {
-    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
-  },
-
-  width() {
-    return this.x2 - this.x1;
-  },
-
-  height() {
-    return this.y2 - this.y1;
-  }
-
-};
-
-function Item(mark) {
-  this.mark = mark;
-  this.bounds = this.bounds || new Bounds();
-}
-
-function GroupItem(mark) {
-  Item.call(this, mark);
-  this.items = this.items || [];
-}
-inherits(GroupItem, Item);
-
-function ResourceLoader(customLoader) {
-  this._pending = 0;
-  this._loader = customLoader || loader();
-}
-
-function increment(loader) {
-  loader._pending += 1;
-}
-
-function decrement(loader) {
-  loader._pending -= 1;
-}
-
-ResourceLoader.prototype = {
-  pending() {
-    return this._pending;
-  },
-
-  sanitizeURL(uri) {
-    const loader = this;
-    increment(loader);
-    return loader._loader.sanitize(uri, {
-      context: 'href'
-    }).then(opt => {
-      decrement(loader);
-      return opt;
-    }).catch(() => {
-      decrement(loader);
-      return null;
-    });
-  },
-
-  loadImage(uri) {
-    const loader = this,
-          Image = image$1();
-    increment(loader);
-    return loader._loader.sanitize(uri, {
-      context: 'image'
-    }).then(opt => {
-      const url = opt.href;
-      if (!url || !Image) throw {
-        url: url
-      };
-      const img = new Image(); // set crossOrigin only if cors is defined; empty string sets anonymous mode
-      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin
-
-      const cors = hasOwnProperty(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';
-      if (cors != null) img.crossOrigin = cors; // attempt to load image resource
-
-      img.onload = () => decrement(loader);
-
-      img.onerror = () => decrement(loader);
-
-      img.src = url;
-      return img;
-    }).catch(e => {
-      decrement(loader);
-      return {
-        complete: false,
-        width: 0,
-        height: 0,
-        src: e && e.url || ''
-      };
-    });
-  },
-
-  ready() {
-    const loader = this;
-    return new Promise(accept => {
-      function poll(value) {
-        if (!loader.pending()) accept(value);else setTimeout(() => {
-          poll(true);
-        }, 10);
-      }
-
-      poll(false);
-    });
-  }
-
-};
-
-function boundStroke (bounds, item, miter) {
-  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
-    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
-    bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
-  }
-
-  return bounds;
-}
-
-function miterAdjustment(item, strokeWidth) {
-  // TODO: more sophisticated adjustment? Or miter support in boundContext?
-  return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;
-}
-
-const circleThreshold = Tau - 1e-8;
-let bounds, lx, ly, rot, ma, mb, mc, md;
-
-const add = (x, y) => bounds.add(x, y);
-
-const addL = (x, y) => add(lx = x, ly = y);
-
-const addX = x => add(x, bounds.y1);
-
-const addY = y => add(bounds.x1, y);
-
-const px = (x, y) => ma * x + mc * y;
-
-const py = (x, y) => mb * x + md * y;
-
-const addp = (x, y) => add(px(x, y), py(x, y));
-
-const addpL = (x, y) => addL(px(x, y), py(x, y));
-
-function boundContext (_, deg) {
-  bounds = _;
-
-  if (deg) {
-    rot = deg * DegToRad;
-    ma = md = Math.cos(rot);
-    mb = Math.sin(rot);
-    mc = -mb;
-  } else {
-    ma = md = 1;
-    rot = mb = mc = 0;
-  }
-
-  return context$1;
-}
-const context$1 = {
-  beginPath() {},
-
-  closePath() {},
-
-  moveTo: addpL,
-  lineTo: addpL,
-
-  rect(x, y, w, h) {
-    if (rot) {
-      addp(x + w, y);
-      addp(x + w, y + h);
-      addp(x, y + h);
-      addpL(x, y);
-    } else {
-      add(x + w, y + h);
-      addL(x, y);
-    }
-  },
-
-  quadraticCurveTo(x1, y1, x2, y2) {
-    const px1 = px(x1, y1),
-          py1 = py(x1, y1),
-          px2 = px(x2, y2),
-          py2 = py(x2, y2);
-    quadExtrema(lx, px1, px2, addX);
-    quadExtrema(ly, py1, py2, addY);
-    addL(px2, py2);
-  },
-
-  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
-    const px1 = px(x1, y1),
-          py1 = py(x1, y1),
-          px2 = px(x2, y2),
-          py2 = py(x2, y2),
-          px3 = px(x3, y3),
-          py3 = py(x3, y3);
-    cubicExtrema(lx, px1, px2, px3, addX);
-    cubicExtrema(ly, py1, py2, py3, addY);
-    addL(px3, py3);
-  },
-
-  arc(cx, cy, r, sa, ea, ccw) {
-    sa += rot;
-    ea += rot; // store last point on path
-
-    lx = r * Math.cos(ea) + cx;
-    ly = r * Math.sin(ea) + cy;
-
-    if (Math.abs(ea - sa) > circleThreshold) {
-      // treat as full circle
-      add(cx - r, cy - r);
-      add(cx + r, cy + r);
-    } else {
-      const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);
-
-      let s, i; // sample end points
-
-      update(sa);
-      update(ea); // sample interior points aligned with 90 degrees
-
-      if (ea !== sa) {
-        sa = sa % Tau;
-        if (sa < 0) sa += Tau;
-        ea = ea % Tau;
-        if (ea < 0) ea += Tau;
-
-        if (ea < sa) {
-          ccw = !ccw; // flip direction
-
-          s = sa;
-          sa = ea;
-          ea = s; // swap end-points
-        }
-
-        if (ccw) {
-          ea -= Tau;
-          s = sa - sa % HalfPi;
-
-          for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) update(s);
-        } else {
-          s = sa - sa % HalfPi + HalfPi;
-
-          for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) update(s);
-        }
-      }
-    }
-  }
-
-};
-
-function quadExtrema(x0, x1, x2, cb) {
-  const t = (x0 - x1) / (x0 + x2 - 2 * x1);
-  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);
-}
-
-function cubicExtrema(x0, x1, x2, x3, cb) {
-  const a = x3 - x0 + 3 * x1 - 3 * x2,
-        b = x0 + x2 - 2 * x1,
-        c = x0 - x1;
-  let t0 = 0,
-      t1 = 0,
-      r; // solve for parameter t
-
-  if (Math.abs(a) > Epsilon) {
-    // quadratic equation
-    r = b * b + c * a;
-
-    if (r >= 0) {
-      r = Math.sqrt(r);
-      t0 = (-b + r) / a;
-      t1 = (-b - r) / a;
-    }
-  } else {
-    // linear equation
-    t0 = 0.5 * c / b;
-  } // calculate position
-
-
-  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));
-  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));
-}
-
-function cubic(t, x0, x1, x2, x3) {
-  const s = 1 - t,
-        s2 = s * s,
-        t2 = t * t;
-  return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;
-}
-
-var context = (context = canvas(1, 1)) ? context.getContext('2d') : null;
-
-const b = new Bounds();
-function intersectPath(draw) {
-  return function (item, brush) {
-    // rely on (inaccurate) bounds intersection if no context
-    if (!context) return true; // add path to offscreen graphics context
-
-    draw(context, item); // get bounds intersection region
-
-    b.clear().union(item.bounds).intersect(brush).round();
-    const {
-      x1,
-      y1,
-      x2,
-      y2
-    } = b; // iterate over intersection region
-    // perform fine grained inclusion test
-
-    for (let y = y1; y <= y2; ++y) {
-      for (let x = x1; x <= x2; ++x) {
-        if (context.isPointInPath(x, y)) {
-          return true;
-        }
-      }
-    } // false if no hits in intersection region
-
-
-    return false;
-  };
-}
-function intersectPoint(item, box) {
-  return box.contains(item.x || 0, item.y || 0);
-}
-function intersectRect(item, box) {
-  const x = item.x || 0,
-        y = item.y || 0,
-        w = item.width || 0,
-        h = item.height || 0;
-  return box.intersects(b.set(x, y, x + w, y + h));
-}
-function intersectRule(item, box) {
-  const x = item.x || 0,
-        y = item.y || 0,
-        x2 = item.x2 != null ? item.x2 : x,
-        y2 = item.y2 != null ? item.y2 : y;
-  return intersectBoxLine(box, x, y, x2, y2);
-}
-function intersectBoxLine(box, x, y, u, v) {
-  const {
-    x1,
-    y1,
-    x2,
-    y2
-  } = box,
-        dx = u - x,
-        dy = v - y;
-  let t0 = 0,
-      t1 = 1,
-      p,
-      q,
-      r,
-      e;
-
-  for (e = 0; e < 4; ++e) {
-    if (e === 0) {
-      p = -dx;
-      q = -(x1 - x);
-    }
-
-    if (e === 1) {
-      p = dx;
-      q = x2 - x;
-    }
-
-    if (e === 2) {
-      p = -dy;
-      q = -(y1 - y);
-    }
-
-    if (e === 3) {
-      p = dy;
-      q = y2 - y;
-    }
-
-    if (Math.abs(p) < 1e-10 && q < 0) return false;
-    r = q / p;
-
-    if (p < 0) {
-      if (r > t1) return false;else if (r > t0) t0 = r;
-    } else if (p > 0) {
-      if (r < t0) return false;else if (r < t1) t1 = r;
-    }
-  }
-
-  return true;
-}
-
-function blend (context, item) {
-  context.globalCompositeOperation = item.blend || 'source-over';
-}
-
-function value (value, dflt) {
-  return value == null ? dflt : value;
-}
-
-function addStops(gradient, stops) {
-  const n = stops.length;
-
-  for (let i = 0; i < n; ++i) {
-    gradient.addColorStop(stops[i].offset, stops[i].color);
-  }
-
-  return gradient;
-}
-
-function gradient (context, spec, bounds) {
-  const w = bounds.width(),
-        h = bounds.height();
-  let gradient;
-
-  if (spec.gradient === 'radial') {
-    gradient = context.createRadialGradient(bounds.x1 + value(spec.x1, 0.5) * w, bounds.y1 + value(spec.y1, 0.5) * h, Math.max(w, h) * value(spec.r1, 0), bounds.x1 + value(spec.x2, 0.5) * w, bounds.y1 + value(spec.y2, 0.5) * h, Math.max(w, h) * value(spec.r2, 0.5));
-  } else {
-    // linear gradient
-    const x1 = value(spec.x1, 0),
-          y1 = value(spec.y1, 0),
-          x2 = value(spec.x2, 1),
-          y2 = value(spec.y2, 0);
-
-    if (x1 === x2 || y1 === y2 || w === h) {
-      // axis aligned: use normal gradient
-      gradient = context.createLinearGradient(bounds.x1 + x1 * w, bounds.y1 + y1 * h, bounds.x1 + x2 * w, bounds.y1 + y2 * h);
-    } else {
-      // not axis aligned: render gradient into a pattern (#2365)
-      // this allows us to use normalized bounding box coordinates
-      const image = canvas(Math.ceil(w), Math.ceil(h)),
-            ictx = image.getContext('2d');
-      ictx.scale(w, h);
-      ictx.fillStyle = addStops(ictx.createLinearGradient(x1, y1, x2, y2), spec.stops);
-      ictx.fillRect(0, 0, w, h);
-      return context.createPattern(image, 'no-repeat');
-    }
-  }
-
-  return addStops(gradient, spec.stops);
-}
-
-function color (context, item, value) {
-  return isGradient(value) ? gradient(context, value, item.bounds) : value;
-}
-
-function fill (context, item, opacity) {
-  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;
-
-  if (opacity > 0) {
-    context.globalAlpha = opacity;
-    context.fillStyle = color(context, item, item.fill);
-    return true;
-  } else {
-    return false;
-  }
-}
-
-var Empty = [];
-function stroke (context, item, opacity) {
-  var lw = (lw = item.strokeWidth) != null ? lw : 1;
-  if (lw <= 0) return false;
-  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
-
-  if (opacity > 0) {
-    context.globalAlpha = opacity;
-    context.strokeStyle = color(context, item, item.stroke);
-    context.lineWidth = lw;
-    context.lineCap = item.strokeCap || 'butt';
-    context.lineJoin = item.strokeJoin || 'miter';
-    context.miterLimit = item.strokeMiterLimit || 10;
-
-    if (context.setLineDash) {
-      context.setLineDash(item.strokeDash || Empty);
-      context.lineDashOffset = item.strokeDashOffset || 0;
-    }
-
-    return true;
-  } else {
-    return false;
-  }
-}
-
-function compare(a, b) {
-  return a.zindex - b.zindex || a.index - b.index;
-}
-
-function zorder(scene) {
-  if (!scene.zdirty) return scene.zitems;
-  var items = scene.items,
-      output = [],
-      item,
-      i,
-      n;
-
-  for (i = 0, n = items.length; i < n; ++i) {
-    item = items[i];
-    item.index = i;
-    if (item.zindex) output.push(item);
-  }
-
-  scene.zdirty = false;
-  return scene.zitems = output.sort(compare);
-}
-function visit(scene, visitor) {
-  var items = scene.items,
-      i,
-      n;
-  if (!items || !items.length) return;
-  const zitems = zorder(scene);
-
-  if (zitems && zitems.length) {
-    for (i = 0, n = items.length; i < n; ++i) {
-      if (!items[i].zindex) visitor(items[i]);
-    }
-
-    items = zitems;
-  }
-
-  for (i = 0, n = items.length; i < n; ++i) {
-    visitor(items[i]);
-  }
-}
-function pickVisit(scene, visitor) {
-  var items = scene.items,
-      hit,
-      i;
-  if (!items || !items.length) return null;
-  const zitems = zorder(scene);
-  if (zitems && zitems.length) items = zitems;
-
-  for (i = items.length; --i >= 0;) {
-    if (hit = visitor(items[i])) return hit;
-  }
-
-  if (items === zitems) {
-    for (items = scene.items, i = items.length; --i >= 0;) {
-      if (!items[i].zindex) {
-        if (hit = visitor(items[i])) return hit;
-      }
-    }
-  }
-
-  return null;
-}
-
-function drawAll(path) {
-  return function (context, scene, bounds) {
-    visit(scene, item => {
-      if (!bounds || bounds.intersects(item.bounds)) {
-        drawPath(path, context, item, item);
-      }
-    });
-  };
-}
-function drawOne(path) {
-  return function (context, scene, bounds) {
-    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {
-      drawPath(path, context, scene.items[0], scene.items);
-    }
-  };
-}
-
-function drawPath(path, context, item, items) {
-  var opacity = item.opacity == null ? 1 : item.opacity;
-  if (opacity === 0) return;
-  if (path(context, items)) return;
-  blend(context, item);
-
-  if (item.fill && fill(context, item, opacity)) {
-    context.fill();
-  }
-
-  if (item.stroke && stroke(context, item, opacity)) {
-    context.stroke();
-  }
-}
-
-function pick$1(test) {
-  test = test || truthy;
-  return function (context, scene, x, y, gx, gy) {
-    x *= context.pixelRatio;
-    y *= context.pixelRatio;
-    return pickVisit(scene, item => {
-      const b = item.bounds; // first hit test against bounding box
-
-      if (b && !b.contains(gx, gy) || !b) return; // if in bounding box, perform more careful test
-
-      if (test(context, item, x, y, gx, gy)) return item;
-    });
-  };
-}
-function hitPath(path, filled) {
-  return function (context, o, x, y) {
-    var item = Array.isArray(o) ? o[0] : o,
-        fill = filled == null ? item.fill : filled,
-        stroke = item.stroke && context.isPointInStroke,
-        lw,
-        lc;
-
-    if (stroke) {
-      lw = item.strokeWidth;
-      lc = item.strokeCap;
-      context.lineWidth = lw != null ? lw : 1;
-      context.lineCap = lc != null ? lc : 'butt';
-    }
-
-    return path(context, o) ? false : fill && context.isPointInPath(x, y) || stroke && context.isPointInStroke(x, y);
-  };
-}
-function pickPath(path) {
-  return pick$1(hitPath(path));
-}
-
-function translate(x, y) {
-  return 'translate(' + x + ',' + y + ')';
-}
-function rotate(a) {
-  return 'rotate(' + a + ')';
-}
-function scale(scaleX, scaleY) {
-  return 'scale(' + scaleX + ',' + scaleY + ')';
-}
-function translateItem(item) {
-  return translate(item.x || 0, item.y || 0);
-}
-function rotateItem(item) {
-  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '');
-}
-function transformItem(item) {
-  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '') + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');
-}
-
-function markItemPath (type, shape, isect) {
-  function attr(emit, item) {
-    emit('transform', rotateItem(item));
-    emit('d', shape(null, item));
-  }
-
-  function bound(bounds, item) {
-    shape(boundContext(bounds, item.angle), item);
-    return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);
-  }
-
-  function draw(context, item) {
-    var x = item.x || 0,
-        y = item.y || 0,
-        a = item.angle || 0;
-    context.translate(x, y);
-    if (a) context.rotate(a *= DegToRad);
-    context.beginPath();
-    shape(context, item);
-    if (a) context.rotate(-a);
-    context.translate(-x, -y);
-  }
-
-  return {
-    type: type,
-    tag: 'path',
-    nested: false,
-    attr: attr,
-    bound: bound,
-    draw: drawAll(draw),
-    pick: pickPath(draw),
-    isect: isect || intersectPath(draw)
-  };
-}
-
-var arc = markItemPath('arc', arc$1);
-
-function pickArea(a, p) {
-  var v = a[0].orient === 'horizontal' ? p[1] : p[0],
-      z = a[0].orient === 'horizontal' ? 'y' : 'x',
-      i = a.length,
-      min = +Infinity,
-      hit,
-      d;
-
-  while (--i >= 0) {
-    if (a[i].defined === false) continue;
-    d = Math.abs(a[i][z] - v);
-
-    if (d < min) {
-      min = d;
-      hit = a[i];
-    }
-  }
-
-  return hit;
-}
-function pickLine(a, p) {
-  var t = Math.pow(a[0].strokeWidth || 1, 2),
-      i = a.length,
-      dx,
-      dy,
-      dd;
-
-  while (--i >= 0) {
-    if (a[i].defined === false) continue;
-    dx = a[i].x - p[0];
-    dy = a[i].y - p[1];
-    dd = dx * dx + dy * dy;
-    if (dd < t) return a[i];
-  }
-
-  return null;
-}
-function pickTrail(a, p) {
-  var i = a.length,
-      dx,
-      dy,
-      dd;
-
-  while (--i >= 0) {
-    if (a[i].defined === false) continue;
-    dx = a[i].x - p[0];
-    dy = a[i].y - p[1];
-    dd = dx * dx + dy * dy;
-    dx = a[i].size || 1;
-    if (dd < dx * dx) return a[i];
-  }
-
-  return null;
-}
-
-function markMultiItemPath (type, shape, tip) {
-  function attr(emit, item) {
-    var items = item.mark.items;
-    if (items.length) emit('d', shape(null, items));
-  }
-
-  function bound(bounds, mark) {
-    var items = mark.items;
-
-    if (items.length === 0) {
-      return bounds;
-    } else {
-      shape(boundContext(bounds), items);
-      return boundStroke(bounds, items[0]);
-    }
-  }
-
-  function draw(context, items) {
-    context.beginPath();
-    shape(context, items);
-  }
-
-  const hit = hitPath(draw);
-
-  function pick(context, scene, x, y, gx, gy) {
-    var items = scene.items,
-        b = scene.bounds;
-
-    if (!items || !items.length || b && !b.contains(gx, gy)) {
-      return null;
-    }
-
-    x *= context.pixelRatio;
-    y *= context.pixelRatio;
-    return hit(context, items, x, y) ? items[0] : null;
-  }
-
-  return {
-    type: type,
-    tag: 'path',
-    nested: true,
-    attr: attr,
-    bound: bound,
-    draw: drawOne(draw),
-    pick: pick,
-    isect: intersectPoint,
-    tip: tip
-  };
-}
-
-var area = markMultiItemPath('area', area$1, pickArea);
-
-function clip (context, scene) {
-  var clip = scene.clip;
-  context.save();
-
-  if (isFunction(clip)) {
-    context.beginPath();
-    clip(context);
-    context.clip();
-  } else {
-    clipGroup(context, scene.group);
-  }
-}
-function clipGroup(context, group) {
-  context.beginPath();
-  hasCornerRadius(group) ? rectangle(context, group, 0, 0) : context.rect(0, 0, group.width || 0, group.height || 0);
-  context.clip();
-}
-
-function offset$1(item) {
-  const sw = value(item.strokeWidth, 1);
-  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
-}
-
-function attr$5(emit, item) {
-  emit('transform', translateItem(item));
-}
-
-function emitRectangle(emit, item) {
-  const off = offset$1(item);
-  emit('d', rectangle(null, item, off, off));
-}
-
-function background(emit, item) {
-  emit('class', 'background');
-  emit('aria-hidden', true);
-  emitRectangle(emit, item);
-}
-
-function foreground(emit, item) {
-  emit('class', 'foreground');
-  emit('aria-hidden', true);
-
-  if (item.strokeForeground) {
-    emitRectangle(emit, item);
-  } else {
-    emit('d', '');
-  }
-}
-
-function content(emit, item, renderer) {
-  const url = item.clip ? clip$1(renderer, item, item) : null;
-  emit('clip-path', url);
-}
-
-function bound$5(bounds, group) {
-  if (!group.clip && group.items) {
-    const items = group.items,
-          m = items.length;
-
-    for (let j = 0; j < m; ++j) {
-      bounds.union(items[j].bounds);
-    }
-  }
-
-  if ((group.clip || group.width || group.height) && !group.noBound) {
-    bounds.add(0, 0).add(group.width || 0, group.height || 0);
-  }
-
-  boundStroke(bounds, group);
-  return bounds.translate(group.x || 0, group.y || 0);
-}
-
-function rectanglePath(context, group, x, y) {
-  const off = offset$1(group);
-  context.beginPath();
-  rectangle(context, group, (x || 0) + off, (y || 0) + off);
-}
-
-const hitBackground = hitPath(rectanglePath);
-const hitForeground = hitPath(rectanglePath, false);
-const hitCorner = hitPath(rectanglePath, true);
-
-function draw$4(context, scene, bounds) {
-  visit(scene, group => {
-    const gx = group.x || 0,
-          gy = group.y || 0,
-          fore = group.strokeForeground,
-          opacity = group.opacity == null ? 1 : group.opacity; // draw group background
-
-    if ((group.stroke || group.fill) && opacity) {
-      rectanglePath(context, group, gx, gy);
-      blend(context, group);
-
-      if (group.fill && fill(context, group, opacity)) {
-        context.fill();
-      }
-
-      if (group.stroke && !fore && stroke(context, group, opacity)) {
-        context.stroke();
-      }
-    } // setup graphics context, set clip and bounds
-
-
-    context.save();
-    context.translate(gx, gy);
-    if (group.clip) clipGroup(context, group);
-    if (bounds) bounds.translate(-gx, -gy); // draw group contents
-
-    visit(group, item => {
-      this.draw(context, item, bounds);
-    }); // restore graphics context
-
-    if (bounds) bounds.translate(gx, gy);
-    context.restore(); // draw group foreground
-
-    if (fore && group.stroke && opacity) {
-      rectanglePath(context, group, gx, gy);
-      blend(context, group);
-
-      if (stroke(context, group, opacity)) {
-        context.stroke();
-      }
-    }
-  });
-}
-
-function pick(context, scene, x, y, gx, gy) {
-  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
-    return null;
-  }
-
-  const cx = x * context.pixelRatio,
-        cy = y * context.pixelRatio;
-  return pickVisit(scene, group => {
-    let hit, dx, dy; // first hit test bounding box
-
-    const b = group.bounds;
-    if (b && !b.contains(gx, gy)) return; // passed bounds check, test rectangular clip
-
-    dx = group.x || 0;
-    dy = group.y || 0;
-    const dw = dx + (group.width || 0),
-          dh = dy + (group.height || 0),
-          c = group.clip;
-    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return; // adjust coordinate system
-
-    context.save();
-    context.translate(dx, dy);
-    dx = gx - dx;
-    dy = gy - dy; // test background for rounded corner clip
-
-    if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {
-      context.restore();
-      return null;
-    }
-
-    const fore = group.strokeForeground,
-          ix = scene.interactive !== false; // hit test against group foreground
-
-    if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {
-      context.restore();
-      return group;
-    } // hit test against contained marks
-
-
-    hit = pickVisit(group, mark => pickMark(mark, dx, dy) ? this.pick(mark, x, y, dx, dy) : null); // hit test against group background
-
-    if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {
-      hit = group;
-    } // restore state and return
-
-
-    context.restore();
-    return hit || null;
-  });
-}
-
-function pickMark(mark, x, y) {
-  return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);
-}
-
-var group = {
-  type: 'group',
-  tag: 'g',
-  nested: false,
-  attr: attr$5,
-  bound: bound$5,
-  draw: draw$4,
-  pick: pick,
-  isect: intersectRect,
-  content: content,
-  background: background,
-  foreground: foreground
-};
-
-var metadata = {
-  'xmlns': 'http://www.w3.org/2000/svg',
-  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
-  'version': '1.1'
-};
-
-function getImage(item, renderer) {
-  var image = item.image;
-
-  if (!image || item.url && item.url !== image.url) {
-    image = {
-      complete: false,
-      width: 0,
-      height: 0
-    };
-    renderer.loadImage(item.url).then(image => {
-      item.image = image;
-      item.image.url = item.url;
-    });
-  }
-
-  return image;
-}
-
-function imageWidth(item, image) {
-  return item.width != null ? item.width : !image || !image.width ? 0 : item.aspect !== false && item.height ? item.height * image.width / image.height : image.width;
-}
-
-function imageHeight(item, image) {
-  return item.height != null ? item.height : !image || !image.height ? 0 : item.aspect !== false && item.width ? item.width * image.height / image.width : image.height;
-}
-
-function imageXOffset(align, w) {
-  return align === 'center' ? w / 2 : align === 'right' ? w : 0;
-}
-
-function imageYOffset(baseline, h) {
-  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;
-}
-
-function attr$4(emit, item, renderer) {
-  const img = getImage(item, renderer),
-        w = imageWidth(item, img),
-        h = imageHeight(item, img),
-        x = (item.x || 0) - imageXOffset(item.align, w),
-        y = (item.y || 0) - imageYOffset(item.baseline, h),
-        i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';
-  emit('href', i, metadata['xmlns:xlink'], 'xlink:href');
-  emit('transform', translate(x, y));
-  emit('width', w);
-  emit('height', h);
-  emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');
-}
-
-function bound$4(bounds, item) {
-  const img = item.image,
-        w = imageWidth(item, img),
-        h = imageHeight(item, img),
-        x = (item.x || 0) - imageXOffset(item.align, w),
-        y = (item.y || 0) - imageYOffset(item.baseline, h);
-  return bounds.set(x, y, x + w, y + h);
-}
-
-function draw$3(context, scene, bounds) {
-  visit(scene, item => {
-    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check
-
-    const img = getImage(item, this);
-    let w = imageWidth(item, img);
-    let h = imageHeight(item, img);
-    if (w === 0 || h === 0) return; // early exit
-
-    let x = (item.x || 0) - imageXOffset(item.align, w),
-        y = (item.y || 0) - imageYOffset(item.baseline, h),
-        opacity,
-        ar0,
-        ar1,
-        t;
-
-    if (item.aspect !== false) {
-      ar0 = img.width / img.height;
-      ar1 = item.width / item.height;
-
-      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
-        if (ar1 < ar0) {
-          t = w / ar0;
-          y += (h - t) / 2;
-          h = t;
-        } else {
-          t = h * ar0;
-          x += (w - t) / 2;
-          w = t;
-        }
-      }
-    }
-
-    if (img.complete || img.toDataURL) {
-      blend(context, item);
-      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;
-      context.imageSmoothingEnabled = item.smooth !== false;
-      context.drawImage(img, x, y, w, h);
-    }
-  });
-}
-
-var image = {
-  type: 'image',
-  tag: 'image',
-  nested: false,
-  attr: attr$4,
-  bound: bound$4,
-  draw: draw$3,
-  pick: pick$1(),
-  isect: truthy,
-  // bounds check is sufficient
-  get: getImage,
-  xOffset: imageXOffset,
-  yOffset: imageYOffset
-};
-
-var line = markMultiItemPath('line', line$1, pickLine);
-
-function attr$3(emit, item) {
-  var sx = item.scaleX || 1,
-      sy = item.scaleY || 1;
-
-  if (sx !== 1 || sy !== 1) {
-    emit('vector-effect', 'non-scaling-stroke');
-  }
-
-  emit('transform', transformItem(item));
-  emit('d', item.path);
-}
-
-function path$1(context, item) {
-  var path = item.path;
-  if (path == null) return true;
-  var x = item.x || 0,
-      y = item.y || 0,
-      sx = item.scaleX || 1,
-      sy = item.scaleY || 1,
-      a = (item.angle || 0) * DegToRad,
-      cache = item.pathCache;
-
-  if (!cache || cache.path !== path) {
-    (item.pathCache = cache = pathParse(path)).path = path;
-  }
-
-  if (a && context.rotate && context.translate) {
-    context.translate(x, y);
-    context.rotate(a);
-    pathRender(context, cache, 0, 0, sx, sy);
-    context.rotate(-a);
-    context.translate(-x, -y);
-  } else {
-    pathRender(context, cache, x, y, sx, sy);
-  }
-}
-
-function bound$3(bounds, item) {
-  return path$1(boundContext(bounds, item.angle), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);
-}
-
-var path$2 = {
-  type: 'path',
-  tag: 'path',
-  nested: false,
-  attr: attr$3,
-  bound: bound$3,
-  draw: drawAll(path$1),
-  pick: pickPath(path$1),
-  isect: intersectPath(path$1)
-};
-
-function attr$2(emit, item) {
-  emit('d', rectangle(null, item));
-}
-
-function bound$2(bounds, item) {
-  var x, y;
-  return boundStroke(bounds.set(x = item.x || 0, y = item.y || 0, x + item.width || 0, y + item.height || 0), item);
-}
-
-function draw$2(context, item) {
-  context.beginPath();
-  rectangle(context, item);
-}
-
-var rect = {
-  type: 'rect',
-  tag: 'path',
-  nested: false,
-  attr: attr$2,
-  bound: bound$2,
-  draw: drawAll(draw$2),
-  pick: pickPath(draw$2),
-  isect: intersectRect
-};
-
-function attr$1(emit, item) {
-  emit('transform', translateItem(item));
-  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);
-  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);
-}
-
-function bound$1(bounds, item) {
-  var x1, y1;
-  return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);
-}
-
-function path(context, item, opacity) {
-  var x1, y1, x2, y2;
-
-  if (item.stroke && stroke(context, item, opacity)) {
-    x1 = item.x || 0;
-    y1 = item.y || 0;
-    x2 = item.x2 != null ? item.x2 : x1;
-    y2 = item.y2 != null ? item.y2 : y1;
-    context.beginPath();
-    context.moveTo(x1, y1);
-    context.lineTo(x2, y2);
-    return true;
-  }
-
-  return false;
-}
-
-function draw$1(context, scene, bounds) {
-  visit(scene, item => {
-    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check
-
-    var opacity = item.opacity == null ? 1 : item.opacity;
-
-    if (opacity && path(context, item, opacity)) {
-      blend(context, item);
-      context.stroke();
-    }
-  });
-}
-
-function hit$1(context, item, x, y) {
-  if (!context.isPointInStroke) return false;
-  return path(context, item, 1) && context.isPointInStroke(x, y);
-}
-
-var rule = {
-  type: 'rule',
-  tag: 'line',
-  nested: false,
-  attr: attr$1,
-  bound: bound$1,
-  draw: draw$1,
-  pick: pick$1(hit$1),
-  isect: intersectRule
-};
-
-var shape = markItemPath('shape', shape$1);
-
-var symbol = markItemPath('symbol', symbol$1, intersectPoint);
-
-const widthCache = lruCache();
-var textMetrics = {
-  height: fontSize,
-  measureWidth: measureWidth,
-  estimateWidth: estimateWidth,
-  width: estimateWidth,
-  canvas: useCanvas
-};
-useCanvas(true);
-
-function useCanvas(use) {
-  textMetrics.width = use && context ? measureWidth : estimateWidth;
-} // make simple estimate if no canvas is available
-
-
-function estimateWidth(item, text) {
-  return _estimateWidth(textValue(item, text), fontSize(item));
-}
-
-function _estimateWidth(text, currentFontHeight) {
-  return ~~(0.8 * text.length * currentFontHeight);
-} // measure text width if canvas is available
-
-
-function measureWidth(item, text) {
-  return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0 : _measureWidth(text, font(item));
-}
-
-function _measureWidth(text, currentFont) {
-  const key = `(${currentFont}) ${text}`;
-  let width = widthCache.get(key);
-
-  if (width === undefined) {
-    context.font = currentFont;
-    width = context.measureText(text).width;
-    widthCache.set(key, width);
-  }
-
-  return width;
-}
-
-function fontSize(item) {
-  return item.fontSize != null ? +item.fontSize || 0 : 11;
-}
-function lineHeight(item) {
-  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
-}
-
-function lineArray(_) {
-  return isArray(_) ? _.length > 1 ? _ : _[0] : _;
-}
-
-function textLines(item) {
-  return lineArray(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);
-}
-function multiLineOffset(item) {
-  const tl = textLines(item);
-  return (isArray(tl) ? tl.length - 1 : 0) * lineHeight(item);
-}
-function textValue(item, line) {
-  const text = line == null ? '' : (line + '').trim();
-  return item.limit > 0 && text.length ? truncate(item, text) : text;
-}
-
-function widthGetter(item) {
-  if (textMetrics.width === measureWidth) {
-    // we are using canvas
-    const currentFont = font(item);
-    return text => _measureWidth(text, currentFont);
-  } else {
-    // we are relying on estimates
-    const currentFontHeight = fontSize(item);
-    return text => _estimateWidth(text, currentFontHeight);
-  }
-}
-
-function truncate(item, text) {
-  var limit = +item.limit,
-      width = widthGetter(item);
-  if (width(text) < limit) return text;
-  var ellipsis = item.ellipsis || '\u2026',
-      rtl = item.dir === 'rtl',
-      lo = 0,
-      hi = text.length,
-      mid;
-  limit -= width(ellipsis);
-
-  if (rtl) {
-    while (lo < hi) {
-      mid = lo + hi >>> 1;
-      if (width(text.slice(mid)) > limit) lo = mid + 1;else hi = mid;
-    }
-
-    return ellipsis + text.slice(lo);
-  } else {
-    while (lo < hi) {
-      mid = 1 + (lo + hi >>> 1);
-      if (width(text.slice(0, mid)) < limit) lo = mid;else hi = mid - 1;
-    }
-
-    return text.slice(0, lo) + ellipsis;
-  }
-}
-
-function fontFamily(item, quote) {
-  var font = item.font;
-  return (quote && font ? String(font).replace(/"/g, '\'') : font) || 'sans-serif';
-}
-function font(item, quote) {
-  return '' + (item.fontStyle ? item.fontStyle + ' ' : '') + (item.fontVariant ? item.fontVariant + ' ' : '') + (item.fontWeight ? item.fontWeight + ' ' : '') + fontSize(item) + 'px ' + fontFamily(item, quote);
-}
-function offset(item) {
-  // perform our own font baseline calculation
-  // why? not all browsers support SVG 1.1 'alignment-baseline' :(
-  // this also ensures consistent layout across renderers
-  var baseline = item.baseline,
-      h = fontSize(item);
-  return Math.round(baseline === 'top' ? 0.79 * h : baseline === 'middle' ? 0.30 * h : baseline === 'bottom' ? -0.21 * h : baseline === 'line-top' ? 0.29 * h + 0.5 * lineHeight(item) : baseline === 'line-bottom' ? 0.29 * h - 0.5 * lineHeight(item) : 0);
-}
-
-const textAlign = {
-  'left': 'start',
-  'center': 'middle',
-  'right': 'end'
-};
-const tempBounds = new Bounds();
-
-function anchorPoint(item) {
-  var x = item.x || 0,
-      y = item.y || 0,
-      r = item.radius || 0,
-      t;
-
-  if (r) {
-    t = (item.theta || 0) - HalfPi;
-    x += r * Math.cos(t);
-    y += r * Math.sin(t);
-  }
-
-  tempBounds.x1 = x;
-  tempBounds.y1 = y;
-  return tempBounds;
-}
-
-function attr(emit, item) {
-  var dx = item.dx || 0,
-      dy = (item.dy || 0) + offset(item),
-      p = anchorPoint(item),
-      x = p.x1,
-      y = p.y1,
-      a = item.angle || 0,
-      t;
-  emit('text-anchor', textAlign[item.align] || 'start');
-
-  if (a) {
-    t = translate(x, y) + ' ' + rotate(a);
-    if (dx || dy) t += ' ' + translate(dx, dy);
-  } else {
-    t = translate(x + dx, y + dy);
-  }
-
-  emit('transform', t);
-}
-
-function bound(bounds, item, mode) {
-  var h = textMetrics.height(item),
-      a = item.align,
-      p = anchorPoint(item),
-      x = p.x1,
-      y = p.y1,
-      dx = item.dx || 0,
-      dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h),
-      // use 4/5 offset
-  tl = textLines(item),
-      w; // get dimensions
-
-  if (isArray(tl)) {
-    // multi-line text
-    h += lineHeight(item) * (tl.length - 1);
-    w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);
-  } else {
-    // single-line text
-    w = textMetrics.width(item, tl);
-  } // horizontal alignment
-
-
-  if (a === 'center') {
-    dx -= w / 2;
-  } else if (a === 'right') {
-    dx -= w;
-  } else ;
-
-  bounds.set(dx += x, dy += y, dx + w, dy + h);
-
-  if (item.angle && !mode) {
-    bounds.rotate(item.angle * DegToRad, x, y);
-  } else if (mode === 2) {
-    return bounds.rotatedPoints(item.angle * DegToRad, x, y);
-  }
-
-  return bounds;
-}
-
-function draw(context, scene, bounds) {
-  visit(scene, item => {
-    var opacity = item.opacity == null ? 1 : item.opacity,
-        p,
-        x,
-        y,
-        i,
-        lh,
-        tl,
-        str;
-    if (bounds && !bounds.intersects(item.bounds) || // bounds check
-    opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;
-    context.font = font(item);
-    context.textAlign = item.align || 'left';
-    p = anchorPoint(item);
-    x = p.x1, y = p.y1;
-
-    if (item.angle) {
-      context.save();
-      context.translate(x, y);
-      context.rotate(item.angle * DegToRad);
-      x = y = 0; // reset x, y
-    }
-
-    x += item.dx || 0;
-    y += (item.dy || 0) + offset(item);
-    tl = textLines(item);
-    blend(context, item);
-
-    if (isArray(tl)) {
-      lh = lineHeight(item);
-
-      for (i = 0; i < tl.length; ++i) {
-        str = textValue(item, tl[i]);
-
-        if (item.fill && fill(context, item, opacity)) {
-          context.fillText(str, x, y);
-        }
-
-        if (item.stroke && stroke(context, item, opacity)) {
-          context.strokeText(str, x, y);
-        }
-
-        y += lh;
-      }
-    } else {
-      str = textValue(item, tl);
-
-      if (item.fill && fill(context, item, opacity)) {
-        context.fillText(str, x, y);
-      }
-
-      if (item.stroke && stroke(context, item, opacity)) {
-        context.strokeText(str, x, y);
-      }
-    }
-
-    if (item.angle) context.restore();
-  });
-}
-
-function hit(context, item, x, y, gx, gy) {
-  if (item.fontSize <= 0) return false;
-  if (!item.angle) return true; // bounds sufficient if no rotation
-  // project point into space of unrotated bounds
-
-  var p = anchorPoint(item),
-      ax = p.x1,
-      ay = p.y1,
-      b = bound(tempBounds, item, 1),
-      a = -item.angle * DegToRad,
-      cos = Math.cos(a),
-      sin = Math.sin(a),
-      px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),
-      py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);
-  return b.contains(px, py);
-}
-
-function intersectText(item, box) {
-  const p = bound(tempBounds, item, 2);
-  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
-}
-
-var text = {
-  type: 'text',
-  tag: 'text',
-  nested: false,
-  attr: attr,
-  bound: bound,
-  draw: draw,
-  pick: pick$1(hit),
-  isect: intersectText
-};
-
-var trail = markMultiItemPath('trail', trail$1, pickTrail);
-
-var Marks = {
-  arc: arc,
-  area: area,
-  group: group,
-  image: image,
-  line: line,
-  path: path$2,
-  rect: rect,
-  rule: rule,
-  shape: shape,
-  symbol: symbol,
-  text: text,
-  trail: trail
-};
-
-function boundItem (item, func, opt) {
-  var type = Marks[item.mark.marktype],
-      bound = func || type.bound;
-  if (type.nested) item = item.mark;
-  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);
-}
-
-var DUMMY = {
-  mark: null
-};
-function boundMark (mark, bounds, opt) {
-  var type = Marks[mark.marktype],
-      bound = type.bound,
-      items = mark.items,
-      hasItems = items && items.length,
-      i,
-      n,
-      item,
-      b;
-
-  if (type.nested) {
-    if (hasItems) {
-      item = items[0];
-    } else {
-      // no items, fake it
-      DUMMY.mark = mark;
-      item = DUMMY;
-    }
-
-    b = boundItem(item, bound, opt);
-    bounds = bounds && bounds.union(b) || b;
-    return bounds;
-  }
-
-  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();
-
-  if (hasItems) {
-    for (i = 0, n = items.length; i < n; ++i) {
-      bounds.union(boundItem(items[i], bound, opt));
-    }
-  }
-
-  return mark.bounds = bounds;
-}
-
-const keys = ['marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex', 'x', 'y', 'width', 'height', 'align', 'baseline', // layout
-'fill', 'fillOpacity', 'opacity', 'blend', // fill
-'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap', // stroke
-'strokeDash', 'strokeDashOffset', // stroke dash
-'strokeForeground', 'strokeOffset', // group
-'startAngle', 'endAngle', 'innerRadius', 'outerRadius', // arc
-'cornerRadius', 'padAngle', // arc, rect
-'cornerRadiusTopLeft', 'cornerRadiusTopRight', // rect, group
-'cornerRadiusBottomLeft', 'cornerRadiusBottomRight', 'interpolate', 'tension', 'orient', 'defined', // area, line
-'url', 'aspect', 'smooth', // image
-'path', 'scaleX', 'scaleY', // path
-'x2', 'y2', // rule
-'size', 'shape', // symbol
-'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy', // text
-'ellipsis', 'limit', 'lineBreak', 'lineHeight', 'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant', // font
-'description', 'aria', 'ariaRole', 'ariaRoleDescription' // aria
-];
-function sceneToJSON(scene, indent) {
-  return JSON.stringify(scene, keys, indent);
-}
-function sceneFromJSON(json) {
-  const scene = typeof json === 'string' ? JSON.parse(json) : json;
-  return initialize(scene);
-}
-
-function initialize(scene) {
-  var type = scene.marktype,
-      items = scene.items,
-      parent,
-      i,
-      n;
-
-  if (items) {
-    for (i = 0, n = items.length; i < n; ++i) {
-      parent = type ? 'mark' : 'group';
-      items[i][parent] = scene;
-      if (items[i].zindex) items[i][parent].zdirty = true;
-      if ('group' === (type || parent)) initialize(items[i]);
-    }
-  }
-
-  if (type) boundMark(scene);
-  return scene;
-}
-
-function Scenegraph(scene) {
-  if (arguments.length) {
-    this.root = sceneFromJSON(scene);
-  } else {
-    this.root = createMark({
-      marktype: 'group',
-      name: 'root',
-      role: 'frame'
-    });
-    this.root.items = [new GroupItem(this.root)];
-  }
-}
-Scenegraph.prototype = {
-  toJSON(indent) {
-    return sceneToJSON(this.root, indent || 0);
-  },
-
-  mark(markdef, group, index) {
-    group = group || this.root.items[0];
-    const mark = createMark(markdef, group);
-    group.items[index] = mark;
-    if (mark.zindex) mark.group.zdirty = true;
-    return mark;
-  }
-
-};
-
-function createMark(def, group) {
-  const mark = {
-    bounds: new Bounds(),
-    clip: !!def.clip,
-    group: group,
-    interactive: def.interactive === false ? false : true,
-    items: [],
-    marktype: def.marktype,
-    name: def.name || undefined,
-    role: def.role || undefined,
-    zindex: def.zindex || 0
-  }; // add accessibility properties if defined
-
-  if (def.aria != null) {
-    mark.aria = def.aria;
-  }
-
-  if (def.description) {
-    mark.description = def.description;
-  }
-
-  return mark;
-}
-
-// create a new DOM element
-function domCreate(doc, tag, ns) {
-  if (!doc && typeof document !== 'undefined' && document.createElement) {
-    doc = document;
-  }
-
-  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
-} // find first child element with matching tag
-
-function domFind(el, tag) {
-  tag = tag.toLowerCase();
-  var nodes = el.childNodes,
-      i = 0,
-      n = nodes.length;
-
-  for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {
-    return nodes[i];
-  }
-} // retrieve child element at given index
-// create & insert if doesn't exist or if tags do not match
-
-function domChild(el, index, tag, ns) {
-  var a = el.childNodes[index],
-      b;
-
-  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {
-    b = a || null;
-    a = domCreate(el.ownerDocument, tag, ns);
-    el.insertBefore(a, b);
-  }
-
-  return a;
-} // remove all child elements at or above the given index
-
-function domClear(el, index) {
-  var nodes = el.childNodes,
-      curr = nodes.length;
-
-  while (curr > index) el.removeChild(nodes[--curr]);
-
-  return el;
-} // generate css class name for mark
-
-function cssClass(mark) {
-  return 'mark-' + mark.marktype + (mark.role ? ' role-' + mark.role : '') + (mark.name ? ' ' + mark.name : '');
-}
-
-function point (event, el) {
-  const rect = el.getBoundingClientRect();
-  return [event.clientX - rect.left - (el.clientLeft || 0), event.clientY - rect.top - (el.clientTop || 0)];
-}
-
-function resolveItem (item, event, el, origin) {
-  var mark = item && item.mark,
-      mdef,
-      p;
-
-  if (mark && (mdef = Marks[mark.marktype]).tip) {
-    p = point(event, el);
-    p[0] -= origin[0];
-    p[1] -= origin[1];
-
-    while (item = item.mark.group) {
-      p[0] -= item.x || 0;
-      p[1] -= item.y || 0;
-    }
-
-    item = mdef.tip(mark.items, p);
-  }
-
-  return item;
-}
-
-/**
- * Create a new Handler instance.
- * @param {object} [customLoader] - Optional loader instance for
- *   href URL sanitization. If not specified, a standard loader
- *   instance will be generated.
- * @param {function} [customTooltip] - Optional tooltip handler
- *   function for custom tooltip display.
- * @constructor
- */
-
-function Handler(customLoader, customTooltip) {
-  this._active = null;
-  this._handlers = {};
-  this._loader = customLoader || loader();
-  this._tooltip = customTooltip || defaultTooltip;
-} // The default tooltip display handler.
-// Sets the HTML title attribute on the visualization container.
-
-function defaultTooltip(handler, event, item, value) {
-  handler.element().setAttribute('title', value || '');
-}
-
-Handler.prototype = {
-  /**
-   * Initialize a new Handler instance.
-   * @param {DOMElement} el - The containing DOM element for the display.
-   * @param {Array<number>} origin - The origin of the display, in pixels.
-   *   The coordinate system will be translated to this point.
-   * @param {object} [obj] - Optional context object that should serve as
-   *   the "this" context for event callbacks.
-   * @return {Handler} - This handler instance.
-   */
-  initialize(el, origin, obj) {
-    this._el = el;
-    this._obj = obj || null;
-    return this.origin(origin);
-  },
-
-  /**
-   * Returns the parent container element for a visualization.
-   * @return {DOMElement} - The containing DOM element.
-   */
-  element() {
-    return this._el;
-  },
-
-  /**
-   * Returns the scene element (e.g., canvas or SVG) of the visualization
-   * Subclasses must override if the first child is not the scene element.
-   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
-   */
-  canvas() {
-    return this._el && this._el.firstChild;
-  },
-
-  /**
-   * Get / set the origin coordinates of the visualization.
-   */
-  origin(origin) {
-    if (arguments.length) {
-      this._origin = origin || [0, 0];
-      return this;
-    } else {
-      return this._origin.slice();
-    }
-  },
-
-  /**
-   * Get / set the scenegraph root.
-   */
-  scene(scene) {
-    if (!arguments.length) return this._scene;
-    this._scene = scene;
-    return this;
-  },
-
-  /**
-   * Add an event handler. Subclasses should override this method.
-   */
-  on()
-  /*type, handler*/
-  {},
-
-  /**
-   * Remove an event handler. Subclasses should override this method.
-   */
-  off()
-  /*type, handler*/
-  {},
-
-  /**
-   * Utility method for finding the array index of an event handler.
-   * @param {Array} h - An array of registered event handlers.
-   * @param {string} type - The event type.
-   * @param {function} handler - The event handler instance to find.
-   * @return {number} - The handler's array index or -1 if not registered.
-   */
-  _handlerIndex(h, type, handler) {
-    for (let i = h ? h.length : 0; --i >= 0;) {
-      if (h[i].type === type && (!handler || h[i].handler === handler)) {
-        return i;
-      }
-    }
-
-    return -1;
-  },
-
-  /**
-   * Returns an array with registered event handlers.
-   * @param {string} [type] - The event type to query. Any annotations
-   *   are ignored; for example, for the argument "click.foo", ".foo" will
-   *   be ignored and the method returns all "click" handlers. If type is
-   *   null or unspecified, this method returns handlers for all types.
-   * @return {Array} - A new array containing all registered event handlers.
-   */
-  handlers(type) {
-    const h = this._handlers,
-          a = [];
-
-    if (type) {
-      a.push(...h[this.eventName(type)]);
-    } else {
-      for (const k in h) {
-        a.push(...h[k]);
-      }
-    }
-
-    return a;
-  },
-
-  /**
-   * Parses an event name string to return the specific event type.
-   * For example, given "click.foo" returns "click"
-   * @param {string} name - The input event type string.
-   * @return {string} - A string with the event type only.
-   */
-  eventName(name) {
-    const i = name.indexOf('.');
-    return i < 0 ? name : name.slice(0, i);
-  },
-
-  /**
-   * Handle hyperlink navigation in response to an item.href value.
-   * @param {Event} event - The event triggering hyperlink navigation.
-   * @param {Item} item - The scenegraph item.
-   * @param {string} href - The URL to navigate to.
-   */
-  handleHref(event, item, href) {
-    this._loader.sanitize(href, {
-      context: 'href'
-    }).then(opt => {
-      const e = new MouseEvent(event.type, event),
-            a = domCreate(null, 'a');
-
-      for (const name in opt) a.setAttribute(name, opt[name]);
-
-      a.dispatchEvent(e);
-    }).catch(() => {
-      /* do nothing */
-    });
-  },
-
-  /**
-   * Handle tooltip display in response to an item.tooltip value.
-   * @param {Event} event - The event triggering tooltip display.
-   * @param {Item} item - The scenegraph item.
-   * @param {boolean} show - A boolean flag indicating whether
-   *   to show or hide a tooltip for the given item.
-   */
-  handleTooltip(event, item, show) {
-    if (item && item.tooltip != null) {
-      item = resolveItem(item, event, this.canvas(), this._origin);
-      const value = show && item && item.tooltip || null;
-
-      this._tooltip.call(this._obj, this, event, item, value);
-    }
-  },
-
-  /**
-   * Returns the size of a scenegraph item and its position relative
-   * to the viewport.
-   * @param {Item} item - The scenegraph item.
-   * @return {object} - A bounding box object (compatible with the
-   *   DOMRect type) consisting of x, y, width, heigh, top, left,
-   *   right, and bottom properties.
-   */
-  getItemBoundingClientRect(item) {
-    const el = this.canvas();
-    if (!el) return;
-    const rect = el.getBoundingClientRect(),
-          origin = this._origin,
-          bounds = item.bounds,
-          width = bounds.width(),
-          height = bounds.height();
-    let x = bounds.x1 + origin[0] + rect.left,
-        y = bounds.y1 + origin[1] + rect.top; // translate coordinate for each parent group
-
-    while (item.mark && (item = item.mark.group)) {
-      x += item.x || 0;
-      y += item.y || 0;
-    } // return DOMRect-compatible bounding box
-
-
-    return {
-      x,
-      y,
-      width,
-      height,
-      left: x,
-      top: y,
-      right: x + width,
-      bottom: y + height
-    };
-  }
-
-};
-
-/**
- * Create a new Renderer instance.
- * @param {object} [loader] - Optional loader instance for
- *   image and href URL sanitization. If not specified, a
- *   standard loader instance will be generated.
- * @constructor
- */
-
-function Renderer(loader) {
-  this._el = null;
-  this._bgcolor = null;
-  this._loader = new ResourceLoader(loader);
-}
-Renderer.prototype = {
-  /**
-   * Initialize a new Renderer instance.
-   * @param {DOMElement} el - The containing DOM element for the display.
-   * @param {number} width - The coordinate width of the display, in pixels.
-   * @param {number} height - The coordinate height of the display, in pixels.
-   * @param {Array<number>} origin - The origin of the display, in pixels.
-   *   The coordinate system will be translated to this point.
-   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
-   *   the width and height to determine the final pixel size.
-   * @return {Renderer} - This renderer instance.
-   */
-  initialize(el, width, height, origin, scaleFactor) {
-    this._el = el;
-    return this.resize(width, height, origin, scaleFactor);
-  },
-
-  /**
-   * Returns the parent container element for a visualization.
-   * @return {DOMElement} - The containing DOM element.
-   */
-  element() {
-    return this._el;
-  },
-
-  /**
-   * Returns the scene element (e.g., canvas or SVG) of the visualization
-   * Subclasses must override if the first child is not the scene element.
-   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
-   */
-  canvas() {
-    return this._el && this._el.firstChild;
-  },
-
-  /**
-   * Get / set the background color.
-   */
-  background(bgcolor) {
-    if (arguments.length === 0) return this._bgcolor;
-    this._bgcolor = bgcolor;
-    return this;
-  },
-
-  /**
-   * Resize the display.
-   * @param {number} width - The new coordinate width of the display, in pixels.
-   * @param {number} height - The new coordinate height of the display, in pixels.
-   * @param {Array<number>} origin - The new origin of the display, in pixels.
-   *   The coordinate system will be translated to this point.
-   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
-   *   the width and height to determine the final pixel size.
-   * @return {Renderer} - This renderer instance;
-   */
-  resize(width, height, origin, scaleFactor) {
-    this._width = width;
-    this._height = height;
-    this._origin = origin || [0, 0];
-    this._scale = scaleFactor || 1;
-    return this;
-  },
-
-  /**
-   * Report a dirty item whose bounds should be redrawn.
-   * This base class method does nothing. Subclasses that perform
-   * incremental should implement this method.
-   * @param {Item} item - The dirty item whose bounds should be redrawn.
-   */
-  dirty()
-  /*item*/
-  {},
-
-  /**
-   * Render an input scenegraph, potentially with a set of dirty items.
-   * This method will perform an immediate rendering with available resources.
-   * The renderer may also need to perform image loading to perform a complete
-   * render. This process can lead to asynchronous re-rendering of the scene
-   * after this method returns. To receive notification when rendering is
-   * complete, use the renderAsync method instead.
-   * @param {object} scene - The root mark of a scenegraph to render.
-   * @return {Renderer} - This renderer instance.
-   */
-  render(scene) {
-    const r = this; // bind arguments into a render call, and cache it
-    // this function may be subsequently called for async redraw
-
-    r._call = function () {
-      r._render(scene);
-    }; // invoke the renderer
-
-
-    r._call(); // clear the cached call for garbage collection
-    // async redraws will stash their own copy
-
-
-    r._call = null;
-    return r;
-  },
-
-  /**
-   * Internal rendering method. Renderer subclasses should override this
-   * method to actually perform rendering.
-   * @param {object} scene - The root mark of a scenegraph to render.
-   */
-  _render()
-  /*scene*/
-  {// subclasses to override
-  },
-
-  /**
-   * Asynchronous rendering method. Similar to render, but returns a Promise
-   * that resolves when all rendering is completed. Sometimes a renderer must
-   * perform image loading to get a complete rendering. The returned
-   * Promise will not resolve until this process completes.
-   * @param {object} scene - The root mark of a scenegraph to render.
-   * @return {Promise} - A Promise that resolves when rendering is complete.
-   */
-  renderAsync(scene) {
-    const r = this.render(scene);
-    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
-  },
-
-  /**
-   * Internal method for asynchronous resource loading.
-   * Proxies method calls to the ImageLoader, and tracks loading
-   * progress to invoke a re-render once complete.
-   * @param {string} method - The method name to invoke on the ImageLoader.
-   * @param {string} uri - The URI for the requested resource.
-   * @return {Promise} - A Promise that resolves to the requested resource.
-   */
-  _load(method, uri) {
-    var r = this,
-        p = r._loader[method](uri);
-
-    if (!r._ready) {
-      // re-render the scene when loading completes
-      const call = r._call;
-      r._ready = r._loader.ready().then(redraw => {
-        if (redraw) call();
-        r._ready = null;
-      });
-    }
-
-    return p;
-  },
-
-  /**
-   * Sanitize a URL to include as a hyperlink in the rendered scene.
-   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
-   * image loading progress and invokes a re-render once complete.
-   * @param {string} uri - The URI string to sanitize.
-   * @return {Promise} - A Promise that resolves to the sanitized URL.
-   */
-  sanitizeURL(uri) {
-    return this._load('sanitizeURL', uri);
-  },
-
-  /**
-   * Requests an image to include in the rendered scene.
-   * This method proxies a call to ImageLoader.loadImage, but also tracks
-   * image loading progress and invokes a re-render once complete.
-   * @param {string} uri - The URI string of the image.
-   * @return {Promise} - A Promise that resolves to the loaded Image.
-   */
-  loadImage(uri) {
-    return this._load('loadImage', uri);
-  }
-
-};
-
-const KeyDownEvent = 'keydown';
-const KeyPressEvent = 'keypress';
-const KeyUpEvent = 'keyup';
-const DragEnterEvent = 'dragenter';
-const DragLeaveEvent = 'dragleave';
-const DragOverEvent = 'dragover';
-const MouseDownEvent = 'mousedown';
-const MouseUpEvent = 'mouseup';
-const MouseMoveEvent = 'mousemove';
-const MouseOutEvent = 'mouseout';
-const MouseOverEvent = 'mouseover';
-const ClickEvent = 'click';
-const DoubleClickEvent = 'dblclick';
-const WheelEvent = 'wheel';
-const MouseWheelEvent = 'mousewheel';
-const TouchStartEvent = 'touchstart';
-const TouchMoveEvent = 'touchmove';
-const TouchEndEvent = 'touchend';
-const Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
-const TooltipShowEvent = MouseMoveEvent;
-const TooltipHideEvent = MouseOutEvent;
-const HrefEvent = ClickEvent;
-
-function CanvasHandler(loader, tooltip) {
-  Handler.call(this, loader, tooltip);
-  this._down = null;
-  this._touch = null;
-  this._first = true;
-  this._events = {};
-}
-
-const eventBundle = type => type === TouchStartEvent || type === TouchMoveEvent || type === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type]; // lazily add listeners to the canvas as needed
-
-
-function eventListenerCheck(handler, type) {
-  eventBundle(type).forEach(_ => addEventListener(handler, _));
-}
-
-function addEventListener(handler, type) {
-  const canvas = handler.canvas();
-
-  if (canvas && !handler._events[type]) {
-    handler._events[type] = 1;
-    canvas.addEventListener(type, handler[type] ? evt => handler[type](evt) : evt => handler.fire(type, evt));
-  }
-}
-
-function move(moveEvent, overEvent, outEvent) {
-  return function (evt) {
-    const a = this._active,
-          p = this.pickEvent(evt);
-
-    if (p === a) {
-      // active item and picked item are the same
-      this.fire(moveEvent, evt); // fire move
-    } else {
-      // active item and picked item are different
-      if (!a || !a.exit) {
-        // fire out for prior active item
-        // suppress if active item was removed from scene
-        this.fire(outEvent, evt);
-      }
-
-      this._active = p; // set new active item
-
-      this.fire(overEvent, evt); // fire over for new active item
-
-      this.fire(moveEvent, evt); // fire move for new active item
-    }
-  };
-}
-
-function inactive(type) {
-  return function (evt) {
-    this.fire(type, evt);
-    this._active = null;
-  };
-}
-
-inherits(CanvasHandler, Handler, {
-  initialize(el, origin, obj) {
-    this._canvas = el && domFind(el, 'canvas'); // add minimal events required for proper state management
-
-    [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach(type => eventListenerCheck(this, type));
-    return Handler.prototype.initialize.call(this, el, origin, obj);
-  },
-
-  // return the backing canvas instance
-  canvas() {
-    return this._canvas;
-  },
-
-  // retrieve the current canvas context
-  context() {
-    return this._canvas.getContext('2d');
-  },
-
-  // supported events
-  events: Events,
-
-  // to keep old versions of firefox happy
-  DOMMouseScroll(evt) {
-    this.fire(MouseWheelEvent, evt);
-  },
-
-  mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),
-  dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),
-  mouseout: inactive(MouseOutEvent),
-  dragleave: inactive(DragLeaveEvent),
-
-  mousedown(evt) {
-    this._down = this._active;
-    this.fire(MouseDownEvent, evt);
-  },
-
-  click(evt) {
-    if (this._down === this._active) {
-      this.fire(ClickEvent, evt);
-      this._down = null;
-    }
-  },
-
-  touchstart(evt) {
-    this._touch = this.pickEvent(evt.changedTouches[0]);
-
-    if (this._first) {
-      this._active = this._touch;
-      this._first = false;
-    }
-
-    this.fire(TouchStartEvent, evt, true);
-  },
-
-  touchmove(evt) {
-    this.fire(TouchMoveEvent, evt, true);
-  },
-
-  touchend(evt) {
-    this.fire(TouchEndEvent, evt, true);
-    this._touch = null;
-  },
-
-  // fire an event
-  fire(type, evt, touch) {
-    const a = touch ? this._touch : this._active,
-          h = this._handlers[type]; // set event type relative to scenegraph items
-
-    evt.vegaType = type; // handle hyperlinks and tooltips first
-
-    if (type === HrefEvent && a && a.href) {
-      this.handleHref(evt, a, a.href);
-    } else if (type === TooltipShowEvent || type === TooltipHideEvent) {
-      this.handleTooltip(evt, a, type !== TooltipHideEvent);
-    } // invoke all registered handlers
-
-
-    if (h) {
-      for (let i = 0, len = h.length; i < len; ++i) {
-        h[i].handler.call(this._obj, evt, a);
-      }
-    }
-  },
-
-  // add an event handler
-  on(type, handler) {
-    const name = this.eventName(type),
-          h = this._handlers,
-          i = this._handlerIndex(h[name], type, handler);
-
-    if (i < 0) {
-      eventListenerCheck(this, type);
-      (h[name] || (h[name] = [])).push({
-        type: type,
-        handler: handler
-      });
-    }
-
-    return this;
-  },
-
-  // remove an event handler
-  off(type, handler) {
-    const name = this.eventName(type),
-          h = this._handlers[name],
-          i = this._handlerIndex(h, type, handler);
-
-    if (i >= 0) {
-      h.splice(i, 1);
-    }
-
-    return this;
-  },
-
-  pickEvent(evt) {
-    const p = point(evt, this._canvas),
-          o = this._origin;
-    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
-  },
-
-  // find the scenegraph item at the current mouse position
-  // x, y -- the absolute x, y mouse coordinates on the canvas element
-  // gx, gy -- the relative coordinates within the current group
-  pick(scene, x, y, gx, gy) {
-    const g = this.context(),
-          mark = Marks[scene.marktype];
-    return mark.pick.call(this, g, scene, x, y, gx, gy);
-  }
-
-});
-
-function devicePixelRatio() {
-  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;
-}
-
-var pixelRatio = devicePixelRatio();
-function resize (canvas, width, height, origin, scaleFactor, opt) {
-  const inDOM = typeof HTMLElement !== 'undefined' && canvas instanceof HTMLElement && canvas.parentNode != null,
-        context = canvas.getContext('2d'),
-        ratio = inDOM ? pixelRatio : scaleFactor;
-  canvas.width = width * ratio;
-  canvas.height = height * ratio;
-
-  for (const key in opt) {
-    context[key] = opt[key];
-  }
-
-  if (inDOM && ratio !== 1) {
-    canvas.style.width = width + 'px';
-    canvas.style.height = height + 'px';
-  }
-
-  context.pixelRatio = ratio;
-  context.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
-  return canvas;
-}
-
-function CanvasRenderer(loader) {
-  Renderer.call(this, loader);
-  this._options = {};
-  this._redraw = false;
-  this._dirty = new Bounds();
-  this._tempb = new Bounds();
-}
-const base$1 = Renderer.prototype;
-
-const viewBounds = (origin, width, height) => new Bounds().set(0, 0, width, height).translate(-origin[0], -origin[1]);
-
-function clipToBounds(g, b, origin) {
-  // expand bounds by 1 pixel, then round to pixel boundaries
-  b.expand(1).round(); // align to base pixel grid in case of non-integer scaling (#2425)
-
-  if (g.pixelRatio % 1) {
-    b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
-  } // to avoid artifacts translate if origin has fractional pixels
-
-
-  b.translate(-(origin[0] % 1), -(origin[1] % 1)); // set clip path
-
-  g.beginPath();
-  g.rect(b.x1, b.y1, b.width(), b.height());
-  g.clip();
-  return b;
-}
-
-inherits(CanvasRenderer, Renderer, {
-  initialize(el, width, height, origin, scaleFactor, options) {
-    this._options = options || {};
-    this._canvas = this._options.externalContext ? null : canvas(1, 1, this._options.type); // instantiate a small canvas
-
-    if (el && this._canvas) {
-      domClear(el, 0).appendChild(this._canvas);
-
-      this._canvas.setAttribute('class', 'marks');
-    } // this method will invoke resize to size the canvas appropriately
-
-
-    return base$1.initialize.call(this, el, width, height, origin, scaleFactor);
-  },
-
-  resize(width, height, origin, scaleFactor) {
-    base$1.resize.call(this, width, height, origin, scaleFactor);
-
-    if (this._canvas) {
-      // configure canvas size and transform
-      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
-    } else {
-      // external context needs to be scaled and positioned to origin
-      const ctx = this._options.externalContext;
-      if (!ctx) error('CanvasRenderer is missing a valid canvas or context');
-      ctx.scale(this._scale, this._scale);
-      ctx.translate(this._origin[0], this._origin[1]);
-    }
-
-    this._redraw = true;
-    return this;
-  },
-
-  canvas() {
-    return this._canvas;
-  },
-
-  context() {
-    return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);
-  },
-
-  dirty(item) {
-    const b = this._tempb.clear().union(item.bounds);
-
-    let g = item.mark.group;
-
-    while (g) {
-      b.translate(g.x || 0, g.y || 0);
-      g = g.mark.group;
-    }
-
-    this._dirty.union(b);
-  },
-
-  _render(scene) {
-    const g = this.context(),
-          o = this._origin,
-          w = this._width,
-          h = this._height,
-          db = this._dirty,
-          vb = viewBounds(o, w, h); // setup
-
-    g.save();
-    const b = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
-    this.clear(-o[0], -o[1], w, h); // render
-
-    this.draw(g, scene, b); // takedown
-
-    g.restore();
-    db.clear();
-    return this;
-  },
-
-  draw(ctx, scene, bounds) {
-    const mark = Marks[scene.marktype];
-    if (scene.clip) clip(ctx, scene);
-    mark.draw.call(this, ctx, scene, bounds);
-    if (scene.clip) ctx.restore();
-  },
-
-  clear(x, y, w, h) {
-    const opt = this._options,
-          g = this.context();
-
-    if (opt.type !== 'pdf' && !opt.externalContext) {
-      // calling clear rect voids vector output in pdf mode
-      // and could remove external context content (#2615)
-      g.clearRect(x, y, w, h);
-    }
-
-    if (this._bgcolor != null) {
-      g.fillStyle = this._bgcolor;
-      g.fillRect(x, y, w, h);
-    }
-  }
-
-});
-
-function SVGHandler(loader, tooltip) {
-  Handler.call(this, loader, tooltip);
-  const h = this;
-  h._hrefHandler = listener(h, (evt, item) => {
-    if (item && item.href) h.handleHref(evt, item, item.href);
-  });
-  h._tooltipHandler = listener(h, (evt, item) => {
-    h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
-  });
-} // wrap an event listener for the SVG DOM
-
-const listener = (context, handler) => evt => {
-  let item = evt.target.__data__;
-  item = Array.isArray(item) ? item[0] : item;
-  evt.vegaType = evt.type;
-  handler.call(context._obj, evt, item);
-};
-
-inherits(SVGHandler, Handler, {
-  initialize(el, origin, obj) {
-    let svg = this._svg;
-
-    if (svg) {
-      svg.removeEventListener(HrefEvent, this._hrefHandler);
-      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
-      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
-    }
-
-    this._svg = svg = el && domFind(el, 'svg');
-
-    if (svg) {
-      svg.addEventListener(HrefEvent, this._hrefHandler);
-      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
-      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
-    }
-
-    return Handler.prototype.initialize.call(this, el, origin, obj);
-  },
-
-  canvas() {
-    return this._svg;
-  },
-
-  // add an event handler
-  on(type, handler) {
-    const name = this.eventName(type),
-          h = this._handlers,
-          i = this._handlerIndex(h[name], type, handler);
-
-    if (i < 0) {
-      const x = {
-        type,
-        handler,
-        listener: listener(this, handler)
-      };
-      (h[name] || (h[name] = [])).push(x);
-
-      if (this._svg) {
-        this._svg.addEventListener(name, x.listener);
-      }
-    }
-
-    return this;
-  },
-
-  // remove an event handler
-  off(type, handler) {
-    const name = this.eventName(type),
-          h = this._handlers[name],
-          i = this._handlerIndex(h, type, handler);
-
-    if (i >= 0) {
-      if (this._svg) {
-        this._svg.removeEventListener(name, h[i].listener);
-      }
-
-      h.splice(i, 1);
-    }
-
-    return this;
-  }
-
-});
-
-const ARIA_HIDDEN = 'aria-hidden';
-const ARIA_LABEL = 'aria-label';
-const ARIA_ROLE = 'role';
-const ARIA_ROLEDESCRIPTION = 'aria-roledescription';
-const GRAPHICS_OBJECT = 'graphics-object';
-const GRAPHICS_SYMBOL = 'graphics-symbol';
-
-const bundle = (role, roledesc, label) => ({
-  [ARIA_ROLE]: role,
-  [ARIA_ROLEDESCRIPTION]: roledesc,
-  [ARIA_LABEL]: label || undefined
-}); // these roles are covered by related roles
-// we can ignore them, no need to generate attributes
-
-
-const AriaIgnore = toSet(['axis-domain', 'axis-grid', 'axis-label', 'axis-tick', 'axis-title', 'legend-band', 'legend-entry', 'legend-gradient', 'legend-label', 'legend-title', 'legend-symbol', 'title']); // aria attribute generators for guide roles
-
-const AriaGuides = {
-  'axis': {
-    desc: 'axis',
-    caption: axisCaption
-  },
-  'legend': {
-    desc: 'legend',
-    caption: legendCaption
-  },
-  'title-text': {
-    desc: 'title',
-    caption: item => `Title text '${titleCaption(item)}'`
-  },
-  'title-subtitle': {
-    desc: 'subtitle',
-    caption: item => `Subtitle text '${titleCaption(item)}'`
-  }
-}; // aria properties generated for mark item encoding channels
-
-const AriaEncode = {
-  ariaRole: ARIA_ROLE,
-  ariaRoleDescription: ARIA_ROLEDESCRIPTION,
-  description: ARIA_LABEL
-};
-function ariaItemAttributes(emit, item) {
-  const hide = item.aria === false;
-  emit(ARIA_HIDDEN, hide || undefined);
-
-  if (hide || item.description == null) {
-    for (const prop in AriaEncode) {
-      emit(AriaEncode[prop], undefined);
-    }
-  } else {
-    const type = item.mark.marktype;
-    emit(ARIA_LABEL, item.description);
-    emit(ARIA_ROLE, item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
-    emit(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type} mark`);
-  }
-}
-function ariaMarkAttributes(mark) {
-  return mark.aria === false ? {
-    [ARIA_HIDDEN]: true
-  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);
-}
-
-function ariaMark(mark) {
-  const type = mark.marktype;
-  const recurse = type === 'group' || type === 'text' || mark.items.some(_ => _.description != null && _.aria !== false);
-  return bundle(recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type} mark container`, mark.description);
-}
-
-function ariaGuide(mark, opt) {
-  try {
-    const item = mark.items[0],
-          caption = opt.caption || (() => '');
-
-    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
-  } catch (err) {
-    return null;
-  }
-}
-
-function titleCaption(item) {
-  return array(item.text).join(' ');
-}
-
-function axisCaption(item) {
-  const datum = item.datum,
-        orient = item.orient,
-        title = datum.title ? extractTitle(item) : null,
-        ctx = item.context,
-        scale = ctx.scales[datum.scale].value,
-        locale = ctx.dataflow.locale(),
-        type = scale.type,
-        xy = orient === 'left' || orient === 'right' ? 'Y' : 'X';
-  return `${xy}-axis` + (title ? ` titled '${title}'` : '') + ` for a ${isDiscrete(type) ? 'discrete' : type} scale` + ` with ${domainCaption(locale, scale, item)}`;
-}
-
-function legendCaption(item) {
-  const datum = item.datum,
-        title = datum.title ? extractTitle(item) : null,
-        type = `${datum.type || ''} legend`.trim(),
-        scales = datum.scales,
-        props = Object.keys(scales),
-        ctx = item.context,
-        scale = ctx.scales[scales[props[0]]].value,
-        locale = ctx.dataflow.locale();
-  return capitalize(type) + (title ? ` titled '${title}'` : '') + ` for ${channelCaption(props)}` + ` with ${domainCaption(locale, scale, item)}`;
-}
-
-function extractTitle(item) {
-  try {
-    return array(peek(item.items).items[0].text).join(' ');
-  } catch (err) {
-    return null;
-  }
-}
-
-function channelCaption(props) {
-  props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));
-  return props.length < 2 ? props[0] : props.slice(0, -1).join(', ') + ' and ' + peek(props);
-}
-
-function capitalize(s) {
-  return s.length ? s[0].toUpperCase() + s.slice(1) : s;
-}
-
-const innerText = val => (val + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
-
-const attrText = val => innerText(val).replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
-
-function markup() {
-  let buf = '',
-      outer = '',
-      inner = '';
-
-  const stack = [],
-        clear = () => outer = inner = '',
-        push = tag => {
-    if (outer) {
-      buf += `${outer}>${inner}`;
-      clear();
-    }
-
-    stack.push(tag);
-  },
-        attr = (name, value) => {
-    if (value != null) outer += ` ${name}="${attrText(value)}"`;
-    return m;
-  },
-        m = {
-    open(tag, ...attrs) {
-      push(tag);
-      outer = '<' + tag;
-
-      for (const set of attrs) {
-        for (const key in set) attr(key, set[key]);
-      }
-
-      return m;
-    },
-
-    close() {
-      const tag = stack.pop();
-
-      if (outer) {
-        buf += outer + (inner ? `>${inner}</${tag}>` : '/>');
-      } else {
-        buf += `</${tag}>`;
-      }
-
-      clear();
-      return m;
-    },
-
-    attr,
-    text: t => (inner += innerText(t), m),
-    toString: () => buf
-  };
-
-  return m;
-}
-const serializeXML = node => _serialize(markup(), node) + '';
-
-function _serialize(m, node) {
-  m.open(node.tagName);
-
-  if (node.hasAttributes()) {
-    const attrs = node.attributes,
-          n = attrs.length;
-
-    for (let i = 0; i < n; ++i) {
-      m.attr(attrs[i].name, attrs[i].value);
-    }
-  }
-
-  if (node.hasChildNodes()) {
-    const children = node.childNodes,
-          n = children.length;
-
-    for (let i = 0; i < n; i++) {
-      const child = children[i];
-      child.nodeType === 3 // text node
-      ? m.text(child.nodeValue) : _serialize(m, child);
-    }
-  }
-
-  return m.close();
-}
-
-const styles = {
-  fill: 'fill',
-  fillOpacity: 'fill-opacity',
-  stroke: 'stroke',
-  strokeOpacity: 'stroke-opacity',
-  strokeWidth: 'stroke-width',
-  strokeCap: 'stroke-linecap',
-  strokeJoin: 'stroke-linejoin',
-  strokeDash: 'stroke-dasharray',
-  strokeDashOffset: 'stroke-dashoffset',
-  strokeMiterLimit: 'stroke-miterlimit',
-  opacity: 'opacity',
-  blend: 'mix-blend-mode'
-}; // ensure miter limit default is consistent with canvas (#2498)
-
-const rootAttributes = {
-  'fill': 'none',
-  'stroke-miterlimit': 10
-};
-
-const RootIndex = 0,
-      xmlns = 'http://www.w3.org/2000/xmlns/',
-      svgns = metadata.xmlns;
-function SVGRenderer(loader) {
-  Renderer.call(this, loader);
-  this._dirtyID = 0;
-  this._dirty = [];
-  this._svg = null;
-  this._root = null;
-  this._defs = null;
-}
-const base = Renderer.prototype;
-inherits(SVGRenderer, Renderer, {
-  /**
-   * Initialize a new SVGRenderer instance.
-   * @param {DOMElement} el - The containing DOM element for the display.
-   * @param {number} width - The coordinate width of the display, in pixels.
-   * @param {number} height - The coordinate height of the display, in pixels.
-   * @param {Array<number>} origin - The origin of the display, in pixels.
-   *   The coordinate system will be translated to this point.
-   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
-   *   the width and height to determine the final pixel size.
-   * @return {SVGRenderer} - This renderer instance.
-   */
-  initialize(el, width, height, origin, scaleFactor) {
-    // create the svg definitions cache
-    this._defs = {};
-
-    this._clearDefs();
-
-    if (el) {
-      this._svg = domChild(el, 0, 'svg', svgns);
-
-      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);
-
-      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);
-
-      this._svg.setAttribute('version', metadata['version']);
-
-      this._svg.setAttribute('class', 'marks');
-
-      domClear(el, 1); // set the svg root group
-
-      this._root = domChild(this._svg, RootIndex, 'g', svgns);
-      setAttributes(this._root, rootAttributes); // ensure no additional child elements
-
-      domClear(this._svg, RootIndex + 1);
-    } // set background color if defined
-
-
-    this.background(this._bgcolor);
-    return base.initialize.call(this, el, width, height, origin, scaleFactor);
-  },
-
-  /**
-   * Get / set the background color.
-   */
-  background(bgcolor) {
-    if (arguments.length && this._svg) {
-      this._svg.style.setProperty('background-color', bgcolor);
-    }
-
-    return base.background.apply(this, arguments);
-  },
-
-  /**
-   * Resize the display.
-   * @param {number} width - The new coordinate width of the display, in pixels.
-   * @param {number} height - The new coordinate height of the display, in pixels.
-   * @param {Array<number>} origin - The new origin of the display, in pixels.
-   *   The coordinate system will be translated to this point.
-   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
-   *   the width and height to determine the final pixel size.
-   * @return {SVGRenderer} - This renderer instance;
-   */
-  resize(width, height, origin, scaleFactor) {
-    base.resize.call(this, width, height, origin, scaleFactor);
-
-    if (this._svg) {
-      setAttributes(this._svg, {
-        width: this._width * this._scale,
-        height: this._height * this._scale,
-        viewBox: `0 0 ${this._width} ${this._height}`
-      });
-
-      this._root.setAttribute('transform', `translate(${this._origin})`);
-    }
-
-    this._dirty = [];
-    return this;
-  },
-
-  /**
-   * Returns the SVG element of the visualization.
-   * @return {DOMElement} - The SVG element.
-   */
-  canvas() {
-    return this._svg;
-  },
-
-  /**
-   * Returns an SVG text string for the rendered content,
-   * or null if this renderer is currently headless.
-   */
-  svg() {
-    const svg = this._svg,
-          bg = this._bgcolor;
-    if (!svg) return null;
-    let node;
-
-    if (bg) {
-      svg.removeAttribute('style');
-      node = domChild(svg, RootIndex, 'rect', svgns);
-      setAttributes(node, {
-        width: this._width,
-        height: this._height,
-        fill: bg
-      });
-    }
-
-    const text = serializeXML(svg);
-
-    if (bg) {
-      svg.removeChild(node);
-
-      this._svg.style.setProperty('background-color', bg);
-    }
-
-    return text;
-  },
-
-  /**
-   * Internal rendering method.
-   * @param {object} scene - The root mark of a scenegraph to render.
-   */
-  _render(scene) {
-    // perform spot updates and re-render markup
-    if (this._dirtyCheck()) {
-      if (this._dirtyAll) this._clearDefs();
-      this.mark(this._root, scene);
-      domClear(this._root, 1);
-    }
-
-    this.defs();
-    this._dirty = [];
-    ++this._dirtyID;
-    return this;
-  },
-
-  // -- Manage rendering of items marked as dirty --
-
-  /**
-   * Flag a mark item as dirty.
-   * @param {Item} item - The mark item.
-   */
-  dirty(item) {
-    if (item.dirty !== this._dirtyID) {
-      item.dirty = this._dirtyID;
-
-      this._dirty.push(item);
-    }
-  },
-
-  /**
-   * Check if a mark item is considered dirty.
-   * @param {Item} item - The mark item.
-   */
-  isDirty(item) {
-    return this._dirtyAll || !item._svg || item.dirty === this._dirtyID;
-  },
-
-  /**
-   * Internal method to check dirty status and, if possible,
-   * make targetted updates without a full rendering pass.
-   */
-  _dirtyCheck() {
-    this._dirtyAll = true;
-    const items = this._dirty;
-    if (!items.length || !this._dirtyID) return true;
-    const id = ++this._dirtyID;
-    let item, mark, type, mdef, i, n, o;
-
-    for (i = 0, n = items.length; i < n; ++i) {
-      item = items[i];
-      mark = item.mark;
-
-      if (mark.marktype !== type) {
-        // memoize mark instance lookup
-        type = mark.marktype;
-        mdef = Marks[type];
-      }
-
-      if (mark.zdirty && mark.dirty !== id) {
-        this._dirtyAll = false;
-        dirtyParents(item, id);
-        mark.items.forEach(i => {
-          i.dirty = id;
-        });
-      }
-
-      if (mark.zdirty) continue; // handle in standard drawing pass
-
-      if (item.exit) {
-        // EXIT
-        if (mdef.nested && mark.items.length) {
-          // if nested mark with remaining points, update instead
-          o = mark.items[0];
-          if (o._svg) this._update(mdef, o._svg, o);
-        } else if (item._svg) {
-          // otherwise remove from DOM
-          o = item._svg.parentNode;
-          if (o) o.removeChild(item._svg);
-        }
-
-        item._svg = null;
-        continue;
-      }
-
-      item = mdef.nested ? mark.items[0] : item;
-      if (item._update === id) continue; // already visited
-
-      if (!item._svg || !item._svg.ownerSVGElement) {
-        // ENTER
-        this._dirtyAll = false;
-        dirtyParents(item, id);
-      } else {
-        // IN-PLACE UPDATE
-        this._update(mdef, item._svg, item);
-      }
-
-      item._update = id;
-    }
-
-    return !this._dirtyAll;
-  },
-
-  // -- Construct & maintain scenegraph to SVG mapping ---
-
-  /**
-   * Render a set of mark items.
-   * @param {SVGElement} el - The parent element in the SVG tree.
-   * @param {object} scene - The mark parent to render.
-   * @param {SVGElement} prev - The previous sibling in the SVG tree.
-   */
-  mark(el, scene, prev) {
-    if (!this.isDirty(scene)) return scene._svg;
-    const svg = this._svg,
-          mdef = Marks[scene.marktype],
-          events = scene.interactive === false ? 'none' : null,
-          isGroup = mdef.tag === 'g';
-    let sibling = null,
-        i = 0;
-    const parent = bind(scene, el, prev, 'g', svg);
-    parent.setAttribute('class', cssClass(scene)); // apply aria attributes to parent container element
-
-    const aria = ariaMarkAttributes(scene);
-
-    for (const key in aria) setAttribute(parent, key, aria[key]);
-
-    if (!isGroup) {
-      setAttribute(parent, 'pointer-events', events);
-    }
-
-    setAttribute(parent, 'clip-path', scene.clip ? clip$1(this, scene, scene.group) : null);
-
-    const process = item => {
-      const dirty = this.isDirty(item),
-            node = bind(item, parent, sibling, mdef.tag, svg);
-
-      if (dirty) {
-        this._update(mdef, node, item);
-
-        if (isGroup) recurse(this, node, item);
-      }
-
-      sibling = node;
-      ++i;
-    };
-
-    if (mdef.nested) {
-      if (scene.items.length) process(scene.items[0]);
-    } else {
-      visit(scene, process);
-    }
-
-    domClear(parent, i);
-    return parent;
-  },
-
-  /**
-   * Update the attributes of an SVG element for a mark item.
-   * @param {object} mdef - The mark definition object
-   * @param {SVGElement} el - The SVG element.
-   * @param {Item} item - The mark item.
-   */
-  _update(mdef, el, item) {
-    // set dom element and values cache
-    // provides access to emit method
-    element = el;
-    values = el.__values__; // apply aria-specific properties
-
-    ariaItemAttributes(emit, item); // apply svg attributes
-
-    mdef.attr(emit, item, this); // some marks need special treatment
-
-    const extra = mark_extras[mdef.type];
-    if (extra) extra.call(this, mdef, el, item); // apply svg style attributes
-    // note: element state may have been modified by 'extra' method
-
-    if (element) this.style(element, item);
-  },
-
-  /**
-   * Update the presentation attributes of an SVG element for a mark item.
-   * @param {SVGElement} el - The SVG element.
-   * @param {Item} item - The mark item.
-   */
-  style(el, item) {
-    if (item == null) return;
-
-    for (const prop in styles) {
-      let value = prop === 'font' ? fontFamily(item) : item[prop];
-      if (value === values[prop]) continue;
-      const name = styles[prop];
-
-      if (value == null) {
-        el.removeAttribute(name);
-      } else {
-        if (isGradient(value)) {
-          value = gradientRef(value, this._defs.gradient, href());
-        }
-
-        el.setAttribute(name, value + '');
-      }
-
-      values[prop] = value;
-    }
-  },
-
-  /**
-   * Render SVG defs, as needed.
-   * Must be called *after* marks have been processed to ensure the
-   * collected state is current and accurate.
-   */
-  defs() {
-    const svg = this._svg,
-          defs = this._defs;
-    let el = defs.el,
-        index = 0;
-
-    for (const id in defs.gradient) {
-      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);
-      index = updateGradient(el, defs.gradient[id], index);
-    }
-
-    for (const id in defs.clipping) {
-      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);
-      index = updateClipping(el, defs.clipping[id], index);
-    } // clean-up
-
-
-    if (el) {
-      index === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index);
-    }
-  },
-
-  /**
-   * Clear defs caches.
-   */
-  _clearDefs() {
-    const def = this._defs;
-    def.gradient = {};
-    def.clipping = {};
-  }
-
-}); // mark ancestor chain with a dirty id
-
-function dirtyParents(item, id) {
-  for (; item && item.dirty !== id; item = item.mark.group) {
-    item.dirty = id;
-
-    if (item.mark && item.mark.dirty !== id) {
-      item.mark.dirty = id;
-    } else return;
-  }
-} // update gradient definitions
-
-
-function updateGradient(el, grad, index) {
-  let i, n, stop;
-
-  if (grad.gradient === 'radial') {
-    // SVG radial gradients automatically transform to normalized bbox
-    // coordinates, in a way that is cumbersome to replicate in canvas.
-    // We wrap the radial gradient in a pattern element, allowing us to
-    // maintain a circular gradient that matches what canvas provides.
-    let pt = domChild(el, index++, 'pattern', svgns);
-    setAttributes(pt, {
-      id: patternPrefix + grad.id,
-      viewBox: '0,0,1,1',
-      width: '100%',
-      height: '100%',
-      preserveAspectRatio: 'xMidYMid slice'
-    });
-    pt = domChild(pt, 0, 'rect', svgns);
-    setAttributes(pt, {
-      width: 1,
-      height: 1,
-      fill: `url(${href()}#${grad.id})`
-    });
-    el = domChild(el, index++, 'radialGradient', svgns);
-    setAttributes(el, {
-      id: grad.id,
-      fx: grad.x1,
-      fy: grad.y1,
-      fr: grad.r1,
-      cx: grad.x2,
-      cy: grad.y2,
-      r: grad.r2
-    });
-  } else {
-    el = domChild(el, index++, 'linearGradient', svgns);
-    setAttributes(el, {
-      id: grad.id,
-      x1: grad.x1,
-      x2: grad.x2,
-      y1: grad.y1,
-      y2: grad.y2
-    });
-  }
-
-  for (i = 0, n = grad.stops.length; i < n; ++i) {
-    stop = domChild(el, i, 'stop', svgns);
-    stop.setAttribute('offset', grad.stops[i].offset);
-    stop.setAttribute('stop-color', grad.stops[i].color);
-  }
-
-  domClear(el, i);
-  return index;
-} // update clipping path definitions
-
-
-function updateClipping(el, clip, index) {
-  let mask;
-  el = domChild(el, index, 'clipPath', svgns);
-  el.setAttribute('id', clip.id);
-
-  if (clip.path) {
-    mask = domChild(el, 0, 'path', svgns);
-    mask.setAttribute('d', clip.path);
-  } else {
-    mask = domChild(el, 0, 'rect', svgns);
-    setAttributes(mask, {
-      x: 0,
-      y: 0,
-      width: clip.width,
-      height: clip.height
-    });
-  }
-
-  domClear(el, 1);
-  return index + 1;
-} // Recursively process group contents.
-
-
-function recurse(renderer, el, group) {
-  el = el.lastChild.previousSibling;
-  let prev,
-      idx = 0;
-  visit(group, item => {
-    prev = renderer.mark(el, item, prev);
-    ++idx;
-  }); // remove any extraneous DOM elements
-
-  domClear(el, 1 + idx);
-} // Bind a scenegraph item to an SVG DOM element.
-// Create new SVG elements as needed.
-
-
-function bind(item, el, sibling, tag, svg) {
-  let node = item._svg,
-      doc; // create a new dom node if needed
-
-  if (!node) {
-    doc = el.ownerDocument;
-    node = domCreate(doc, tag, svgns);
-    item._svg = node;
-
-    if (item.mark) {
-      node.__data__ = item;
-      node.__values__ = {
-        fill: 'default'
-      }; // if group, create background, content, and foreground elements
-
-      if (tag === 'g') {
-        const bg = domCreate(doc, 'path', svgns);
-        node.appendChild(bg);
-        bg.__data__ = item;
-        const cg = domCreate(doc, 'g', svgns);
-        node.appendChild(cg);
-        cg.__data__ = item;
-        const fg = domCreate(doc, 'path', svgns);
-        node.appendChild(fg);
-        fg.__data__ = item;
-        fg.__values__ = {
-          fill: 'default'
-        };
-      }
-    }
-  } // (re-)insert if (a) not contained in SVG or (b) sibling order has changed
-
-
-  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
-    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
-  }
-
-  return node;
-} // check if two nodes are ordered siblings
-
-
-function siblingCheck(node, sibling) {
-  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same
-} // -- Set attributes & styles on SVG elements ---
-
-
-let element = null,
-    // temp var for current SVG element
-values = null; // temp var for current values hash
-// Extra configuration for certain mark types
-
-const mark_extras = {
-  group(mdef, el, item) {
-    const fg = element = el.childNodes[2];
-    values = fg.__values__;
-    mdef.foreground(emit, item, this);
-    values = el.__values__; // use parent's values hash
-
-    element = el.childNodes[1];
-    mdef.content(emit, item, this);
-    const bg = element = el.childNodes[0];
-    mdef.background(emit, item, this);
-    const value = item.mark.interactive === false ? 'none' : null;
-
-    if (value !== values.events) {
-      setAttribute(fg, 'pointer-events', value);
-      setAttribute(bg, 'pointer-events', value);
-      values.events = value;
-    }
-
-    if (item.strokeForeground && item.stroke) {
-      const fill = item.fill;
-      setAttribute(fg, 'display', null); // set style of background
-
-      this.style(bg, item);
-      setAttribute(bg, 'stroke', null); // set style of foreground
-
-      if (fill) item.fill = null;
-      values = fg.__values__;
-      this.style(fg, item);
-      if (fill) item.fill = fill; // leave element null to prevent downstream styling
-
-      element = null;
-    } else {
-      // ensure foreground is ignored
-      setAttribute(fg, 'display', 'none');
-    }
-  },
-
-  image(mdef, el, item) {
-    if (item.smooth === false) {
-      setStyle(el, 'image-rendering', 'optimizeSpeed');
-      setStyle(el, 'image-rendering', 'pixelated');
-    } else {
-      setStyle(el, 'image-rendering', null);
-    }
-  },
-
-  text(mdef, el, item) {
-    const tl = textLines(item);
-    let key, value, doc, lh;
-
-    if (isArray(tl)) {
-      // multi-line text
-      value = tl.map(_ => textValue(item, _));
-      key = value.join('\n'); // content cache key
-
-      if (key !== values.text) {
-        domClear(el, 0);
-        doc = el.ownerDocument;
-        lh = lineHeight(item);
-        value.forEach((t, i) => {
-          const ts = domCreate(doc, 'tspan', svgns);
-          ts.__data__ = item; // data binding
-
-          ts.textContent = t;
-
-          if (i) {
-            ts.setAttribute('x', 0);
-            ts.setAttribute('dy', lh);
-          }
-
-          el.appendChild(ts);
-        });
-        values.text = key;
-      }
-    } else {
-      // single-line text
-      value = textValue(item, tl);
-
-      if (value !== values.text) {
-        el.textContent = value;
-        values.text = value;
-      }
-    }
-
-    setAttribute(el, 'font-family', fontFamily(item));
-    setAttribute(el, 'font-size', fontSize(item) + 'px');
-    setAttribute(el, 'font-style', item.fontStyle);
-    setAttribute(el, 'font-variant', item.fontVariant);
-    setAttribute(el, 'font-weight', item.fontWeight);
-  }
-
-};
-
-function emit(name, value, ns) {
-  // early exit if value is unchanged
-  if (value === values[name]) return; // use appropriate method given namespace (ns)
-
-  if (ns) {
-    setAttributeNS(element, name, value, ns);
-  } else {
-    setAttribute(element, name, value);
-  } // note current value for future comparison
-
-
-  values[name] = value;
-}
-
-function setStyle(el, name, value) {
-  if (value !== values[name]) {
-    if (value == null) {
-      el.style.removeProperty(name);
-    } else {
-      el.style.setProperty(name, value + '');
-    }
-
-    values[name] = value;
-  }
-}
-
-function setAttributes(el, attrs) {
-  for (const key in attrs) {
-    setAttribute(el, key, attrs[key]);
-  }
-}
-
-function setAttribute(el, name, value) {
-  if (value != null) {
-    // if value is provided, update DOM attribute
-    el.setAttribute(name, value);
-  } else {
-    // else remove DOM attribute
-    el.removeAttribute(name);
-  }
-}
-
-function setAttributeNS(el, name, value, ns) {
-  if (value != null) {
-    // if value is provided, update DOM attribute
-    el.setAttributeNS(ns, name, value);
-  } else {
-    // else remove DOM attribute
-    el.removeAttributeNS(ns, name);
-  }
-}
-
-function href() {
-  let loc;
-  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
-}
-
-function SVGStringRenderer(loader) {
-  Renderer.call(this, loader);
-  this._text = null;
-  this._defs = {
-    gradient: {},
-    clipping: {}
-  };
-}
-inherits(SVGStringRenderer, Renderer, {
-  /**
-   * Returns the rendered SVG text string,
-   * or null if rendering has not yet occurred.
-   */
-  svg() {
-    return this._text;
-  },
-
-  /**
-   * Internal rendering method.
-   * @param {object} scene - The root mark of a scenegraph to render.
-   */
-  _render(scene) {
-    const m = markup(); // svg tag
-
-    m.open('svg', extend({}, metadata, {
-      class: 'marks',
-      width: this._width * this._scale,
-      height: this._height * this._scale,
-      viewBox: `0 0 ${this._width} ${this._height}`
-    })); // background, if defined
-
-    const bg = this._bgcolor;
-
-    if (bg && bg !== 'transparent' && bg !== 'none') {
-      m.open('rect', {
-        width: this._width,
-        height: this._height,
-        fill: bg
-      }).close();
-    } // root content group
-
-
-    m.open('g', rootAttributes, {
-      transform: 'translate(' + this._origin + ')'
-    });
-    this.mark(m, scene);
-    m.close(); // </g>
-    // defs
-
-    this.defs(m); // get SVG text string
-
-    this._text = m.close() + '';
-    return this;
-  },
-
-  /**
-   * Render a set of mark items.
-   * @param {object} m - The markup context.
-   * @param {object} scene - The mark parent to render.
-   */
-  mark(m, scene) {
-    const mdef = Marks[scene.marktype],
-          tag = mdef.tag,
-          attrList = [ariaItemAttributes, mdef.attr]; // render opening group tag
-
-    m.open('g', {
-      'class': cssClass(scene),
-      'clip-path': scene.clip ? clip$1(this, scene, scene.group) : null
-    }, ariaMarkAttributes(scene), {
-      'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null
-    }); // render contained elements
-
-    const process = item => {
-      const href = this.href(item);
-      if (href) m.open('a', href);
-      m.open(tag, this.attr(scene, item, attrList, tag !== 'g' ? tag : null));
-
-      if (tag === 'text') {
-        const tl = textLines(item);
-
-        if (isArray(tl)) {
-          // multi-line text
-          const attrs = {
-            x: 0,
-            dy: lineHeight(item)
-          };
-
-          for (let i = 0; i < tl.length; ++i) {
-            m.open('tspan', i ? attrs : null).text(textValue(item, tl[i])).close();
-          }
-        } else {
-          // single-line text
-          m.text(textValue(item, tl));
-        }
-      } else if (tag === 'g') {
-        const fore = item.strokeForeground,
-              fill = item.fill,
-              stroke = item.stroke;
-
-        if (fore && stroke) {
-          item.stroke = null;
-        }
-
-        m.open('path', this.attr(scene, item, mdef.background, 'bgrect')).close(); // recurse for group content
-
-        m.open('g', this.attr(scene, item, mdef.content));
-        visit(item, scene => this.mark(m, scene));
-        m.close();
-
-        if (fore && stroke) {
-          if (fill) item.fill = null;
-          item.stroke = stroke;
-          m.open('path', this.attr(scene, item, mdef.foreground, 'bgrect')).close();
-          if (fill) item.fill = fill;
-        } else {
-          m.open('path', this.attr(scene, item, mdef.foreground, 'bgfore')).close();
-        }
-      }
-
-      m.close(); // </tag>
-
-      if (href) m.close(); // </a>
-    };
-
-    if (mdef.nested) {
-      if (scene.items && scene.items.length) process(scene.items[0]);
-    } else {
-      visit(scene, process);
-    } // render closing group tag
-
-
-    return m.close(); // </g>
-  },
-
-  /**
-   * Get href attributes for a hyperlinked mark item.
-   * @param {Item} item - The mark item.
-   */
-  href(item) {
-    const href = item.href;
-    let attr;
-
-    if (href) {
-      if (attr = this._hrefs && this._hrefs[href]) {
-        return attr;
-      } else {
-        this.sanitizeURL(href).then(attr => {
-          // rewrite to use xlink namespace
-          attr['xlink:href'] = attr.href;
-          attr.href = null;
-          (this._hrefs || (this._hrefs = {}))[href] = attr;
-        });
-      }
-    }
-
-    return null;
-  },
-
-  /**
-   * Get an object of SVG attributes for a mark item.
-   * @param {object} scene - The mark parent.
-   * @param {Item} item - The mark item.
-   * @param {array|function} attrs - One or more attribute emitters.
-   * @param {string} tag - The tag being rendered.
-   */
-  attr(scene, item, attrs, tag) {
-    const object = {},
-          emit = (name, value, ns, prefixed) => {
-      object[prefixed || name] = value;
-    }; // apply mark specific attributes
-
-
-    if (Array.isArray(attrs)) {
-      attrs.forEach(fn => fn(emit, item, this));
-    } else {
-      attrs(emit, item, this);
-    } // apply style attributes
-
-
-    if (tag) {
-      style(object, item, scene, tag, this._defs);
-    }
-
-    return object;
-  },
-
-  /**
-   * Render SVG defs, as needed.
-   * Must be called *after* marks have been processed to ensure the
-   * collected state is current and accurate.
-   * @param {object} m - The markup context.
-   */
-  defs(m) {
-    const gradient = this._defs.gradient,
-          clipping = this._defs.clipping,
-          count = Object.keys(gradient).length + Object.keys(clipping).length;
-    if (count === 0) return; // nothing to do
-
-    m.open('defs');
-
-    for (const id in gradient) {
-      const def = gradient[id],
-            stops = def.stops;
-
-      if (def.gradient === 'radial') {
-        // SVG radial gradients automatically transform to normalized bbox
-        // coordinates, in a way that is cumbersome to replicate in canvas.
-        // We wrap the radial gradient in a pattern element, allowing us to
-        // maintain a circular gradient that matches what canvas provides.
-        m.open('pattern', {
-          id: patternPrefix + id,
-          viewBox: '0,0,1,1',
-          width: '100%',
-          height: '100%',
-          preserveAspectRatio: 'xMidYMid slice'
-        });
-        m.open('rect', {
-          width: '1',
-          height: '1',
-          fill: 'url(#' + id + ')'
-        }).close();
-        m.close(); // </pattern>
-
-        m.open('radialGradient', {
-          id: id,
-          fx: def.x1,
-          fy: def.y1,
-          fr: def.r1,
-          cx: def.x2,
-          cy: def.y2,
-          r: def.r2
-        });
-      } else {
-        m.open('linearGradient', {
-          id: id,
-          x1: def.x1,
-          x2: def.x2,
-          y1: def.y1,
-          y2: def.y2
-        });
-      }
-
-      for (let i = 0; i < stops.length; ++i) {
-        m.open('stop', {
-          offset: stops[i].offset,
-          'stop-color': stops[i].color
-        }).close();
-      }
-
-      m.close();
-    }
-
-    for (const id in clipping) {
-      const def = clipping[id];
-      m.open('clipPath', {
-        id: id
-      });
-
-      if (def.path) {
-        m.open('path', {
-          d: def.path
-        }).close();
-      } else {
-        m.open('rect', {
-          x: 0,
-          y: 0,
-          width: def.width,
-          height: def.height
-        }).close();
-      }
-
-      m.close();
-    }
-
-    m.close();
-  }
-
-}); // Helper function for attr for style presentation attributes
-
-function style(s, item, scene, tag, defs) {
-  if (item == null) return s;
-
-  if (tag === 'bgrect' && scene.interactive === false) {
-    s['pointer-events'] = 'none';
-  }
-
-  if (tag === 'bgfore') {
-    if (scene.interactive === false) {
-      s['pointer-events'] = 'none';
-    }
-
-    s.display = 'none';
-    if (item.fill !== null) return s;
-  }
-
-  if (tag === 'image' && item.smooth === false) {
-    s.style = 'image-rendering: optimizeSpeed; image-rendering: pixelated;';
-  }
-
-  if (tag === 'text') {
-    s['font-family'] = fontFamily(item);
-    s['font-size'] = fontSize(item) + 'px';
-    s['font-style'] = item.fontStyle;
-    s['font-variant'] = item.fontVariant;
-    s['font-weight'] = item.fontWeight;
-  }
-
-  for (const prop in styles) {
-    let value = item[prop];
-    const name = styles[prop];
-
-    if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ; else if (value != null) {
-      if (isGradient(value)) {
-        value = gradientRef(value, defs.gradient, '');
-      }
-
-      s[name] = value;
-    }
-  }
-
-  return s;
-}
-
-const Canvas = 'canvas';
-const PNG = 'png';
-const SVG = 'svg';
-const None = 'none';
-const RenderType = {
-  Canvas: Canvas,
-  PNG: PNG,
-  SVG: SVG,
-  None: None
-};
-const modules = {};
-modules[Canvas] = modules[PNG] = {
-  renderer: CanvasRenderer,
-  headless: CanvasRenderer,
-  handler: CanvasHandler
-};
-modules[SVG] = {
-  renderer: SVGRenderer,
-  headless: SVGStringRenderer,
-  handler: SVGHandler
-};
-modules[None] = {};
-function renderModule(name, _) {
-  name = String(name || '').toLowerCase();
-
-  if (arguments.length > 1) {
-    modules[name] = _;
-    return this;
-  } else {
-    return modules[name];
-  }
-}
-
-function intersect(scene, bounds, filter) {
-  const hits = [],
-        // intersection results
-  box = new Bounds().union(bounds),
-        // defensive copy
-  type = scene.marktype;
-  return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : error('Intersect scene must be mark node or group item.');
-}
-
-function intersectMark(mark, box, filter, hits) {
-  if (visitMark(mark, box, filter)) {
-    const items = mark.items,
-          type = mark.marktype,
-          n = items.length;
-    let i = 0;
-
-    if (type === 'group') {
-      for (; i < n; ++i) {
-        intersectGroup(items[i], box, filter, hits);
-      }
-    } else {
-      for (const test = Marks[type].isect; i < n; ++i) {
-        const item = items[i];
-        if (intersectItem(item, box, test)) hits.push(item);
-      }
-    }
-  }
-
-  return hits;
-}
-
-function visitMark(mark, box, filter) {
-  // process if bounds intersect and if
-  // (1) mark is a group mark (so we must recurse), or
-  // (2) mark is interactive and passes filter
-  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));
-}
-
-function intersectGroup(group, box, filter, hits) {
-  // test intersect against group
-  // skip groups by default unless filter says otherwise
-  if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {
-    hits.push(group);
-  } // recursively test children marks
-  // translate box to group coordinate space
-
-
-  const marks = group.items,
-        n = marks && marks.length;
-
-  if (n) {
-    const x = group.x || 0,
-          y = group.y || 0;
-    box.translate(-x, -y);
-
-    for (let i = 0; i < n; ++i) {
-      intersectMark(marks[i], box, filter, hits);
-    }
-
-    box.translate(x, y);
-  }
-
-  return hits;
-}
-
-function intersectItem(item, box, test) {
-  // test bounds enclosure, bounds intersection, then detailed test
-  const bounds = item.bounds;
-  return box.encloses(bounds) || box.intersects(bounds) && test(item, box);
-}
-
-const clipBounds = new Bounds();
-function boundClip (mark) {
-  const clip = mark.clip;
-
-  if (isFunction(clip)) {
-    clip(boundContext(clipBounds.clear()));
-  } else if (clip) {
-    clipBounds.set(0, 0, mark.group.width, mark.group.height);
-  } else return;
-
-  mark.bounds.intersect(clipBounds);
-}
-
-const TOLERANCE = 1e-9;
-function sceneEqual(a, b, key) {
-  return a === b ? true : key === 'path' ? pathEqual(a, b) : a instanceof Date && b instanceof Date ? +a === +b : isNumber(a) && isNumber(b) ? Math.abs(a - b) <= TOLERANCE : !a || !b || !isObject(a) && !isObject(b) ? a == b : objectEqual(a, b);
-}
-function pathEqual(a, b) {
-  return sceneEqual(pathParse(a), pathParse(b));
-}
-
-function objectEqual(a, b) {
-  var ka = Object.keys(a),
-      kb = Object.keys(b),
-      key,
-      i;
-  if (ka.length !== kb.length) return false;
-  ka.sort();
-  kb.sort();
-
-  for (i = ka.length - 1; i >= 0; i--) {
-    if (ka[i] != kb[i]) return false;
-  }
-
-  for (i = ka.length - 1; i >= 0; i--) {
-    key = ka[i];
-    if (!sceneEqual(a[key], b[key], key)) return false;
-  }
-
-  return typeof a === typeof b;
-}
-
-function resetSVGDefIds() {
-  resetSVGClipId();
-  resetSVGGradientId();
-}
-
-export { Bounds, CanvasHandler, CanvasRenderer, Gradient, GroupItem, Handler, Item, Marks, RenderType, Renderer, ResourceLoader, SVGHandler, SVGRenderer, SVGStringRenderer, Scenegraph, boundClip, boundContext, boundItem, boundMark, boundStroke, domChild, domClear, domCreate, domFind, font, fontFamily, fontSize, intersect, intersectBoxLine, intersectPath, intersectPoint, intersectRule, lineHeight, markup, multiLineOffset, curves as pathCurves, pathEqual, pathParse, vg_rect as pathRectangle, pathRender, symbols as pathSymbols, vg_trail as pathTrail, point, renderModule, resetSVGClipId, resetSVGDefIds, sceneEqual, sceneFromJSON, pickVisit as scenePickVisit, sceneToJSON, visit as sceneVisit, zorder as sceneZOrder, serializeXML, textMetrics };
diff --git a/node_modules/vega-scenegraph/package-lock.json b/node_modules/vega-scenegraph/package-lock.json
new file mode 100644
index 0000000..7d0fa18
--- /dev/null
+++ b/node_modules/vega-scenegraph/package-lock.json
@@ -0,0 +1,439 @@
+{
+  "name": "vega-scenegraph",
+  "version": "4.9.4",
+  "lockfileVersion": 2,
+  "requires": true,
+  "packages": {
+    "": {
+      "name": "vega-scenegraph",
+      "version": "4.9.4",
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "d3-path": "^2.0.0",
+        "d3-shape": "^2.0.0",
+        "vega-canvas": "^1.2.5",
+        "vega-loader": "^4.3.3",
+        "vega-scale": "^7.1.1",
+        "vega-util": "^1.15.2"
+      }
+    },
+    "node_modules/commander": {
+      "version": "2.20.3",
+      "resolved": "https://registry.npmmirror.com/commander/-/commander-2.20.3.tgz",
+      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ=="
+    },
+    "node_modules/d3-array": {
+      "version": "2.12.1",
+      "resolved": "https://registry.npmmirror.com/d3-array/-/d3-array-2.12.1.tgz",
+      "integrity": "sha512-B0ErZK/66mHtEsR1TkPEEkwdy+WDesimkM5gpZr5Dsg54BiTA5RXtYW5qTLIAcekaS9xfZrzBLF/OAkB3Qn1YQ==",
+      "dependencies": {
+        "internmap": "^1.0.0"
+      }
+    },
+    "node_modules/d3-color": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmmirror.com/d3-color/-/d3-color-2.0.0.tgz",
+      "integrity": "sha512-SPXi0TSKPD4g9tw0NMZFnR95XVgUZiBH+uUTqQuDu1OsE2zomHU7ho0FISciaPvosimixwHFl3WHLGabv6dDgQ=="
+    },
+    "node_modules/d3-dsv": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmmirror.com/d3-dsv/-/d3-dsv-2.0.0.tgz",
+      "integrity": "sha512-E+Pn8UJYx9mViuIUkoc93gJGGYut6mSDKy2+XaPwccwkRGlR+LO97L2VCCRjQivTwLHkSnAJG7yo00BWY6QM+w==",
+      "dependencies": {
+        "commander": "2",
+        "iconv-lite": "0.4",
+        "rw": "1"
+      },
+      "bin": {
+        "csv2json": "bin/dsv2json",
+        "csv2tsv": "bin/dsv2dsv",
+        "dsv2dsv": "bin/dsv2dsv",
+        "dsv2json": "bin/dsv2json",
+        "json2csv": "bin/json2dsv",
+        "json2dsv": "bin/json2dsv",
+        "json2tsv": "bin/json2dsv",
+        "tsv2csv": "bin/dsv2dsv",
+        "tsv2json": "bin/dsv2json"
+      }
+    },
+    "node_modules/d3-format": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmmirror.com/d3-format/-/d3-format-2.0.0.tgz",
+      "integrity": "sha512-Ab3S6XuE/Q+flY96HXT0jOXcM4EAClYFnRGY5zsjRGNy6qCYrQsMffs7cV5Q9xejb35zxW5hf/guKw34kvIKsA=="
+    },
+    "node_modules/d3-interpolate": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmmirror.com/d3-interpolate/-/d3-interpolate-2.0.1.tgz",
+      "integrity": "sha512-c5UhwwTs/yybcmTpAVqwSFl6vrQ8JZJoT5F7xNFK9pymv5C0Ymcc9/LIJHtYIggg/yS9YHw8i8O8tgb9pupjeQ==",
+      "dependencies": {
+        "d3-color": "1 - 2"
+      }
+    },
+    "node_modules/d3-path": {
+      "version": "2.0.0",
+      "license": "BSD-3-Clause"
+    },
+    "node_modules/d3-scale": {
+      "version": "3.3.0",
+      "resolved": "https://registry.npmmirror.com/d3-scale/-/d3-scale-3.3.0.tgz",
+      "integrity": "sha512-1JGp44NQCt5d1g+Yy+GeOnZP7xHo0ii8zsQp6PGzd+C1/dl0KGsp9A7Mxwp+1D1o4unbTTxVdU/ZOIEBoeZPbQ==",
+      "dependencies": {
+        "d3-array": "^2.3.0",
+        "d3-format": "1 - 2",
+        "d3-interpolate": "1.2.0 - 2",
+        "d3-time": "^2.1.1",
+        "d3-time-format": "2 - 3"
+      }
+    },
+    "node_modules/d3-shape": {
+      "version": "2.1.0",
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "d3-path": "1 - 2"
+      }
+    },
+    "node_modules/d3-time": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmmirror.com/d3-time/-/d3-time-2.1.1.tgz",
+      "integrity": "sha512-/eIQe/eR4kCQwq7yxi7z4c6qEXf2IYGcjoWB5OOQy4Tq9Uv39/947qlDcN2TLkiTzQWzvnsuYPB9TrWaNfipKQ==",
+      "dependencies": {
+        "d3-array": "2"
+      }
+    },
+    "node_modules/d3-time-format": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmmirror.com/d3-time-format/-/d3-time-format-3.0.0.tgz",
+      "integrity": "sha512-UXJh6EKsHBTjopVqZBhFysQcoXSv/5yLONZvkQ5Kk3qbwiUYkdX17Xa1PT6U1ZWXGGfB1ey5L8dKMlFq2DO0Ag==",
+      "dependencies": {
+        "d3-time": "1 - 2"
+      }
+    },
+    "node_modules/iconv-lite": {
+      "version": "0.4.24",
+      "resolved": "https://registry.npmmirror.com/iconv-lite/-/iconv-lite-0.4.24.tgz",
+      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
+      "dependencies": {
+        "safer-buffer": ">= 2.1.2 < 3"
+      },
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/internmap": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmmirror.com/internmap/-/internmap-1.0.1.tgz",
+      "integrity": "sha512-lDB5YccMydFBtasVtxnZ3MRBHuaoE8GKsppq+EchKL2U4nK/DmEpPHNH8MZe5HkMtpSiTSOZwfN0tzYjO/lJEw=="
+    },
+    "node_modules/node-fetch": {
+      "version": "2.6.7",
+      "resolved": "https://registry.npmmirror.com/node-fetch/-/node-fetch-2.6.7.tgz",
+      "integrity": "sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==",
+      "dependencies": {
+        "whatwg-url": "^5.0.0"
+      },
+      "engines": {
+        "node": "4.x || >=6.0.0"
+      },
+      "peerDependencies": {
+        "encoding": "^0.1.0"
+      },
+      "peerDependenciesMeta": {
+        "encoding": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/rw": {
+      "version": "1.3.3",
+      "resolved": "https://registry.npmmirror.com/rw/-/rw-1.3.3.tgz",
+      "integrity": "sha512-PdhdWy89SiZogBLaw42zdeqtRJ//zFd2PgQavcICDUgJT5oW10QCRKbJ6bg4r0/UY2M6BWd5tkxuGFRvCkgfHQ=="
+    },
+    "node_modules/safer-buffer": {
+      "version": "2.1.2",
+      "resolved": "https://registry.npmmirror.com/safer-buffer/-/safer-buffer-2.1.2.tgz",
+      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
+    },
+    "node_modules/topojson-client": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmmirror.com/topojson-client/-/topojson-client-3.1.0.tgz",
+      "integrity": "sha512-605uxS6bcYxGXw9qi62XyrV6Q3xwbndjachmNxu8HWTtVPxZfEJN9fd/SZS1Q54Sn2y0TMyMxFj/cJINqGHrKw==",
+      "dependencies": {
+        "commander": "2"
+      },
+      "bin": {
+        "topo2geo": "bin/topo2geo",
+        "topomerge": "bin/topomerge",
+        "topoquantize": "bin/topoquantize"
+      }
+    },
+    "node_modules/tr46": {
+      "version": "0.0.3",
+      "resolved": "https://registry.npmmirror.com/tr46/-/tr46-0.0.3.tgz",
+      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
+    },
+    "node_modules/vega-canvas": {
+      "version": "1.2.6",
+      "resolved": "https://registry.npmmirror.com/vega-canvas/-/vega-canvas-1.2.6.tgz",
+      "integrity": "sha512-rgeYUpslYn/amIfnuv3Sw6n4BGns94OjjZNtUc9IDji6b+K8LGS/kW+Lvay8JX/oFqtulBp8RLcHN6QjqPLA9Q=="
+    },
+    "node_modules/vega-format": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmmirror.com/vega-format/-/vega-format-1.0.4.tgz",
+      "integrity": "sha512-oTAeub3KWm6nKhXoYCx1q9G3K43R6/pDMXvqDlTSUtjoY7b/Gixm8iLcir5S9bPjvH40n4AcbZsPmNfL/Up77A==",
+      "dependencies": {
+        "d3-array": "^2.7.1",
+        "d3-format": "^2.0.0",
+        "d3-time-format": "^3.0.0",
+        "vega-time": "^2.0.3",
+        "vega-util": "^1.15.2"
+      }
+    },
+    "node_modules/vega-loader": {
+      "version": "4.4.1",
+      "resolved": "https://registry.npmmirror.com/vega-loader/-/vega-loader-4.4.1.tgz",
+      "integrity": "sha512-dj65i4qlNhK0mOmjuchHgUrF5YUaWrYpx0A8kXA68lBk5Hkx8FNRztkcl07CZJ1+8V81ymEyJii9jzGbhEX0ag==",
+      "dependencies": {
+        "d3-dsv": "^2.0.0",
+        "node-fetch": "^2.6.1",
+        "topojson-client": "^3.1.0",
+        "vega-format": "^1.0.4",
+        "vega-util": "^1.16.0"
+      }
+    },
+    "node_modules/vega-scale": {
+      "version": "7.1.1",
+      "resolved": "https://registry.npmmirror.com/vega-scale/-/vega-scale-7.1.1.tgz",
+      "integrity": "sha512-yE0to0prA9E5PBJ/XP77TO0BMkzyUVyt7TH5PAwj+CZT7PMsMO6ozihelRhoIiVcP0Ae/ByCEQBUQkzN5zJ0ZA==",
+      "dependencies": {
+        "d3-array": "^2.7.1",
+        "d3-interpolate": "^2.0.1",
+        "d3-scale": "^3.2.2",
+        "vega-time": "^2.0.4",
+        "vega-util": "^1.15.2"
+      }
+    },
+    "node_modules/vega-time": {
+      "version": "2.0.4",
+      "resolved": "https://registry.npmmirror.com/vega-time/-/vega-time-2.0.4.tgz",
+      "integrity": "sha512-U314UDR9+ZlWrD3KBaeH+j/c2WSMdvcZq5yJfFT0yTg1jsBKAQBYFGvl+orackD8Zx3FveHOxx3XAObaQeDX+Q==",
+      "dependencies": {
+        "d3-array": "^2.7.1",
+        "d3-time": "^2.0.0",
+        "vega-util": "^1.15.2"
+      }
+    },
+    "node_modules/vega-util": {
+      "version": "1.17.0",
+      "resolved": "https://registry.npmmirror.com/vega-util/-/vega-util-1.17.0.tgz",
+      "integrity": "sha512-HTaydZd9De3yf+8jH66zL4dXJ1d1p5OIFyoBzFiOli4IJbwkL1jrefCKz6AHDm1kYBzDJ0X4bN+CzZSCTvNk1w=="
+    },
+    "node_modules/webidl-conversions": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmmirror.com/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
+      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
+    },
+    "node_modules/whatwg-url": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmmirror.com/whatwg-url/-/whatwg-url-5.0.0.tgz",
+      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
+      "dependencies": {
+        "tr46": "~0.0.3",
+        "webidl-conversions": "^3.0.0"
+      }
+    }
+  },
+  "dependencies": {
+    "commander": {
+      "version": "2.20.3",
+      "resolved": "https://registry.npmmirror.com/commander/-/commander-2.20.3.tgz",
+      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ=="
+    },
+    "d3-array": {
+      "version": "2.12.1",
+      "resolved": "https://registry.npmmirror.com/d3-array/-/d3-array-2.12.1.tgz",
+      "integrity": "sha512-B0ErZK/66mHtEsR1TkPEEkwdy+WDesimkM5gpZr5Dsg54BiTA5RXtYW5qTLIAcekaS9xfZrzBLF/OAkB3Qn1YQ==",
+      "requires": {
+        "internmap": "^1.0.0"
+      }
+    },
+    "d3-color": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmmirror.com/d3-color/-/d3-color-2.0.0.tgz",
+      "integrity": "sha512-SPXi0TSKPD4g9tw0NMZFnR95XVgUZiBH+uUTqQuDu1OsE2zomHU7ho0FISciaPvosimixwHFl3WHLGabv6dDgQ=="
+    },
+    "d3-dsv": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmmirror.com/d3-dsv/-/d3-dsv-2.0.0.tgz",
+      "integrity": "sha512-E+Pn8UJYx9mViuIUkoc93gJGGYut6mSDKy2+XaPwccwkRGlR+LO97L2VCCRjQivTwLHkSnAJG7yo00BWY6QM+w==",
+      "requires": {
+        "commander": "2",
+        "iconv-lite": "0.4",
+        "rw": "1"
+      }
+    },
+    "d3-format": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmmirror.com/d3-format/-/d3-format-2.0.0.tgz",
+      "integrity": "sha512-Ab3S6XuE/Q+flY96HXT0jOXcM4EAClYFnRGY5zsjRGNy6qCYrQsMffs7cV5Q9xejb35zxW5hf/guKw34kvIKsA=="
+    },
+    "d3-interpolate": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmmirror.com/d3-interpolate/-/d3-interpolate-2.0.1.tgz",
+      "integrity": "sha512-c5UhwwTs/yybcmTpAVqwSFl6vrQ8JZJoT5F7xNFK9pymv5C0Ymcc9/LIJHtYIggg/yS9YHw8i8O8tgb9pupjeQ==",
+      "requires": {
+        "d3-color": "1 - 2"
+      }
+    },
+    "d3-path": {
+      "version": "2.0.0"
+    },
+    "d3-scale": {
+      "version": "3.3.0",
+      "resolved": "https://registry.npmmirror.com/d3-scale/-/d3-scale-3.3.0.tgz",
+      "integrity": "sha512-1JGp44NQCt5d1g+Yy+GeOnZP7xHo0ii8zsQp6PGzd+C1/dl0KGsp9A7Mxwp+1D1o4unbTTxVdU/ZOIEBoeZPbQ==",
+      "requires": {
+        "d3-array": "^2.3.0",
+        "d3-format": "1 - 2",
+        "d3-interpolate": "1.2.0 - 2",
+        "d3-time": "^2.1.1",
+        "d3-time-format": "2 - 3"
+      }
+    },
+    "d3-shape": {
+      "version": "2.1.0",
+      "requires": {
+        "d3-path": "1 - 2"
+      }
+    },
+    "d3-time": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmmirror.com/d3-time/-/d3-time-2.1.1.tgz",
+      "integrity": "sha512-/eIQe/eR4kCQwq7yxi7z4c6qEXf2IYGcjoWB5OOQy4Tq9Uv39/947qlDcN2TLkiTzQWzvnsuYPB9TrWaNfipKQ==",
+      "requires": {
+        "d3-array": "2"
+      }
+    },
+    "d3-time-format": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmmirror.com/d3-time-format/-/d3-time-format-3.0.0.tgz",
+      "integrity": "sha512-UXJh6EKsHBTjopVqZBhFysQcoXSv/5yLONZvkQ5Kk3qbwiUYkdX17Xa1PT6U1ZWXGGfB1ey5L8dKMlFq2DO0Ag==",
+      "requires": {
+        "d3-time": "1 - 2"
+      }
+    },
+    "iconv-lite": {
+      "version": "0.4.24",
+      "resolved": "https://registry.npmmirror.com/iconv-lite/-/iconv-lite-0.4.24.tgz",
+      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
+      "requires": {
+        "safer-buffer": ">= 2.1.2 < 3"
+      }
+    },
+    "internmap": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmmirror.com/internmap/-/internmap-1.0.1.tgz",
+      "integrity": "sha512-lDB5YccMydFBtasVtxnZ3MRBHuaoE8GKsppq+EchKL2U4nK/DmEpPHNH8MZe5HkMtpSiTSOZwfN0tzYjO/lJEw=="
+    },
+    "node-fetch": {
+      "version": "2.6.7",
+      "resolved": "https://registry.npmmirror.com/node-fetch/-/node-fetch-2.6.7.tgz",
+      "integrity": "sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==",
+      "requires": {
+        "whatwg-url": "^5.0.0"
+      }
+    },
+    "rw": {
+      "version": "1.3.3",
+      "resolved": "https://registry.npmmirror.com/rw/-/rw-1.3.3.tgz",
+      "integrity": "sha512-PdhdWy89SiZogBLaw42zdeqtRJ//zFd2PgQavcICDUgJT5oW10QCRKbJ6bg4r0/UY2M6BWd5tkxuGFRvCkgfHQ=="
+    },
+    "safer-buffer": {
+      "version": "2.1.2",
+      "resolved": "https://registry.npmmirror.com/safer-buffer/-/safer-buffer-2.1.2.tgz",
+      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
+    },
+    "topojson-client": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmmirror.com/topojson-client/-/topojson-client-3.1.0.tgz",
+      "integrity": "sha512-605uxS6bcYxGXw9qi62XyrV6Q3xwbndjachmNxu8HWTtVPxZfEJN9fd/SZS1Q54Sn2y0TMyMxFj/cJINqGHrKw==",
+      "requires": {
+        "commander": "2"
+      }
+    },
+    "tr46": {
+      "version": "0.0.3",
+      "resolved": "https://registry.npmmirror.com/tr46/-/tr46-0.0.3.tgz",
+      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
+    },
+    "vega-canvas": {
+      "version": "1.2.6",
+      "resolved": "https://registry.npmmirror.com/vega-canvas/-/vega-canvas-1.2.6.tgz",
+      "integrity": "sha512-rgeYUpslYn/amIfnuv3Sw6n4BGns94OjjZNtUc9IDji6b+K8LGS/kW+Lvay8JX/oFqtulBp8RLcHN6QjqPLA9Q=="
+    },
+    "vega-format": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmmirror.com/vega-format/-/vega-format-1.0.4.tgz",
+      "integrity": "sha512-oTAeub3KWm6nKhXoYCx1q9G3K43R6/pDMXvqDlTSUtjoY7b/Gixm8iLcir5S9bPjvH40n4AcbZsPmNfL/Up77A==",
+      "requires": {
+        "d3-array": "^2.7.1",
+        "d3-format": "^2.0.0",
+        "d3-time-format": "^3.0.0",
+        "vega-time": "^2.0.3",
+        "vega-util": "^1.15.2"
+      }
+    },
+    "vega-loader": {
+      "version": "4.4.1",
+      "resolved": "https://registry.npmmirror.com/vega-loader/-/vega-loader-4.4.1.tgz",
+      "integrity": "sha512-dj65i4qlNhK0mOmjuchHgUrF5YUaWrYpx0A8kXA68lBk5Hkx8FNRztkcl07CZJ1+8V81ymEyJii9jzGbhEX0ag==",
+      "requires": {
+        "d3-dsv": "^2.0.0",
+        "node-fetch": "^2.6.1",
+        "topojson-client": "^3.1.0",
+        "vega-format": "^1.0.4",
+        "vega-util": "^1.16.0"
+      }
+    },
+    "vega-scale": {
+      "version": "7.1.1",
+      "resolved": "https://registry.npmmirror.com/vega-scale/-/vega-scale-7.1.1.tgz",
+      "integrity": "sha512-yE0to0prA9E5PBJ/XP77TO0BMkzyUVyt7TH5PAwj+CZT7PMsMO6ozihelRhoIiVcP0Ae/ByCEQBUQkzN5zJ0ZA==",
+      "requires": {
+        "d3-array": "^2.7.1",
+        "d3-interpolate": "^2.0.1",
+        "d3-scale": "^3.2.2",
+        "vega-time": "^2.0.4",
+        "vega-util": "^1.15.2"
+      }
+    },
+    "vega-time": {
+      "version": "2.0.4",
+      "resolved": "https://registry.npmmirror.com/vega-time/-/vega-time-2.0.4.tgz",
+      "integrity": "sha512-U314UDR9+ZlWrD3KBaeH+j/c2WSMdvcZq5yJfFT0yTg1jsBKAQBYFGvl+orackD8Zx3FveHOxx3XAObaQeDX+Q==",
+      "requires": {
+        "d3-array": "^2.7.1",
+        "d3-time": "^2.0.0",
+        "vega-util": "^1.15.2"
+      }
+    },
+    "vega-util": {
+      "version": "1.17.0",
+      "resolved": "https://registry.npmmirror.com/vega-util/-/vega-util-1.17.0.tgz",
+      "integrity": "sha512-HTaydZd9De3yf+8jH66zL4dXJ1d1p5OIFyoBzFiOli4IJbwkL1jrefCKz6AHDm1kYBzDJ0X4bN+CzZSCTvNk1w=="
+    },
+    "webidl-conversions": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmmirror.com/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
+      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
+    },
+    "whatwg-url": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmmirror.com/whatwg-url/-/whatwg-url-5.0.0.tgz",
+      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
+      "requires": {
+        "tr46": "~0.0.3",
+        "webidl-conversions": "^3.0.0"
+      }
+    }
+  }
+}
diff --git a/node_modules/vega-scenegraph/src/Handler.js b/node_modules/vega-scenegraph/src/Handler.js
index 66e8b53..f16d325 100644
--- a/node_modules/vega-scenegraph/src/Handler.js
+++ b/node_modules/vega-scenegraph/src/Handler.js
@@ -1,6 +1,6 @@
-import {domCreate} from './util/dom';
+import { domCreate } from './util/dom';
 import resolveItem from './util/resolveItem';
-import {loader} from 'vega-loader';
+import { loader } from 'vega-loader';
 
 /**
  * Create a new Handler instance.
@@ -81,12 +81,12 @@ Handler.prototype = {
   /**
    * Add an event handler. Subclasses should override this method.
    */
-  on(/*type, handler*/) {},
+  on(/*type, handler*/) { },
 
   /**
    * Remove an event handler. Subclasses should override this method.
    */
-  off(/*type, handler*/) {},
+  off(/*type, handler*/) { },
 
   /**
    * Utility method for finding the array index of an event handler.
@@ -96,7 +96,7 @@ Handler.prototype = {
    * @return {number} - The handler's array index or -1 if not registered.
    */
   _handlerIndex(h, type, handler) {
-    for (let i = h ? h.length : 0; --i>=0;) {
+    for (let i = h ? h.length : 0; --i >= 0;) {
       if (h[i].type === type && (!handler || h[i].handler === handler)) {
         return i;
       }
@@ -141,10 +141,10 @@ Handler.prototype = {
    */
   handleHref(event, item, href) {
     this._loader
-      .sanitize(href, {context:'href'})
+      .sanitize(href, { context: 'href' })
       .then(opt => {
         const e = new MouseEvent(event.type, event),
-              a = domCreate(null, 'a');
+          a = domCreate(null, 'a');
         for (const name in opt) a.setAttribute(name, opt[name]);
         a.dispatchEvent(e);
       })
@@ -160,6 +160,7 @@ Handler.prototype = {
    */
   handleTooltip(event, item, show) {
     if (item && item.tooltip != null) {
+      // Comment it to make line can show the hover all the time
       item = resolveItem(item, event, this.canvas(), this._origin);
       const value = (show && item && item.tooltip) || null;
       this._tooltip.call(this._obj, this, event, item, value);
@@ -179,13 +180,13 @@ Handler.prototype = {
     if (!el) return;
 
     const rect = el.getBoundingClientRect(),
-          origin = this._origin,
-          bounds = item.bounds,
-          width = bounds.width(),
-          height = bounds.height();
+      origin = this._origin,
+      bounds = item.bounds,
+      width = bounds.width(),
+      height = bounds.height();
 
     let x = bounds.x1 + origin[0] + rect.left,
-        y = bounds.y1 + origin[1] + rect.top;
+      y = bounds.y1 + origin[1] + rect.top;
 
     // translate coordinate for each parent group
     while (item.mark && (item = item.mark.group)) {
diff --git a/node_modules/vega-scenegraph/src/SVGHandler.js b/node_modules/vega-scenegraph/src/SVGHandler.js
index c614203..af83ab2 100644
--- a/node_modules/vega-scenegraph/src/SVGHandler.js
+++ b/node_modules/vega-scenegraph/src/SVGHandler.js
@@ -30,7 +30,7 @@ inherits(SVGHandler, Handler, {
       svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
       svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
     }
-    this._svg = svg = el && domFind(el, 'svg');
+    this._svg = svg = el && domFind(el, 'g');
     if (svg) {
       svg.addEventListener(HrefEvent, this._hrefHandler);
       svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
diff --git a/node_modules/vega-scenegraph/src/SVGRenderer.js b/node_modules/vega-scenegraph/src/SVGRenderer.js
index 2c9de04..fdafdcc 100644
--- a/node_modules/vega-scenegraph/src/SVGRenderer.js
+++ b/node_modules/vega-scenegraph/src/SVGRenderer.js
@@ -1,19 +1,19 @@
 import Renderer from './Renderer';
-import {gradientRef, isGradient, patternPrefix} from './Gradient';
+import { gradientRef, isGradient, patternPrefix } from './Gradient';
 import marks from './marks/index';
-import {ariaItemAttributes, ariaMarkAttributes} from './util/aria';
-import {cssClass, domChild, domClear, domCreate} from './util/dom';
-import {serializeXML} from './util/markup';
-import {fontFamily, fontSize, lineHeight, textLines, textValue} from './util/text';
-import {visit} from './util/visit';
+import { ariaItemAttributes, ariaMarkAttributes } from './util/aria';
+import { cssClass, domChild, domClear, domCreate } from './util/dom';
+import { serializeXML } from './util/markup';
+import { fontFamily, fontSize, lineHeight, textLines, textValue } from './util/text';
+import { visit } from './util/visit';
 import clip from './util/svg/clip';
 import metadata from './util/svg/metadata';
-import {rootAttributes, styles} from './util/svg/styles';
-import {inherits, isArray} from 'vega-util';
+import { rootAttributes, styles } from './util/svg/styles';
+import { inherits, isArray } from 'vega-util';
 
 const RootIndex = 0,
-      xmlns = 'http://www.w3.org/2000/xmlns/',
-      svgns = metadata.xmlns;
+  xmlns = 'http://www.w3.org/2000/xmlns/',
+  svgns = metadata.xmlns;
 
 export default function SVGRenderer(loader) {
   Renderer.call(this, loader);
@@ -44,13 +44,11 @@ inherits(SVGRenderer, Renderer, {
     this._clearDefs();
 
     if (el) {
-      this._svg = domChild(el, 0, 'svg', svgns);
-      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);
-      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);
-      this._svg.setAttribute('version', metadata['version']);
-      this._svg.setAttribute('class', 'marks');
+      this._svg = domChild(el, 0, 'g', svgns);
+      // this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);
+      // this._svg.setAttribute('version', metadata['version']);
+      // this._svg.setAttribute('class', 'marks');
       domClear(el, 1);
-
       // set the svg root group
       this._root = domChild(this._svg, RootIndex, 'g', svgns);
       setAttributes(this._root, rootAttributes);
@@ -116,7 +114,7 @@ inherits(SVGRenderer, Renderer, {
    */
   svg() {
     const svg = this._svg,
-          bg = this._bgcolor;
+      bg = this._bgcolor;
 
     if (!svg) return null;
 
@@ -124,7 +122,7 @@ inherits(SVGRenderer, Renderer, {
     if (bg) {
       svg.removeAttribute('style');
       node = domChild(svg, RootIndex, 'rect', svgns);
-      setAttributes(node, {width: this._width, height: this._height, fill: bg});
+      setAttributes(node, { width: this._width, height: this._height, fill: bg });
     }
 
     const text = serializeXML(svg);
@@ -192,7 +190,7 @@ inherits(SVGRenderer, Renderer, {
     const id = ++this._dirtyID;
     let item, mark, type, mdef, i, n, o;
 
-    for (i=0, n=items.length; i<n; ++i) {
+    for (i = 0, n = items.length; i < n; ++i) {
       item = items[i];
       mark = item.mark;
 
@@ -251,12 +249,12 @@ inherits(SVGRenderer, Renderer, {
     if (!this.isDirty(scene)) return scene._svg;
 
     const svg = this._svg,
-          mdef = marks[scene.marktype],
-          events = scene.interactive === false ? 'none' : null,
-          isGroup = mdef.tag === 'g';
+      mdef = marks[scene.marktype],
+      events = scene.interactive === false ? 'none' : null,
+      isGroup = mdef.tag === 'g';
 
     let sibling = null,
-        i = 0;
+      i = 0;
 
     const parent = bind(scene, el, prev, 'g', svg);
     parent.setAttribute('class', cssClass(scene));
@@ -273,7 +271,7 @@ inherits(SVGRenderer, Renderer, {
 
     const process = item => {
       const dirty = this.isDirty(item),
-            node = bind(item, parent, sibling, mdef.tag, svg);
+        node = bind(item, parent, sibling, mdef.tag, svg);
 
       if (dirty) {
         this._update(mdef, node, item);
@@ -354,10 +352,10 @@ inherits(SVGRenderer, Renderer, {
    */
   defs() {
     const svg = this._svg,
-          defs = this._defs;
+      defs = this._defs;
 
     let el = defs.el,
-        index = 0;
+      index = 0;
 
     for (const id in defs.gradient) {
       if (!el) defs.el = (el = domChild(svg, RootIndex + 1, 'defs', svgns));
@@ -389,7 +387,7 @@ inherits(SVGRenderer, Renderer, {
 
 // mark ancestor chain with a dirty id
 function dirtyParents(item, id) {
-  for (; item && item.dirty !== id; item=item.mark.group) {
+  for (; item && item.dirty !== id; item = item.mark.group) {
     item.dirty = id;
     if (item.mark && item.mark.dirty !== id) {
       item.mark.dirty = id;
@@ -443,7 +441,7 @@ function updateGradient(el, grad, index) {
     });
   }
 
-  for (i=0, n=grad.stops.length; i<n; ++i) {
+  for (i = 0, n = grad.stops.length; i < n; ++i) {
     stop = domChild(el, i, 'stop', svgns);
     stop.setAttribute('offset', grad.stops[i].offset);
     stop.setAttribute('stop-color', grad.stops[i].color);
@@ -465,7 +463,7 @@ function updateClipping(el, clip, index) {
     mask.setAttribute('d', clip.path);
   } else {
     mask = domChild(el, 0, 'rect', svgns);
-    setAttributes(mask, {x: 0, y: 0, width: clip.width, height: clip.height});
+    setAttributes(mask, { x: 0, y: 0, width: clip.width, height: clip.height });
   }
   domClear(el, 1);
 
@@ -499,7 +497,7 @@ function bind(item, el, sibling, tag, svg) {
 
     if (item.mark) {
       node.__data__ = item;
-      node.__values__ = {fill: 'default'};
+      node.__values__ = { fill: 'default' };
 
       // if group, create background, content, and foreground elements
       if (tag === 'g') {
@@ -514,7 +512,7 @@ function bind(item, el, sibling, tag, svg) {
         const fg = domCreate(doc, 'path', svgns);
         node.appendChild(fg);
         fg.__data__ = item;
-        fg.__values__ = {fill: 'default'};
+        fg.__values__ = { fill: 'default' };
       }
     }
   }
@@ -537,7 +535,7 @@ function siblingCheck(node, sibling) {
 // -- Set attributes & styles on SVG elements ---
 
 let element = null, // temp var for current SVG element
-    values = null;  // temp var for current values hash
+  values = null;  // temp var for current values hash
 
 // Extra configuration for certain mark types
 const mark_extras = {
@@ -687,5 +685,5 @@ function href() {
   let loc;
   return typeof window === 'undefined' ? ''
     : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length)
-    : loc.href;
+      : loc.href;
 }
diff --git a/node_modules/vega-scenegraph/src/SVGStringRenderer.js b/node_modules/vega-scenegraph/src/SVGStringRenderer.js
index ba21d2e..8c2e08c 100644
--- a/node_modules/vega-scenegraph/src/SVGStringRenderer.js
+++ b/node_modules/vega-scenegraph/src/SVGStringRenderer.js
@@ -1,15 +1,15 @@
 import Renderer from './Renderer';
-import {gradientRef, isGradient, patternPrefix} from './Gradient';
+import { gradientRef, isGradient, patternPrefix } from './Gradient';
 import Marks from './marks/index';
-import {ariaItemAttributes, ariaMarkAttributes} from './util/aria';
-import {cssClass} from './util/dom';
-import {markup} from './util/markup';
-import {fontFamily, fontSize, lineHeight, textLines, textValue} from './util/text';
-import {visit} from './util/visit';
+import { ariaItemAttributes, ariaMarkAttributes } from './util/aria';
+import { cssClass } from './util/dom';
+import { markup } from './util/markup';
+import { fontFamily, fontSize, lineHeight, textLines, textValue } from './util/text';
+import { visit } from './util/visit';
 import clip from './util/svg/clip';
 import metadata from './util/svg/metadata';
-import {rootAttributes, styles} from './util/svg/styles';
-import {extend, inherits, isArray} from 'vega-util';
+import { rootAttributes, styles } from './util/svg/styles';
+import { extend, inherits, isArray } from 'vega-util';
 
 export default function SVGStringRenderer(loader) {
   Renderer.call(this, loader);
@@ -37,20 +37,19 @@ inherits(SVGStringRenderer, Renderer, {
     const m = markup();
 
     // svg tag
-    m.open('svg', extend({}, metadata, {
-      class:   'marks',
-      width:   this._width * this._scale,
-      height:  this._height * this._scale,
+    m.open('g', extend({}, metadata, {
+      class: 'marks',
+      width: this._width * this._scale,
+      height: this._height * this._scale,
       viewBox: `0 0 ${this._width} ${this._height}`
     }));
-
     // background, if defined
     const bg = this._bgcolor;
     if (bg && bg !== 'transparent' && bg !== 'none') {
       m.open('rect', {
-        width:  this._width,
+        width: this._width,
         height: this._height,
-        fill:   bg
+        fill: bg
       }).close();
     }
 
@@ -77,8 +76,8 @@ inherits(SVGStringRenderer, Renderer, {
    */
   mark(m, scene) {
     const mdef = Marks[scene.marktype],
-          tag  = mdef.tag,
-          attrList = [ariaItemAttributes, mdef.attr];
+      tag = mdef.tag,
+      attrList = [ariaItemAttributes, mdef.attr];
 
     // render opening group tag
     m.open('g',
@@ -106,9 +105,9 @@ inherits(SVGStringRenderer, Renderer, {
         const tl = textLines(item);
         if (isArray(tl)) {
           // multi-line text
-          const attrs = {x: 0, dy: lineHeight(item)};
-          for (let i=0; i<tl.length; ++i) {
-            m.open('tspan', i ? attrs: null)
+          const attrs = { x: 0, dy: lineHeight(item) };
+          for (let i = 0; i < tl.length; ++i) {
+            m.open('tspan', i ? attrs : null)
               .text(textValue(item, tl[i]))
               .close();
           }
@@ -118,8 +117,8 @@ inherits(SVGStringRenderer, Renderer, {
         }
       } else if (tag === 'g') {
         const fore = item.strokeForeground,
-              fill = item.fill,
-              stroke = item.stroke;
+          fill = item.fill,
+          stroke = item.stroke;
 
         if (fore && stroke) {
           item.stroke = null;
@@ -199,9 +198,9 @@ inherits(SVGStringRenderer, Renderer, {
    */
   attr(scene, item, attrs, tag) {
     const object = {},
-          emit = (name, value, ns, prefixed) => {
-            object[prefixed || name] = value;
-          };
+      emit = (name, value, ns, prefixed) => {
+        object[prefixed || name] = value;
+      };
 
     // apply mark specific attributes
     if (Array.isArray(attrs)) {
@@ -226,8 +225,8 @@ inherits(SVGStringRenderer, Renderer, {
    */
   defs(m) {
     const gradient = this._defs.gradient,
-          clipping = this._defs.clipping,
-          count = Object.keys(gradient).length + Object.keys(clipping).length;
+      clipping = this._defs.clipping,
+      count = Object.keys(gradient).length + Object.keys(clipping).length;
 
     if (count === 0) return; // nothing to do
 
@@ -235,7 +234,7 @@ inherits(SVGStringRenderer, Renderer, {
 
     for (const id in gradient) {
       const def = gradient[id],
-            stops = def.stops;
+        stops = def.stops;
 
       if (def.gradient === 'radial') {
         // SVG radial gradients automatically transform to normalized bbox
@@ -252,9 +251,9 @@ inherits(SVGStringRenderer, Renderer, {
         });
 
         m.open('rect', {
-          width:  '1',
+          width: '1',
           height: '1',
-          fill:   'url(#' + id + ')'
+          fill: 'url(#' + id + ')'
         }).close();
 
         m.close(); // </pattern>
@@ -291,7 +290,7 @@ inherits(SVGStringRenderer, Renderer, {
     for (const id in clipping) {
       const def = clipping[id];
 
-      m.open('clipPath', {id: id});
+      m.open('clipPath', { id: id });
       if (def.path) {
         m.open('path', {
           d: def.path
diff --git a/node_modules/vega-scenegraph/src/util/resolveItem.js b/node_modules/vega-scenegraph/src/util/resolveItem.js
index d088245..6cd106d 100644
--- a/node_modules/vega-scenegraph/src/util/resolveItem.js
+++ b/node_modules/vega-scenegraph/src/util/resolveItem.js
@@ -1,10 +1,10 @@
 import marks from '../marks/index';
 import point from './point';
 
-export default function(item, event, el, origin) {
+export default function (item, event, el, origin) {
   var mark = item && item.mark,
-      mdef, p;
-
+    mdef, p;
+  let item_back = item;
   if (mark && (mdef = marks[mark.marktype]).tip) {
     p = point(event, el);
     p[0] -= origin[0];
@@ -14,6 +14,9 @@ export default function(item, event, el, origin) {
       p[1] -= item.y || 0;
     }
     item = mdef.tip(mark.items, p);
+    if (!item) {
+      item = item_back;
+    }
   }
 
   return item;
